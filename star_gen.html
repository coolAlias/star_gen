<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>Star System Generator</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="robots" content="index, follow">
		<style>
			h1, h2, h3, h4 {
				margin: 0px;
			}
			table {
				border-collapse: collapse;
				margin: 8px 0px 8px 0px;
			}
			table, th, td {
				border: 1px solid;
				padding: 4px;
			}
			thead tr {
				background-color: #E7E9EB;
			}
			th {
				word-wrap: normal;
			}
			tbody tr:nth-child(2n) {
				background-color: #E8E8E8;
			}
			tr.candidate {
				background-color: #98FB98 !important;
			}
			label {
				display: block;
				font-weight: bold;
				padding-bottom: 2px;
			}
			input[type=number], input[type=text] {
				min-width: 4rem;
				padding: 2px;
			}
			input[type=checkbox] {
				display: inline-block;
				transform: scale(1.25);
			}
			button[type=submit] {
				font-size: 1.1rem;
				margin-top: 8px;
				padding: 4px 8px 4px 8px;
			}
			.inline {
				display: inline-block;
			}
			.block {
				display: block;
			}
			.input_container {
				max-width: max-content;
				margin-bottom: 8px;
			}
			.container {
				margin: 8px 0px 8px 0px;
				width: fit-content;
			}
			.basis-full {
				flex-basis: 100%;
			}
			.flex {
				display: flex;
			}
			.flex-row {
				align-items: center;
				flex-direction: row;
			}
			.flex-row * {
				margin-right: 8px;
			}
			.flex-wrap {
				flex-wrap: wrap;
			}
			.footnote {
				font-size: 0.8rem;
				font-style: italic;
				margin: 0;
			}
			.show-options {
				margin: 8px;
			}
			.w-60 {
				width: 60%;
			}
			.min-w-half {
				min-width: 50%;
			}
			.center {
				text-align: center;
			}
			.right {
				text-align: right;
			}
			.mb-4 {
				margin-bottom: 4px;
			}
			.small-caps {
				font-variant: small-caps;
			}
			.hide {
				display: none;
				visibility: hidden;
			}
			.show {
				display: block;
				visibility: visible;
			}
			.show-table {
				display: table-cell;
				visibility: visible;
			}
			.text-bold {
				font-weight: bold;
			}
			.text-red {
				color: red;
			}
			.text-sm {
				font-size: 0.9rem;
			}
			@media (min-width: 768px) {
				.md\:basis-1\/2 {
					flex-basis: 50%;
				}
			}
		</style>
	</head>
	<body style="padding: 5px;">
		<h1 class="small-caps">Star System Generator</h1>
		<form id="form" style="padding-bottom: 5px;" method="get" action="#" accept-charset="utf-8">
			<div class="container min-w-half">
				<div class="input_container">
					<label for="seed" class="small-caps">Seed (Optional) <input id="seed" class="inline" type="text" name="seed" /></label>
				</div>
				<h2>Continuation Method</h2>
				<hr>
				<div id="options_continuation" class="hide">
					<div class="flex flex-row">
						<div class="input_container">
							<label for="system_profile" class="small-caps">Star Profile(s) <input id="system_profile" class="inline" type="text" name="system_profile" /></label>
						</div>
						<div class="input_container">
							<label for="cont_sec"><input id="cont_sec" name="cont_sec" type="checkbox" /> Check for Secondaries</label>
						</div>
					</div>
					<div class="container">
						<h4 class="small-caps">System Planetary Profile</h4>
						<div class="flex flex-row">
							<div class="input_container">
								<label>Gas Giants</label>
								<input class="center w-60" name="cont_spp" type="number" min="0" step="1" />
							</div>
							<div class="input_container">
								<label>Belts</label>
								<input class="center w-60" name="cont_spp" type="number" min="0" step="1" />
							</div>
							<div class="input_container">
								<label>Terrestrial</label>
								<input class="center w-60" name="cont_spp" type="number" min="0" step="1" />
							</div>
							<div class="input_container">
								<label>Baseline</label>
								<input class="center w-60" name="cont_spp" type="number" step="1" />
							</div>
							<div class="input_container">
								<label>Spread</label>
								<input class="center w-60" name="cont_spp" type="number" min="0" step="0.001" />
							</div>
						</div>
					</div>
					<div class="container">
						<div class="flex flex-row">
							<div class="input_container">
								<label for="cont_uwp" class="small-caps">Main World Uwp</label>
								<input id="cont_uwp" class="block" name="cont_uwp" type="text" />
							</div>
							<div class="input_container">
								<label for="cont_temp">Temperature</label>
								<select id="cont_temp" name="cont_temp">
									<option value="7">Temperate</option>
									<option value="10">Hot</option>
									<option value="4">Cold</option>
								</select>
							</div>
							<div class="input_container">
								<label for="cont_host">Satellite of:</label>
								<select id="cont_host" name="cont_host">
									<option value="-1">Auto</option>
									<option value="1">Gas Giant</option>
									<option value="3">Terrestrial</option>
								</select>
							</div>
						</div>
						<span class="text-sm">Acceptable formats: SAH, ?SAHPGL (? = optional Starport code), or full the UWP (e.g. CA6A643-9).</span>
					</div>
					<p id="error" class="text-bold text-red hide"></p>
				</div>
				<p class="show-options"><a href="#" onclick="return toggleShowOptions(event, this, 'options_continuation')">Show More</a></p>
			</div>
			<div class="container min-w-half">
				<h2>Standard Options</h2>
				<hr>
				<div id="options_stellar" class="hide">
					<div class="flex flex-wrap">
						<div class="flex-row basis-full md:basis-1/2">
							<h3 class="small-caps mb-4">Star / System Options</h3>
							<div class="input_container">
								<label for="star_trad_gen"><input id="star_trad_gen" name="star_trad_gen" type="checkbox" checked /> Traditional Traveller Star Distributions</label>
							</div>
							<div class="input_container">
								<label for="prime_main"><input id="prime_main" name="prime_main" type="checkbox" checked /> Primary Star: Main-Sequence Only</label>
							</div>
							<div class="input_container">
								<label for="prime_peculiar">Primary Star: Peculiar Type*</label>
								<select id="prime_peculiar" class="block" name="prime_peculiar">
									<option value="0">Fine, the Universe is Weird!</option>
									<option value="1">Roll 1D: 1-5 = NS, 6 = BH</option>
									<option value="2">Reroll Unusual Result</option>
								</select>
								<span class="text-sm">* Only if Primary Star: Main-Sequence Only is NOT checked.</span>
							</div>
							<div class="input_container">
								<label for="star_flat_sub"><input id="star_flat_sub" name="star_flat_sub" type="checkbox" /> Star Subtype: Flat Roll Method</label>
							</div>
							<div class="input_container">
								<label for="var_mass"><input id="var_mass" name="var_mass" type="checkbox" checked /> Enable Variance: Mass</label>
							</div>
							<div class="input_container">
								<label for="var_temp"><input id="var_temp" name="var_temp" type="checkbox" checked /> Enable Variance: Temperature</label>
							</div>
							<div class="input_container">
								<label for="var_size"><input id="var_size" name="var_size" type="checkbox" checked /> Enable Variance: Diameter</label>
							</div>
							<div class="input_container">
								<label for="var_nits"><input id="var_nits" name="var_nits" type="checkbox" /> Enable Variance: Luminosity</label>
							</div>
							<div class="input_container">
								<label for="var_orbit"><input id="var_orbit" name="var_orbit" type="checkbox" checked /> Enable Variance: Orbit#s</label>
							</div>
							<div class="input_container">
								<label for="enable_ecc"><input id="enable_ecc" name="enable_ecc" type="checkbox" checked /> Enable Orbital Eccentricity</label>
							</div>
							<div class="input_container">
								<label for="star_age_small"><input id="star_age_small" name="star_age_small" type="checkbox" checked /> Age, Small Stars: Increase Precision</label>
							</div>
							<div class="input_container">
								<label for="star_age_large"><input id="star_age_large" name="star_age_large" type="checkbox" checked /> Age, Large Stars: Use 1D100/100</label>
							</div>
							<div class="input_container">
								<label for="sec_giant_twin">Secondary Giant bigger than Primary Giant</label>
								<select id="sec_giant_twin" class="block" name="sec_giant_twin">
									<option value="0">Use Twin method</option>
									<option value="1">Change to Class V</option>
								</select>
							</div>
						</div>
						<div class="flex-row basis-full md:basis-1/2">
							<h3 class="small-caps mb-4">Planet Options</h3>
							<div class="input_container">
								<label for="hzco_fudge"><input id="hzco_fudge" class="center" name="hzco_fudge" type="number" min="0" max="1" value="0.5" step="0.001" /> HZCO Fudge</label>
							</div>
							<div class="input_container">
								<label for="main_tier"><input id="main_tier" class="center" name="main_tier" type="number" min="0" max="1" value="0.8" step="0.001" /> Main World Candidate Threshold</label>
							</div>
							<div class="input_container">
								<label for="cumulative_orbit"><input id="cumulative_orbit" name="cumulative_orbit" type="checkbox" checked /> Cumulative Orbital Variance</label>
							</div>
							<div class="input_container">
								<label for="per_star_baseline"><input id="per_star_baseline" name="per_star_baseline" type="checkbox" checked /> Per-Star Baseline Numbers</label>
							</div>
							<div class="input_container">
								<label for="per_star_empty_orbits"><input id="per_star_empty_orbits" name="per_star_empty_orbits" type="checkbox" checked /> Per-Star Empty Orbits</label>
							</div>
							<div class="input_container">
								<label for="basic_temp"><input id="basic_temp" name="basic_temp" type="checkbox" checked /> Temperature: Basic Mean Only</label>
							</div>
							<div class="input_container">
								<label for="flat_temp"><input id="flat_temp" name="flat_temp" type="checkbox" checked /> Temperature: Flat Roll Beyond HZCO</label>
							</div>
							<div class="input_container">
								<label for="green_check"><input id="green_check" name="green_check" type="checkbox" checked /> Enable Runaway Greenhouse Effect</label>
							</div>
							<div class="input_container">
								<label for="green_inner"><input id="green_inner" name="green_inner" type="checkbox" checked /> Enable Runaway Greenhouse for all &lt; HZCO</label>
							</div>
							<div class="input_container">
								<label for="hill_moon_qty"><input id="hill_moon_qty" name="hill_moon_qty" type="checkbox" checked /> Use Hill Sphere for DM-1 per die to Moon Qty</label>
							</div>
							<div class="input_container">
								<label for="var_hr"><input id="var_hr" name="var_hr" type="checkbox" /> Habitability Rating Variance: +D3-2</label>
							</div>
							<div class="input_container">
								<label for="bio_all"><input id="bio_all" name="bio_all" type="checkbox" /> Life: Check Every World</label>
							</div>
							<div class="input_container">
								<label for="sub_moons"><input id="sub_moons" name="sub_moons" type="checkbox" /> Display Moons under Host Planet</label>
							</div>
						</div>
					</div>
				</div>
				<p class="show-options"><a href="#" onclick="return toggleShowOptions(event, this, 'options_stellar')">Show More</a></p>
			</div>
			<button type="submit" class="small-caps">Generate</button>
		</form>
		<div id="output" class="container">
			<h3 class="small-caps">Star System Data</h3>
			<p><strong>System Age</strong>: <span id="system_age"></span></p>
			<p>
				<strong>System Profile</strong>: <span id="system_profile_short"></span>
				<br>
				<span id="system_profile_long"></span>
			</p>
			<p><strong>Seed</strong>: <span id="system_seed"></span></p>
			<table>
				<thead>
					<tr>
						<th colspan="5">Objects</th>
						<th colspan="5">System Planetary Profile: <span id="system_planet_profile_short"></span></th>
					</tr><tr>
						<th>Stellar</th>
						<th>Gas Giants</th>
						<th>Planetoid Belts</th>
						<th>Terrestrials</th>
						<th>Empty</th>
						<th>Baseline #</th>
						<th>Baseline Orbit#</th>
						<th>System Spread</th>
						<th>Calculated</th>
						<th>Max Spread</th>
					</tr>
				</thead>
				<tbody>
					<td class="center" id="n_stellar">0</td>
					<td class="center" id="n_planet_gas">0</td>
					<td class="center" id="n_planet_belt">0</td>
					<td class="center" id="n_planet_rock">0</td>
					<td class="center" id="n_empty">0</td>
					<td class="center" id="baseline_number"></td>
					<td class="center" id="baseline_orbit"></td>
					<td class="center" id="system_spread"></td>
					<td class="center" id="system_spread_calc"></td>
					<td class="center" id="system_spread_max"></td>
				</tbody>
			</table>
			<table>
				<thead>
					<tr id="star_tbl_header">
						<th>Component</th>
						<th>Class</th>
						<th>Mass &odot;</th>
						<th>Diameter &odot;</th>
						<th>Temp (K)</th>
						<th>Luminosity</th>
						<th>Orbit#*</th>
						<th>AU</th>
						<th>Ecc</th>
						<th>Min</th>
						<th>Max</th>
						<th>Period</th>
						<th>HZCO</th>
						<th>Allowed Orbit#s*</th>
						<th># Slots</th>
						<th># Planets</th>
						<th class="hide toggle-per_star_baseline">Baseline #</th>
						<th class="hide toggle-per_star_baseline">Base Orbit#</th>
						<th class="hide toggle-per_star_baseline">Spread</th>
					</tr>
				</thead>
				<tbody id="star_tbl_entries">
				</tbody>
			</table>
			<p class="footnote right">* Orbit#s are measured from the object being orbited, not necessarily the primary star</p>
			<template id="star_tbl_template">
				<tr>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td class="center"></td>
					<td class="center"></td>
					<td class="center"></td>
					<td class="center"></td>
					<td class="hide center toggle-per_star_baseline"></td>
					<td class="hide center toggle-per_star_baseline"></td>
					<td class="hide center toggle-per_star_baseline"></td>
				<tr>
			</template>
			<table>
				<thead>
					<tr id="planet_tbl_header">
						<th>Primary</th>
						<th>Object</th>
						<th>Mass &CirclePlus;</th>
						<th>Diameter</th>
						<th>Density</th>
						<th>Gravity</th>
						<th>Esc V (km/s)</th>
						<th class="toggle-basic_temp hide">High (C)</th>
						<th id="th_temp_mean">Temp (C)</th>
						<th class="toggle-basic_temp hide">Low (C)</th>
						<th>Albedo</th>
						<th>Orbit#*</th>
						<th>AU</th>
						<th>Ecc</th>
						<th>Min</th>
						<th>Max</th>
						<th>Period</th>
						<th>Sidereal</th>
						<th>Solar</th>
						<th>Days / Year</th>
						<th>Axial Tilt</th>
						<th>SAH/UWP</th>
						<th>Sub</th>
						<th>Notes</th>
					</tr>
				</thead>
				<tbody id="planet_tbl_entries">
				</tbody>
			</table>
			<template id="planet_tbl_template">
				<tr>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td class="toggle-basic_temp hide"></td>
					<td></td>
					<td class="toggle-basic_temp hide"></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
				<tr>
			</template>
		</div>
		<div id="main_world_candidates" class="container hide">
			<h3 class="small-caps">Main World Candidate(s)</h3>
			<hr>
			<span>Minimum to Qualify: <span id="main_world_min"></span></span>
			<table id="main_world_tbl">
				<thead>
					<tr>
						<th>Score</th>
						<th>Primary</th>
						<th>Object</th>
						<th>SAH/UWP</th>
						<th>HZ?</th>
						<th>Habitability</th>
						<th>Resources</th>
						<th>Biomass</th>
						<th>Complexity</th>
						<th>Diversity</th>
						<th>Compatibility</th>
						<th>Sophonts</th>
						<th>Greenhouse Factor</th>
						<th>Surface Distribution</th>
					</tr>
				</thead>
				<tbody id="main_world_tbl_entries">
				</tbody>
			</table>
			<template id="main_world_row_template">
				<tr>
					<td class="right"></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
				<tr>
			</template>
		</div>
		<div id="roll_history" class="container">
		</div>
		<template id="roll_tbl_template">
			<table>
				<thead>
					<tr>
						<th>Result</th>
						<th>Dice</th>
						<th>DM</th>
						<th>Roll(s)</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
				</tbody>
			</table>
		</template>
		<template id="roll_row_template">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
			<tr>
		</template>
	</body>
</html>
<script>
const debug = true;

// Astronomical Unit, in km
const AU = 149597870.9;

// Radius of Sol in AU
const SOL_RADIUS_AU = 0.00465;

// Diameter of Sol in km, i.e. 1 "standard" stellar unit of Diameter
const SOL_DIAMETER = 1391400;

// Diameter of Terra in km, i.e. 1 "standard" planetary unit of Diameter
const TERRA_DIAMETER = 12742;

// Conversion rate between Terran and Solar units of Diameter
const TERRA_DIAMETER_TO_SOL = 0.009;

// Mass of Terra in kg, i.e. 1 "standard" planetary unit of Mass
const TERRA_MASS = 5.972E24;

// Conversion rate between Terran and Solar units of Mass
const TERRA_MASS_TO_SOL = 0.00000303;

// Density of Terra in g/cm³
const TERRA_DENSITY = 5.514;

// Gravity of Terra in m/s²
const TERRA_GRAVITY = 9.8066;

/** Array Index = whole Orbit# */
const ORBIT_AU = [
	0,
	0.4,
	0.7,
	1.0,
	1.6,
	2.8,
	5.2,
	10,
	20,
	40,
	77,
	154,
	308,
	615,
	1230,
	2500,
	4900,
	9800,
	19500,
	39500,
	78700,
];

// Main Sequence Stars
const MAIN_TYPE_O  =  0;
const MAIN_TYPE_B  =  1;
const MAIN_TYPE_A  =  2;
const MAIN_TYPE_F  =  3;
const MAIN_TYPE_G  =  4;
const MAIN_TYPE_K  =  5;
const MAIN_TYPE_M  =  6;
// Failed Star; includes types L, T, and Y
const BROWN_DWARF  =  8; // See note below on why White Dwarf = 7
// Post-Stellar objects, i.e. dead stars
const WHITE_DWARF  =  7; // Because this is sort of maybe sometimes considered Type VII and in some cases is the next progression
const PULSAR       =  9; // Technically a type of Neutron Star, but listed separately for some reason
const NEUTRON_STAR = 10;
const BLACK_HOLE   = 11;
// Particularly Peculiar Types
const PROTOSTAR    = 12;
const NEBULA       = 13;
const STAR_CLUSTER = 14;
const ANOMALY      = 15;

const STAR_NAME = {
	[MAIN_TYPE_O]: 'Type O',
	[MAIN_TYPE_B]: 'Type B',
	[MAIN_TYPE_A]: 'Type A',
	[MAIN_TYPE_F]: 'Type F',
	[MAIN_TYPE_G]: 'Type G',
	[MAIN_TYPE_K]: 'Type K',
	[MAIN_TYPE_M]: 'Type M',
	[WHITE_DWARF]: 'White Dwarf',
	[BROWN_DWARF]: 'Brown Dwarf',
	[PULSAR]:      'Pulsar',
	[NEUTRON_STAR]:'Neutron Star',
	[BLACK_HOLE]:  'Black Hole',
	[PROTOSTAR]:   'Protostar',
	[NEBULA]:      'Nebula',
	[STAR_CLUSTER]:'Star Cluster',
	[ANOMALY]:     'Anomaly',
};

const STAR_TYPE = {
	[MAIN_TYPE_O]: 'O',
	[MAIN_TYPE_B]: 'B',
	[MAIN_TYPE_A]: 'A',
	[MAIN_TYPE_F]: 'F',
	[MAIN_TYPE_G]: 'G',
	[MAIN_TYPE_K]: 'K',
	[MAIN_TYPE_M]: 'M',
	[WHITE_DWARF]: 'D', 
	[BROWN_DWARF]: 'BD', 
	[PULSAR]:      'PSR',
	[NEUTRON_STAR]:'NS',
	[BLACK_HOLE]:  'BH',
	[PROTOSTAR]:   'P',
	[NEBULA]:      'N',
	[STAR_CLUSTER]:'SC',
	[ANOMALY]:     'X',
};

const TYPE_HOT = {
	 2: MAIN_TYPE_A,
	 3: MAIN_TYPE_A,
	 4: MAIN_TYPE_A,
	 5: MAIN_TYPE_A,
	 6: MAIN_TYPE_A,
	 7: MAIN_TYPE_A,
	 8: MAIN_TYPE_A,
	 9: MAIN_TYPE_A,
	10: MAIN_TYPE_B,
	11: MAIN_TYPE_B,
	12: MAIN_TYPE_O,
};

const TYPE_PECULIAR = {
	 2: BLACK_HOLE,
	 3: PULSAR,
	 4: NEUTRON_STAR,
	 5: NEBULA,
	 6: NEBULA,
	 7: PROTOSTAR,
	 8: PROTOSTAR,
	 9: PROTOSTAR,
	10: STAR_CLUSTER,
	11: ANOMALY,
	12: ANOMALY,
};

const TYPE_REAL = {
	 2: -1, // roll on Special or, if allowed, Unusual
	 3: MAIN_TYPE_M,
	 4: MAIN_TYPE_M,
	 5: MAIN_TYPE_M,
	 6: MAIN_TYPE_M,
	 7: MAIN_TYPE_M,
	 8: MAIN_TYPE_M,
	 9: MAIN_TYPE_K,
	10: MAIN_TYPE_G,
	11: MAIN_TYPE_F,
	12: 16, // Roll on Hot
	13: 16, // Roll on Hot
};

const TYPE_TRAD = {
	 2: -1, // roll on Special or, if allowed, Unusual
	 3: MAIN_TYPE_M,
	 4: MAIN_TYPE_M,
	 5: MAIN_TYPE_M,
	 6: MAIN_TYPE_M,
	 7: MAIN_TYPE_K,
	 8: MAIN_TYPE_K,
	 9: MAIN_TYPE_G,
	10: MAIN_TYPE_G,
	11: MAIN_TYPE_F,
	12: 16, // Roll on Hot
	13: 16, // Roll on Hot
};

const STAR_CLASS = {
	// 0, Ia+, and Iab are not included at this time
	0: 'Ia',
	1: 'Ib',
	2: 'II',
	3: 'III',
	4: 'IV',
	5: 'V',
	6: 'VI',
	// Special cases used temporarily during generation; they ultimately use -1 as their Classification
	[WHITE_DWARF]: 'D',
	[BROWN_DWARF]: 'BD',
};

const CLASS_GIANT = {
	 2: 3,
	 3: 3,
	 4: 3,
	 5: 3,
	 6: 3,
	 7: 3,
	 8: 3,
	 9: 2,
	10: 2,
	11: 1,
	12: 0,
};

const CLASS_SPECIAL = {
	 2:  6,
	 3:  6,
	 4:  6,
	 5:  6,
	 6:  4,
	 7:  4,
	 8:  4,
	 9:  3,
	10:  3,
	11: 16, // roll on Giant
	12: 16, // roll on Giant
};

const CLASS_UNUSUAL = {
	 2: -1, // roll on Peculiar (returns a Type instead of Class)
	 3:  6, // Class VI
	 4:  4, // Class IV
	 5:  BROWN_DWARF,
	 6:  BROWN_DWARF,
	 7:  BROWN_DWARF,
	 8:  WHITE_DWARF,
	 9:  WHITE_DWARF,
	10:  WHITE_DWARF,
	11:  3, // Class III
	12: 16, // roll on Giant
};

const SUBTYPE_M_PRIMARY = {
	 2: 8,
	 3: 6,
	 4: 5,
	 5: 4,
	 6: 0,
	 7: 2,
	 8: 1,
	 9: 3,
	10: 5,
	11: 7,
	12: 9,
};

const SUBTYPE_NUMERIC = {
	 2: 0,
	 3: 1,
	 4: 3,
	 5: 5,
	 6: 7,
	 7: 9,
	 8: 8,
	 9: 6,
	10: 4,
	11: 2,
	12: 0,
};

// [Type][Class][Subtype]['M': Mass, 'T': Temperature, 'L': Luminosity', 'D': Diameter]
const STAR_DATA = {
	0: {
		0: {
			0: {'M': 200, 'T': 50000, 'L': 3400000, 'D': 25.0,},
			1: {'M': 176, 'T': 48000, 'L': 2940000, 'D': 24.4,},
			2: {'M': 152, 'T': 46000, 'L': 2480000, 'D': 23.8,},
			3: {'M': 128, 'T': 44000, 'L': 2020000, 'D': 23.2,},
			4: {'M': 104, 'T': 42000, 'L': 1560000, 'D': 22.6,},
			5: {'M':  80, 'T': 40000, 'L': 1100000, 'D': 22.0,},
			6: {'M':  76, 'T': 38000, 'L':  938000, 'D': 21.6,},
			7: {'M':  72, 'T': 36000, 'L':  776000, 'D': 21.2,},
			8: {'M':  68, 'T': 34000, 'L':  614000, 'D': 20.8,},
			9: {'M':  64, 'T': 32000, 'L':  452000, 'D': 20.4,},
		},
		1: {
			0: {'M': 150, 'T': 50000, 'L': 3200000, 'D': 24.0,},
			1: {'M': 132, 'T': 48000, 'L': 2740000, 'D': 23.2,},
			2: {'M': 114, 'T': 46000, 'L': 2280000, 'D': 22.4,},
			3: {'M':  96, 'T': 44000, 'L': 1820000, 'D': 21.6,},
			4: {'M':  78, 'T': 42000, 'L': 1360000, 'D': 20.8,},
			5: {'M':  60, 'T': 40000, 'L':  900000, 'D': 20.0,},
			6: {'M':  56, 'T': 38000, 'L':  748000, 'D': 18.8,},
			7: {'M':  52, 'T': 36000, 'L':  596000, 'D': 17.6,},
			8: {'M':  48, 'T': 34000, 'L':  444000, 'D': 16.4,},
			9: {'M':  44, 'T': 32000, 'L':  292000, 'D': 15.2,},
		},
		2: {
			0: {'M': 130, 'T': 50000, 'L': 2700000, 'D': 22.0,},
			1: {'M': 112, 'T': 48000, 'L': 2306000, 'D': 21.2,},
			2: {'M':  94, 'T': 46000, 'L': 1912000, 'D': 20.4,},
			3: {'M':  76, 'T': 44000, 'L': 1518000, 'D': 19.6,},
			4: {'M':  58, 'T': 42000, 'L': 1124000, 'D': 18.8,},
			5: {'M':  40, 'T': 40000, 'L':  730000, 'D': 18.0,},
			6: {'M':  38, 'T': 38000, 'L':  604000, 'D': 16.8,},
			7: {'M':  36, 'T': 36000, 'L':  478000, 'D': 15.6,},
			8: {'M':  34, 'T': 34000, 'L':  352000, 'D': 14.4,},
			9: {'M':  32, 'T': 32000, 'L':  226000, 'D': 13.2,},
		},
		3: {
			0: {'M': 110, 'T': 50000, 'L': 2400000, 'D': 21.0,},
			1: {'M':  94, 'T': 48000, 'L': 2022000, 'D': 19.8,},
			2: {'M':  78, 'T': 46000, 'L': 1644000, 'D': 18.6,},
			3: {'M':  62, 'T': 44000, 'L': 1266000, 'D': 17.4,},
			4: {'M':  46, 'T': 42000, 'L':  888000, 'D': 16.2,},
			5: {'M':  30, 'T': 40000, 'L':  510000, 'D': 15.0,},
			6: {'M':  28, 'T': 38000, 'L':  422400, 'D': 14.0,},
			7: {'M':  26, 'T': 36000, 'L':  334800, 'D': 13.0,},
			8: {'M':  24, 'T': 34000, 'L':  247200, 'D': 12.0,},
			9: {'M':  22, 'T': 32000, 'L':  159600, 'D': 11.0,},
		},
		4: {
			// N/A
		},
		5: {
			0: {'M': 90.0, 'T': 50000, 'L': 2200000, 'D': 20.0,},
			1: {'M': 84.0, 'T': 48000, 'L': 1826000, 'D': 18.4,},
			2: {'M': 78.0, 'T': 46000, 'L': 1452000, 'D': 16.8,},
			3: {'M': 72.0, 'T': 44000, 'L': 1078000, 'D': 15.2,},
			4: {'M': 66.0, 'T': 42000, 'L':  704000, 'D': 13.6,},
			5: {'M': 60.0, 'T': 40000, 'L':  330000, 'D': 12.0,},
			6: {'M': 51.6, 'T': 38000, 'L':  271000, 'D': 11.0,},
			7: {'M': 43.2, 'T': 36000, 'L':  212000, 'D': 10.0,},
			8: {'M': 34.8, 'T': 34000, 'L':  153000, 'D':  9.0,},
			9: {'M': 26.4, 'T': 32000, 'L':   94000, 'D':  8.0,},
		},
		6: {
			0: {'M': 2.0, 'T': 50000, 'L': 180.0, 'D': 0.180,},
			1: {'M': 1.9, 'T': 48000, 'L': 158.6, 'D': 0.180,},
			2: {'M': 1.8, 'T': 46000, 'L': 137.2, 'D': 0.180,},
			3: {'M': 1.7, 'T': 44000, 'L': 115.8, 'D': 0.180,},
			4: {'M': 1.6, 'T': 42000, 'L':  94.4, 'D': 0.180,},
			5: {'M': 1.5, 'T': 40000, 'L':  73.0, 'D': 0.180,},
			6: {'M': 1.3, 'T': 38000, 'L':  64.2, 'D': 0.184,},
			7: {'M': 1.1, 'T': 36000, 'L':  55.4, 'D': 0.188,},
			8: {'M': 0.9, 'T': 34000, 'L':  46.6, 'D': 0.192,},
			9: {'M': 0.7, 'T': 32000, 'L':  37.8, 'D': 0.196,},
		},
	},
	1: {
		0: {
			0: {'M': 60, 'T': 30000, 'L': 290000, 'D':  20,},
			1: {'M': 54, 'T': 27000, 'L': 264000, 'D':  28,},
			2: {'M': 48, 'T': 24000, 'L': 238000, 'D':  36,},
			3: {'M': 42, 'T': 21000, 'L': 212000, 'D':  44,},
			4: {'M': 36, 'T': 18000, 'L': 186000, 'D':  52,},
			5: {'M': 30, 'T': 15000, 'L': 160000, 'D':  60,},
			6: {'M': 28, 'T': 14000, 'L': 154000, 'D':  72,},
			7: {'M': 26, 'T': 13000, 'L': 148000, 'D':  84,},
			8: {'M': 24, 'T': 12000, 'L': 142000, 'D':  96,},
			9: {'M': 22, 'T': 11000, 'L': 136000, 'D': 108,},
		},
		1: {
			0: {'M': 40, 'T': 30000, 'L': 140000, 'D': 14.0,},
			1: {'M': 37, 'T': 27000, 'L': 117600, 'D': 16.2,},
			2: {'M': 34, 'T': 24000, 'L':  95200, 'D': 18.4,},
			3: {'M': 31, 'T': 21000, 'L':  72800, 'D': 20.6,},
			4: {'M': 28, 'T': 18000, 'L':  50400, 'D': 22.8,},
			5: {'M': 25, 'T': 15000, 'L':  28000, 'D': 25.0,},
			6: {'M': 23, 'T': 14000, 'L':  26800, 'D': 30.0,},
			7: {'M': 21, 'T': 13000, 'L':  25600, 'D': 35.0,},
			8: {'M': 19, 'T': 12000, 'L':  24400, 'D': 40.0,},
			9: {'M': 17, 'T': 11000, 'L':  23200, 'D': 45.0,},
		},
		2: {
			0: {'M': 30.0, 'T': 30000, 'L': 100000, 'D': 12.0,},
			1: {'M': 28.0, 'T': 27000, 'L':  81760, 'D': 12.4,},
			2: {'M': 26.0, 'T': 24000, 'L':  63520, 'D': 12.8,},
			3: {'M': 24.0, 'T': 21000, 'L':  45280, 'D': 13.2,},
			4: {'M': 22.0, 'T': 18000, 'L':  27040, 'D': 13.6,},
			5: {'M': 20.0, 'T': 15000, 'L':   8800, 'D': 14.0,},
			6: {'M': 18.8, 'T': 14000, 'L':   8640, 'D': 17.2,},
			7: {'M': 17.6, 'T': 13000, 'L':   8480, 'D': 20.4,},
			8: {'M': 16.4, 'T': 12000, 'L':   8320, 'D': 23.6,},
			9: {'M': 15.2, 'T': 11000, 'L':   8160, 'D': 26.8,},
		},
		3: {
			0: {'M': 20.0, 'T': 30000, 'L': 72000, 'D': 10.0,},
			1: {'M': 18.0, 'T': 27000, 'L': 57920, 'D':  9.2,},
			2: {'M': 16.0, 'T': 24000, 'L': 43840, 'D':  8.4,},
			3: {'M': 14.0, 'T': 21000, 'L': 29760, 'D':  7.6,},
			4: {'M': 12.0, 'T': 18000, 'L': 15680, 'D':  6.8,},
			5: {'M': 10.0, 'T': 15000, 'L':  1600, 'D':  6.0,},
			6: {'M':  9.6, 'T': 14000, 'L':  1324, 'D':  5.8,},
			7: {'M':  9.2, 'T': 13000, 'L':  1048, 'D':  5.6,},
			8: {'M':  8.8, 'T': 12000, 'L':   772, 'D':  5.4,},
			9: {'M':  8.4, 'T': 11000, 'L':   496, 'D':  5.2,},
		},
		4: {
			0: {'M': 20.0, 'T': 30000, 'L': 46000, 'D': 8.0,},
			1: {'M': 18.0, 'T': 27000, 'L': 37020, 'D': 7.4,},
			2: {'M': 16.0, 'T': 24000, 'L': 28040, 'D': 6.8,},
			3: {'M': 14.0, 'T': 21000, 'L': 19060, 'D': 6.2,},
			4: {'M': 12.0, 'T': 18000, 'L': 10080, 'D': 5.6,},
			5: {'M': 10.0, 'T': 15000, 'L':  1100, 'D': 5.0,},
			6: {'M':  8.8, 'T': 14000, 'L':   908, 'D': 4.8,},
			7: {'M':  7.6, 'T': 13000, 'L':   716, 'D': 4.6,},
			8: {'M':  6.4, 'T': 12000, 'L':   524, 'D': 4.4,},
			9: {'M':  5.2, 'T': 11000, 'L':   332, 'D': 4.2,},
		},
		5: {
			0: {'M': 18.00, 'T': 30000, 'L': 35000.0, 'D': 7.00,},
			1: {'M': 15.40, 'T': 27000, 'L': 28110.0, 'D': 6.30,},
			2: {'M': 12.80, 'T': 24000, 'L': 21220.0, 'D': 5.60,},
			3: {'M': 10.20, 'T': 21000, 'L': 14330.0, 'D': 4.90,},
			4: {'M':  7.60, 'T': 18000, 'L':  7440.0, 'D': 4.20,},
			5: {'M':  5.00, 'T': 15000, 'L':   550.0, 'D': 3.50,},
			6: {'M':  4.44, 'T': 14000, 'L':   448.6, 'D': 3.24,},
			7: {'M':  3.88, 'T': 13000, 'L':   347.2, 'D': 2.98,},
			8: {'M':  3.32, 'T': 12000, 'L':   245.8, 'D': 2.72,},
			9: {'M':  2.76, 'T': 11000, 'L':   144.4, 'D': 2.46,},
		},
		6: {
			0: {'M': 0.50, 'T': 30000, 'L': 29.0, 'D': 0.20,},
			1: {'M': 0.48, 'T': 27000, 'L': 25.4, 'D': 0.26,},
			2: {'M': 0.46, 'T': 24000, 'L': 21.8, 'D': 0.32,},
			3: {'M': 0.44, 'T': 21000, 'L': 18.2, 'D': 0.38,},
			4: {'M': 0.42, 'T': 18000, 'L': 14.6, 'D': 0.44,},
			// Since there is no A0 VI, M and D were interpolated assuming a similar delta from B5 to B9 as from B0 to B5
			5: {'M': 0.40, 'T': 15000, 'L': 11.0, 'D': 0.50,},
			6: {'M': 0.38, 'T': 14000, 'L':  9.0, 'D': 0.56,},
			7: {'M': 0.36, 'T': 13000, 'L':  7.0, 'D': 0.62,},
			8: {'M': 0.34, 'T': 12000, 'L':  5.0, 'D': 0.68,},
			9: {'M': 0.32, 'T': 11000, 'L':  3.0, 'D': 0.74,},
		},
	},
	2: {
		0: {
			0: {'M': 20.0, 'T': 10000, 'L': 130000, 'D': 120,},
			1: {'M': 19.0, 'T':  9600, 'L': 128000, 'D': 132,},
			2: {'M': 18.0, 'T':  9200, 'L': 126000, 'D': 144,},
			3: {'M': 17.0, 'T':  8800, 'L': 124000, 'D': 156,},
			4: {'M': 16.0, 'T':  8400, 'L': 122000, 'D': 168,},
			5: {'M': 15.0, 'T':  8000, 'L': 120000, 'D': 180,},
			6: {'M': 14.6, 'T':  7900, 'L': 120000, 'D': 186,},
			7: {'M': 14.2, 'T':  7800, 'L': 120000, 'D': 192,},
			8: {'M': 13.8, 'T':  7700, 'L': 120000, 'D': 198,},
			9: {'M': 13.4, 'T':  7600, 'L': 120000, 'D': 204,},
		},
		1: {
			0: {'M': 15.0, 'T': 10000, 'L': 22000, 'D': 50,},
			1: {'M': 14.6, 'T':  9600, 'L': 21600, 'D': 55,},
			2: {'M': 14.2, 'T':  9200, 'L': 21200, 'D': 60,},
			3: {'M': 13.8, 'T':  8800, 'L': 20800, 'D': 65,},
			4: {'M': 13.4, 'T':  8400, 'L': 20400, 'D': 70,},
			5: {'M': 13.0, 'T':  8000, 'L': 20000, 'D': 75,},
			6: {'M': 12.8, 'T':  7900, 'L': 20000, 'D': 77,},
			7: {'M': 12.6, 'T':  7800, 'L': 20000, 'D': 79,},
			8: {'M': 12.4, 'T':  7700, 'L': 20000, 'D': 81,},
			9: {'M': 12.2, 'T':  7600, 'L': 20000, 'D': 83,},
		},
		2: {
			0: {'M': 14.0, 'T': 10000, 'L': 8000, 'D': 30,},
			1: {'M': 13.4, 'T':  9600, 'L': 7860, 'D': 33,},
			2: {'M': 12.8, 'T':  9200, 'L': 7720, 'D': 36,},
			3: {'M': 12.2, 'T':  8800, 'L': 7580, 'D': 39,},
			4: {'M': 11.6, 'T':  8400, 'L': 7440, 'D': 42,},
			5: {'M': 11.0, 'T':  8000, 'L': 7300, 'D': 45,},
			6: {'M': 10.8, 'T':  7900, 'L': 7240, 'D': 46,},
			7: {'M': 10.6, 'T':  7800, 'L': 7180, 'D': 47,},
			8: {'M': 10.4, 'T':  7700, 'L': 7120, 'D': 48,},
			9: {'M': 10.2, 'T':  7600, 'L': 7060, 'D': 49,},
		},
		3: {
			0: {'M': 8.0, 'T': 10000, 'L': 220, 'D': 5,},
			1: {'M': 7.6, 'T':  9600, 'L': 194, 'D': 5,},
			2: {'M': 7.2, 'T':  9200, 'L': 168, 'D': 5,},
			3: {'M': 6.8, 'T':  8800, 'L': 142, 'D': 5,},
			4: {'M': 6.4, 'T':  8400, 'L': 116, 'D': 5,},
			5: {'M': 6.0, 'T':  8000, 'L':  90, 'D': 5,},
			6: {'M': 5.6, 'T':  7900, 'L':  86, 'D': 5,},
			7: {'M': 5.2, 'T':  7800, 'L':  82, 'D': 5,},
			8: {'M': 4.8, 'T':  7700, 'L':  78, 'D': 5,},
			9: {'M': 4.4, 'T':  7600, 'L':  74, 'D': 5,},
		},
		4: {
			0: {'M': 4.00, 'T': 10000, 'L': 140.0, 'D': 4.0,},
			1: {'M': 3.66, 'T':  9600, 'L': 118.6, 'D': 3.8,},
			2: {'M': 3.32, 'T':  9200, 'L':  97.2, 'D': 3.6,},
			3: {'M': 2.98, 'T':  8800, 'L':  75.8, 'D': 3.4,},
			4: {'M': 2.64, 'T':  8400, 'L':  54.4, 'D': 3.2,},
			5: {'M': 2.30, 'T':  8000, 'L':  33.0, 'D': 3.0,},
			6: {'M': 2.24, 'T':  7900, 'L':  31.4, 'D': 3.0,},
			7: {'M': 2.18, 'T':  7800, 'L':  29.8, 'D': 3.0,},
			8: {'M': 2.12, 'T':  7700, 'L':  28.2, 'D': 3.0,},
			9: {'M': 2.06, 'T':  7600, 'L':  26.6, 'D': 3.0,},
		},
		5: {
			0: {'M': 2.20, 'T': 10000, 'L': 43.00, 'D': 2.20,},
			1: {'M': 2.12, 'T':  9600, 'L': 37.40, 'D': 2.16,},
			2: {'M': 2.04, 'T':  9200, 'L': 31.80, 'D': 2.12,},
			3: {'M': 1.96, 'T':  8800, 'L': 26.20, 'D': 2.08,},
			4: {'M': 1.88, 'T':  8400, 'L': 20.60, 'D': 2.04,},
			5: {'M': 1.80, 'T':  8000, 'L': 15.00, 'D': 2.00,},
			6: {'M': 1.74, 'T':  7900, 'L': 13.62, 'D': 1.94,},
			7: {'M': 1.68, 'T':  7800, 'L': 12.24, 'D': 1.88,},
			8: {'M': 1.62, 'T':  7700, 'L': 10.86, 'D': 1.82,},
			9: {'M': 1.56, 'T':  7600, 'L':  9.48, 'D': 1.76,},
		},
		6: {
			// N/A
		},
	},
	3: {
		0: {
			0: {'M': 13.0, 'T': 7500, 'L': 120000, 'D': 210,},
			1: {'M': 12.8, 'T': 7300, 'L': 120000, 'D': 224,},
			2: {'M': 12.6, 'T': 7100, 'L': 120000, 'D': 238,},
			3: {'M': 12.4, 'T': 6900, 'L': 120000, 'D': 252,},
			4: {'M': 12.2, 'T': 6700, 'L': 120000, 'D': 266,},
			5: {'M': 12.0, 'T': 6500, 'L': 120000, 'D': 280,},
			6: {'M': 12.0, 'T': 6400, 'L': 120000, 'D': 290,},
			7: {'M': 12.0, 'T': 6300, 'L': 120000, 'D': 300,},
			8: {'M': 12.0, 'T': 6200, 'L': 120000, 'D': 310,},
			9: {'M': 12.0, 'T': 6100, 'L': 120000, 'D': 320,},
		},
		1: {
			0: {'M': 12.0, 'T': 7500, 'L': 20000, 'D':  85,},
			1: {'M': 11.6, 'T': 7300, 'L': 20000, 'D':  91,},
			2: {'M': 11.2, 'T': 7100, 'L': 20000, 'D':  97,},
			3: {'M': 10.8, 'T': 6900, 'L': 20000, 'D': 103,},
			4: {'M': 10.4, 'T': 6700, 'L': 20000, 'D': 109,},
			5: {'M': 10.0, 'T': 6500, 'L': 20000, 'D': 115,},
			6: {'M': 10.0, 'T': 6400, 'L': 20000, 'D': 119,},
			7: {'M': 10.0, 'T': 6300, 'L': 20000, 'D': 123,},
			8: {'M': 10.0, 'T': 6200, 'L': 20000, 'D': 127,},
			9: {'M': 10.0, 'T': 6100, 'L': 20000, 'D': 131,},
		},
		2: {
			0: {'M': 10.0, 'T': 7500, 'L': 7000, 'D': 50.0,},
			1: {'M':  9.6, 'T': 7300, 'L': 6980, 'D': 53.2,},
			2: {'M':  9.2, 'T': 7100, 'L': 6960, 'D': 56.4,},
			3: {'M':  8.8, 'T': 6900, 'L': 6940, 'D': 59.6,},
			4: {'M':  8.4, 'T': 6700, 'L': 6920, 'D': 62.8,},
			5: {'M':  8.0, 'T': 6500, 'L': 6900, 'D': 66.0,},
			6: {'M':  8.0, 'T': 6400, 'L': 6880, 'D': 68.2,},
			7: {'M':  8.0, 'T': 6300, 'L': 6860, 'D': 70.4,},
			8: {'M':  8.0, 'T': 6200, 'L': 6840, 'D': 72.6,},
			9: {'M':  8.0, 'T': 6100, 'L': 6820, 'D': 74.8,},
		},
		3: {
			0: {'M': 4.0, 'T': 7500, 'L':  70.0, 'D': 5,},
			1: {'M': 3.8, 'T': 7300, 'L':  63.8, 'D': 5,},
			2: {'M': 3.6, 'T': 7100, 'L':  57.6, 'D': 5,},
			3: {'M': 3.4, 'T': 6900, 'L':  51.4, 'D': 5,},
			4: {'M': 3.2, 'T': 6700, 'L':  45.2, 'D': 5,},
			5: {'M': 3.0, 'T': 6500, 'L':  39.0, 'D': 5,},
			6: {'M': 2.9, 'T': 6400, 'L':  55.2, 'D': 6,},
			7: {'M': 2.8, 'T': 6300, 'L':  71.4, 'D': 7,},
			8: {'M': 2.7, 'T': 6200, 'L':  87.6, 'D': 8,},
			9: {'M': 2.6, 'T': 6100, 'L': 103.8, 'D': 9,},
		},
		4: {
			0: {'M': 2.00, 'T': 7500, 'L': 25.0, 'D': 3.0,},
			1: {'M': 1.90, 'T': 7300, 'L': 21.2, 'D': 2.8,},
			2: {'M': 1.80, 'T': 7100, 'L': 17.4, 'D': 2.6,},
			3: {'M': 1.70, 'T': 6900, 'L': 13.6, 'D': 2.4,},
			4: {'M': 1.60, 'T': 6700, 'L':  9.8, 'D': 2.2,},
			5: {'M': 1.50, 'T': 6500, 'L':  6.0, 'D': 2.0,},
			6: {'M': 1.54, 'T': 6400, 'L':  6.8, 'D': 2.2,},
			7: {'M': 1.58, 'T': 6300, 'L':  7.6, 'D': 2.4,},
			8: {'M': 1.62, 'T': 6200, 'L':  8.4, 'D': 2.6,},
			9: {'M': 1.66, 'T': 6100, 'L':  9.2, 'D': 2.8,},
		},
		5: {
			0: {'M': 1.50, 'T': 7500, 'L': 8.10, 'D': 1.70,},
			1: {'M': 1.46, 'T': 7300, 'L': 7.18, 'D': 1.66,},
			2: {'M': 1.42, 'T': 7100, 'L': 6.26, 'D': 1.62,},
			3: {'M': 1.38, 'T': 6900, 'L': 5.34, 'D': 1.58,},
			4: {'M': 1.34, 'T': 6700, 'L': 4.42, 'D': 1.54,},
			5: {'M': 1.30, 'T': 6500, 'L': 3.50, 'D': 1.50,},
			6: {'M': 1.26, 'T': 6400, 'L': 3.08, 'D': 1.42,},
			7: {'M': 1.22, 'T': 6300, 'L': 2.66, 'D': 1.34,},
			8: {'M': 1.18, 'T': 6200, 'L': 2.24, 'D': 1.26,},
			9: {'M': 1.14, 'T': 6100, 'L': 1.82, 'D': 1.18,},
		},
		6: {
			// N/A
		},
	},
	4: {
		0: {
			0: {'M': 12.0, 'T': 6000, 'L': 120000, 'D': 330,},
			1: {'M': 12.2, 'T': 5920, 'L': 118000, 'D': 336,},
			2: {'M': 12.4, 'T': 5840, 'L': 116000, 'D': 342,},
			3: {'M': 12.6, 'T': 5760, 'L': 114000, 'D': 348,},
			4: {'M': 12.8, 'T': 5680, 'L': 112000, 'D': 354,},
			5: {'M': 13.0, 'T': 5600, 'L': 110000, 'D': 360,},
			6: {'M': 13.2, 'T': 5520, 'L': 110000, 'D': 372,},
			7: {'M': 13.4, 'T': 5440, 'L': 110000, 'D': 384,},
			8: {'M': 13.6, 'T': 5360, 'L': 110000, 'D': 396,},
			9: {'M': 13.8, 'T': 5280, 'L': 110000, 'D': 408,},
		},
		1: {
			0: {'M': 10.0, 'T': 6000, 'L': 20000, 'D': 135,},
			1: {'M': 10.2, 'T': 5920, 'L': 20000, 'D': 138,},
			2: {'M': 10.4, 'T': 5840, 'L': 20000, 'D': 141,},
			3: {'M': 10.6, 'T': 5760, 'L': 20000, 'D': 144,},
			4: {'M': 10.8, 'T': 5680, 'L': 20000, 'D': 147,},
			5: {'M': 11.0, 'T': 5600, 'L': 20000, 'D': 150,},
			6: {'M': 11.2, 'T': 5520, 'L': 20200, 'D': 156,},
			7: {'M': 11.4, 'T': 5440, 'L': 20400, 'D': 162,},
			8: {'M': 11.6, 'T': 5360, 'L': 20600, 'D': 168,},
			9: {'M': 11.8, 'T': 5280, 'L': 20800, 'D': 174,},
		},
		2: {
			0: {'M':  8.0, 'T': 6000, 'L': 6800, 'D':  77.0,},
			1: {'M':  8.4, 'T': 5920, 'L': 6840, 'D':  79.6,},
			2: {'M':  8.8, 'T': 5840, 'L': 6880, 'D':  82.2,},
			3: {'M':  9.2, 'T': 5760, 'L': 6920, 'D':  84.8,},
			4: {'M':  9.6, 'T': 5680, 'L': 6960, 'D':  87.4,},
			5: {'M': 10.0, 'T': 5600, 'L': 7000, 'D':  90.0,},
			6: {'M': 10.0, 'T': 5520, 'L': 7160, 'D':  94.0,},
			7: {'M': 10.0, 'T': 5440, 'L': 7320, 'D':  98.0,},
			8: {'M': 10.0, 'T': 5360, 'L': 7480, 'D': 102.0,},
			9: {'M': 10.0, 'T': 5280, 'L': 7640, 'D': 106.0,},
		},
		3: {
			0: {'M': 2.50, 'T': 6000, 'L': 120, 'D': 10,},
			1: {'M': 2.48, 'T': 5920, 'L': 136, 'D': 11,},
			2: {'M': 2.46, 'T': 5840, 'L': 152, 'D': 12,},
			3: {'M': 2.44, 'T': 5760, 'L': 168, 'D': 13,},
			4: {'M': 2.42, 'T': 5680, 'L': 184, 'D': 14,},
			5: {'M': 2.40, 'T': 5600, 'L': 200, 'D': 15,},
			6: {'M': 2.14, 'T': 5520, 'L': 212, 'D': 16,},
			7: {'M': 1.88, 'T': 5440, 'L': 224, 'D': 17,},
			8: {'M': 1.62, 'T': 5360, 'L': 236, 'D': 18,},
			9: {'M': 1.36, 'T': 5280, 'L': 248, 'D': 19,},
		},
		4: {
			0: {'M': 1.70, 'T': 6000, 'L': 10.0, 'D': 3.0,},
			1: {'M': 1.60, 'T': 5920, 'L': 10.8, 'D': 3.2,},
			2: {'M': 1.50, 'T': 5840, 'L': 11.6, 'D': 3.4,},
			3: {'M': 1.40, 'T': 5760, 'L': 12.4, 'D': 3.6,},
			4: {'M': 1.30, 'T': 5680, 'L': 13.2, 'D': 3.8,},
			5: {'M': 1.20, 'T': 5600, 'L': 14.0, 'D': 4.0,},
			6: {'M': 1.26, 'T': 5520, 'L': 15.8, 'D': 4.4,},
			7: {'M': 1.32, 'T': 5440, 'L': 17.6, 'D': 4.8,},
			8: {'M': 1.38, 'T': 5360, 'L': 19.4, 'D': 5.2,},
			9: {'M': 1.44, 'T': 5280, 'L': 21.2, 'D': 5.6,},
		},
		5: {
			0: {'M': 1.10, 'T': 6000, 'L': 1.400, 'D': 1.10,},
			1: {'M': 1.06, 'T': 5920, 'L': 1.276, 'D': 1.07,},
			2: {'M': 1.02, 'T': 5840, 'L': 1.152, 'D': 1.04,},
			3: {'M': 0.98, 'T': 5760, 'L': 1.028, 'D': 1.01,},
			4: {'M': 0.94, 'T': 5680, 'L': 0.904, 'D': 0.98,},
			5: {'M': 0.90, 'T': 5600, 'L': 0.780, 'D': 0.95,},
			6: {'M': 0.88, 'T': 5520, 'L': 0.728, 'D': 0.94,},
			7: {'M': 0.86, 'T': 5440, 'L': 0.676, 'D': 0.93,},
			8: {'M': 0.84, 'T': 5360, 'L': 0.624, 'D': 0.92,},
			9: {'M': 0.82, 'T': 5280, 'L': 0.572, 'D': 0.91,},
		},
		6: {
			0: {'M': 0.80, 'T': 6000, 'L': 0.73, 'D': 0.80,},
			1: {'M': 0.78, 'T': 5920, 'L': 0.67, 'D': 0.78,},
			2: {'M': 0.76, 'T': 5840, 'L': 0.61, 'D': 0.76,},
			3: {'M': 0.74, 'T': 5760, 'L': 0.55, 'D': 0.74,},
			4: {'M': 0.72, 'T': 5680, 'L': 0.49, 'D': 0.72,},
			5: {'M': 0.70, 'T': 5600, 'L': 0.43, 'D': 0.70,},
			6: {'M': 0.68, 'T': 5520, 'L': 0.39, 'D': 0.68,},
			7: {'M': 0.66, 'T': 5440, 'L': 0.35, 'D': 0.66,},
			8: {'M': 0.64, 'T': 5360, 'L': 0.31, 'D': 0.64,},
			9: {'M': 0.62, 'T': 5280, 'L': 0.27, 'D': 0.62,},
		},
	},
	5: {
		0: {
			0: {'M': 14.0, 'T': 5200, 'L': 110000, 'D': 420,},
			1: {'M': 14.8, 'T': 5040, 'L': 112000, 'D': 456,},
			2: {'M': 15.6, 'T': 4880, 'L': 114000, 'D': 492,},
			3: {'M': 16.4, 'T': 4720, 'L': 116000, 'D': 528,},
			4: {'M': 17.2, 'T': 4560, 'L': 118000, 'D': 564,},
			5: {'M': 18.0, 'T': 4400, 'L': 120000, 'D': 600,},
			6: {'M': 18.4, 'T': 4260, 'L': 122000, 'D': 660,},
			7: {'M': 18.8, 'T': 4120, 'L': 124000, 'D': 720,},
			8: {'M': 19.2, 'T': 3980, 'L': 126000, 'D': 780,},
			9: {'M': 19.6, 'T': 3840, 'L': 128000, 'D': 840,},
		},
		1: {
			0: {'M': 12.0, 'T': 5200, 'L': 21000, 'D': 180,},
			1: {'M': 12.2, 'T': 5040, 'L': 21200, 'D': 196,},
			2: {'M': 12.4, 'T': 4880, 'L': 21400, 'D': 212,},
			3: {'M': 12.6, 'T': 4720, 'L': 21600, 'D': 228,},
			4: {'M': 12.8, 'T': 4560, 'L': 21800, 'D': 244,},
			5: {'M': 13.0, 'T': 4400, 'L': 22000, 'D': 260,},
			6: {'M': 13.4, 'T': 4260, 'L': 22400, 'D': 284,},
			7: {'M': 13.8, 'T': 4120, 'L': 22800, 'D': 308,},
			8: {'M': 14.2, 'T': 3980, 'L': 23200, 'D': 332,},
			9: {'M': 14.6, 'T': 3840, 'L': 23600, 'D': 356,},
		},
		2: {
			0: {'M': 10.0, 'T': 5200, 'L': 7800, 'D': 110,},
			1: {'M': 10.4, 'T': 5040, 'L': 7920, 'D': 120,},
			2: {'M': 10.8, 'T': 4880, 'L': 8040, 'D': 130,},
			3: {'M': 11.2, 'T': 4720, 'L': 8160, 'D': 140,},
			4: {'M': 11.6, 'T': 4560, 'L': 8280, 'D': 150,},
			5: {'M': 12.0, 'T': 4400, 'L': 8400, 'D': 160,},
			6: {'M': 12.4, 'T': 4260, 'L': 8480, 'D': 174,},
			7: {'M': 12.8, 'T': 4120, 'L': 8560, 'D': 188,},
			8: {'M': 13.2, 'T': 3980, 'L': 8640, 'D': 202,},
			9: {'M': 13.6, 'T': 3840, 'L': 8720, 'D': 216,},
		},
		3: {
			0: {'M': 1.10, 'T': 5200, 'L': 260, 'D': 20,},
			1: {'M': 1.18, 'T': 5040, 'L': 314, 'D': 24,},
			2: {'M': 1.26, 'T': 4880, 'L': 368, 'D': 28,},
			3: {'M': 1.34, 'T': 4720, 'L': 422, 'D': 32,},
			4: {'M': 1.42, 'T': 4560, 'L': 476, 'D': 36,},
			5: {'M': 1.50, 'T': 4400, 'L': 530, 'D': 40,},
			6: {'M': 1.56, 'T': 4260, 'L': 544, 'D': 44,},
			7: {'M': 1.62, 'T': 4120, 'L': 558, 'D': 48,},
			8: {'M': 1.68, 'T': 3980, 'L': 572, 'D': 52,},
			9: {'M': 1.74, 'T': 3840, 'L': 586, 'D': 56,},
		},
		4: {
			0: {'M': 1.50, 'T': 5200, 'L': 23.0, 'D': 6.0,},
			1: {'M': 1.56, 'T': 5040, 'L': 24.4, 'D': 6.4,},
			2: {'M': 1.62, 'T': 4880, 'L': 25.8, 'D': 6.8,},
			3: {'M': 1.68, 'T': 4720, 'L': 27.2, 'D': 7.2,},
			4: {'M': 1.74, 'T': 4560, 'L': 28.6, 'D': 7.6,},
			// 5+ N/A; M, and D were interpolated assuming a similar delta from K0 to K5 as from G5 to K0
		},
		5: {
			0: {'M': 0.80, 'T': 5200, 'L': 0.5200, 'D': 0.90,},
			1: {'M': 0.78, 'T': 5040, 'L': 0.4580, 'D': 0.88,},
			2: {'M': 0.76, 'T': 4880, 'L': 0.3960, 'D': 0.86,},
			3: {'M': 0.74, 'T': 4720, 'L': 0.3340, 'D': 0.84,},
			4: {'M': 0.72, 'T': 4560, 'L': 0.2720, 'D': 0.82,},
			5: {'M': 0.70, 'T': 4400, 'L': 0.2100, 'D': 0.80,},
			6: {'M': 0.66, 'T': 4260, 'L': 0.1844, 'D': 0.78,},
			7: {'M': 0.62, 'T': 4120, 'L': 0.1588, 'D': 0.76,},
			8: {'M': 0.58, 'T': 3980, 'L': 0.1332, 'D': 0.74,},
			9: {'M': 0.54, 'T': 3840, 'L': 0.1076, 'D': 0.72,},
		},
		6: {
			0: {'M': 0.60, 'T': 5200, 'L': 0.2300, 'D': 0.60,},
			1: {'M': 0.58, 'T': 5040, 'L': 0.2006, 'D': 0.58,},
			2: {'M': 0.56, 'T': 4880, 'L': 0.1712, 'D': 0.56,},
			3: {'M': 0.54, 'T': 4720, 'L': 0.1418, 'D': 0.54,},
			4: {'M': 0.52, 'T': 4560, 'L': 0.1124, 'D': 0.52,},
			5: {'M': 0.50, 'T': 4400, 'L': 0.0830, 'D': 0.50,},
			6: {'M': 0.48, 'T': 4260, 'L': 0.0718, 'D': 0.48,},
			7: {'M': 0.46, 'T': 4120, 'L': 0.0606, 'D': 0.46,},
			8: {'M': 0.44, 'T': 3980, 'L': 0.0494, 'D': 0.44,},
			9: {'M': 0.42, 'T': 3840, 'L': 0.0382, 'D': 0.42,},
		},
	},
	6: {
		0: {
			0: {'M': 20, 'T': 3700, 'L': 130000, 'D':  900,},
			1: {'M': 21, 'T': 3560, 'L': 124000, 'D':  960,},
			2: {'M': 22, 'T': 3420, 'L': 118000, 'D': 1020,},
			3: {'M': 23, 'T': 3280, 'L': 112000, 'D': 1080,},
			4: {'M': 24, 'T': 3140, 'L': 106000, 'D': 1140,},
			5: {'M': 25, 'T': 3000, 'L': 100000, 'D': 1200,},
			6: {'M': 26, 'T': 2880, 'L':  98000, 'D': 1320,},
			7: {'M': 27, 'T': 2760, 'L':  96000, 'D': 1440,},
			8: {'M': 28, 'T': 2640, 'L':  94000, 'D': 1560,},
			9: {'M': 30, 'T': 2400, 'L':  90000, 'D': 1800,},
		},
		1: {
			0: {'M': 15, 'T': 3700, 'L': 24000, 'D': 380,},
			1: {'M': 16, 'T': 3560, 'L': 24400, 'D': 424,},
			2: {'M': 17, 'T': 3420, 'L': 24800, 'D': 468,},
			3: {'M': 18, 'T': 3280, 'L': 25200, 'D': 512,},
			4: {'M': 19, 'T': 3140, 'L': 25600, 'D': 556,},
			5: {'M': 20, 'T': 3000, 'L': 26000, 'D': 600,},
			6: {'M': 21, 'T': 2880, 'L': 24600, 'D': 640,},
			7: {'M': 22, 'T': 2760, 'L': 23200, 'D': 680,},
			8: {'M': 23, 'T': 2640, 'L': 21800, 'D': 720,},
			9: {'M': 25, 'T': 2400, 'L': 19000, 'D': 800,},
		},
		2: {
			0: {'M': 14.0, 'T': 3700, 'L': 8800, 'D': 230,},
			1: {'M': 14.4, 'T': 3560, 'L': 8800, 'D': 254,},
			2: {'M': 14.8, 'T': 3420, 'L': 8800, 'D': 278,},
			3: {'M': 15.2, 'T': 3280, 'L': 8800, 'D': 302,},
			4: {'M': 15.6, 'T': 3140, 'L': 8800, 'D': 326,},
			5: {'M': 16.0, 'T': 3000, 'L': 8800, 'D': 350,},
			6: {'M': 16.4, 'T': 2880, 'L': 8500, 'D': 380,},
			7: {'M': 16.8, 'T': 2760, 'L': 8200, 'D': 410,},
			8: {'M': 17.2, 'T': 2640, 'L': 7900, 'D': 440,},
			9: {'M': 18.0, 'T': 2400, 'L': 7300, 'D': 500,},
		},
		3: {
			0: {'M': 1.80, 'T': 3700, 'L':  600, 'D':  60,},
			1: {'M': 1.92, 'T': 3560, 'L':  624, 'D':  68,},
			2: {'M': 2.04, 'T': 3420, 'L':  648, 'D':  76,},
			3: {'M': 2.16, 'T': 3280, 'L':  672, 'D':  84,},
			4: {'M': 2.28, 'T': 3140, 'L':  696, 'D':  92,},
			5: {'M': 2.40, 'T': 3000, 'L':  720, 'D': 100,},
			6: {'M': 3.52, 'T': 2880, 'L':  816, 'D': 120,},
			7: {'M': 4.64, 'T': 2760, 'L':  912, 'D': 140,},
			8: {'M': 5.76, 'T': 2640, 'L': 1008, 'D': 160,},
			9: {'M': 8.00, 'T': 2400, 'L': 1200, 'D': 200,},
		},
		4: {
			// N/A
		},
		5: {
			0: {'M': 0.500, 'T': 3700, 'L': 0.082000, 'D': 0.70,},
			1: {'M': 0.432, 'T': 3560, 'L': 0.066180, 'D': 0.60,},
			2: {'M': 0.364, 'T': 3420, 'L': 0.050360, 'D': 0.50,},
			3: {'M': 0.296, 'T': 3280, 'L': 0.034540, 'D': 0.40,},
			4: {'M': 0.228, 'T': 3140, 'L': 0.018720, 'D': 0.30,},
			5: {'M': 0.160, 'T': 3000, 'L': 0.002900, 'D': 0.20,},
			6: {'M': 0.144, 'T': 2880, 'L': 0.002378, 'D': 0.18,},
			7: {'M': 0.128, 'T': 2760, 'L': 0.001856, 'D': 0.16,},
			8: {'M': 0.112, 'T': 2640, 'L': 0.001334, 'D': 0.14,},
			9: {'M': 0.080, 'T': 2400, 'L': 0.000290, 'D': 0.10,},
		},
		6: {
			0: {'M': 0.400, 'T': 3700, 'L': 0.027000, 'D': 0.400,},
			1: {'M': 0.344, 'T': 3560, 'L': 0.021744, 'D': 0.340,},
			2: {'M': 0.288, 'T': 3420, 'L': 0.016488, 'D': 0.280,},
			3: {'M': 0.232, 'T': 3280, 'L': 0.011232, 'D': 0.220,},
			4: {'M': 0.176, 'T': 3140, 'L': 0.005976, 'D': 0.160,},
			5: {'M': 0.120, 'T': 3000, 'L': 0.000720, 'D': 0.100,},
			6: {'M': 0.111, 'T': 2880, 'L': 0.000614, 'D': 0.096,},
			7: {'M': 0.102, 'T': 2760, 'L': 0.000508, 'D': 0.092,},
			8: {'M': 0.093, 'T': 2640, 'L': 0.000402, 'D': 0.088,},
			9: {'M': 0.075, 'T': 2400, 'L': 0.000190, 'D': 0.080,},
		},
	},
};

// Brown Dwarf data lookup by Mass ('M'); interpolated and condensed results across the entire L/T/Y range into range 0-9
const BROWN_DWARF_DATA = [
	{'M': 0.0800, 'T': 2400.0, 'L': 0.000290000, 'D': 0.1,},
	{'M': 0.0726, 'T': 2166.7, 'L': 0.000257790, 'D': 0.1,},
	{'M': 0.0651, 'T': 1933.3, 'L': 0.000225570, 'D': 0.1,},
	{'M': 0.0577, 'T': 1700.0, 'L': 0.000193360, 'D': 0.1,},
	{'M': 0.0502, 'T': 1466.7, 'L': 0.000161140, 'D': 0.1,},
	{'M': 0.0428, 'T': 1233.3, 'L': 0.000128930, 'D': 0.1,},
	{'M': 0.0353, 'T': 1000.0, 'L': 0.000096715, 'D': 0.1,},
	{'M': 0.0279, 'T':  766.7, 'L': 0.000064500, 'D': 0.1,},
	{'M': 0.0204, 'T':  533.3, 'L': 0.000032286, 'D': 0.1,},
	{'M': 0.0130, 'T':  300.0, 'L': 0.000000072, 'D': 0.1,},
];

// White Dwarf data lookup by Age ('A')
const WHITE_DWARF_DATA = [
	{'A':  0.0, 'T': 100000, 'L': 2500.000, 'D': 0.017,},
	{'A':  0.1, 'T':  25000, 'L': 0.200000, 'D': 0.017,},
	{'A':  0.5, 'T':  10000, 'L': 0.002500, 'D': 0.017,},
	{'A':  1.0, 'T':   8000, 'L': 0.001000, 'D': 0.017,},
	{'A':  1.5, 'T':   7000, 'L': 0.000590, 'D': 0.017,},
	{'A':  2.5, 'T':   5500, 'L': 0.000230, 'D': 0.017,},
	{'A':  5.0, 'T':   5000, 'L': 0.000150, 'D': 0.017,},
	{'A': 10.0, 'T':   4000, 'L': 0.000063, 'D': 0.017,},
	{'A': 13.0, 'T':   3800, 'L': 0.000051, 'D': 0.017,},
];

const NON_PRIMARY_COMPANION = {
	 2: 'Other',
	 3: 'Other',
	 4: 'Random',
	 5: 'Random',
	 6: 'Lesser',
	 7: 'Lesser',
	 8: 'Sibling',
	 9: 'Sibling',
	10: 'Twin',
	11: 'Twin',
	12: 'Twin',
};

const NON_PRIMARY_DEAD = {
	 2: 'Other',
	 3: 'Other',
	 4: 'Random',
	 5: 'Random',
	 6: 'Random',
	 7: 'Random',
	 8: 'Random',
	 9: 'Lesser',
	10: 'Lesser',
	11: 'Twin',
	12: 'Twin',
};

const NON_PRIMARY_SECONDARY = {
	 2: 'Other',
	 3: 'Other',
	 4: 'Random',
	 5: 'Random',
	 6: 'Random',
	 7: 'Lesser',
	 8: 'Lesser',
	 9: 'Sibling',
	10: 'Sibling',
	11: 'Twin',
	12: 'Twin',
};

const PLANET_EMPTY = 0;

const PLANET_BELT = 2;

const PLANET_GAS = 1;

const PLANET_ROCK = 3;

const PLANET_MOON = 4;

const PLANET_RING = 5;

const PLANET_QTY_GAS = {
	 4: 1,
	 5: 2,
	 6: 2,
	 7: 3,
	 8: 3,
	 9: 4,
	10: 4,
	11: 4,
	12: 5,
	13: 6,
};

const TERRESTRIAL_DIAMETERS = [
	0,
	// There is also a Size 'S' = 600 km, but it doesn't fit in this lookup table
	1600,
	3200,
	4800,
	6400,
	8000,
	9600,
	11200,
	12800,
	14400,
	16000,
	17600,
	19200,
	20800,
	22400,
	24000,
];

const TERRESTRIAL_DENSITIES = [
	[0.03,0.06,0.09,0.12,0.15,0.18,0.21,0.24,0.27,0.30,0.33],
	[0.18,0.21,0.24,0.27,0.30,0.33,0.36,0.39,0.41,0.44,0.47],
	[0.50,0.53,0.56,0.59,0.62,0.65,0.68,0.71,0.74,0.77,0.80],
	[0.82,0.85,0.88,0.91,0.94,0.97,1.00,1.03,1.06,1.09,1.12],
	[1.15,1.18,1.21,1.24,1.27,1.30,1.33,1.36,1.39,1.42,1.45],
	[1.50,1.55,1.60,1.65,1.70,1.75,1.80,1.85,1.90,1.95,2.00],
];

const TAINT_B = 11;
const TAINT_G = 16;
const TAINT_H = 17;
const TAINT_L = 20;
const TAINT_P = 23;
const TAINT_R = 25;
const TAINT_S = 26;

class Roll
{
	constructor(die_qty, die_size = 6, modifier = 0, description = '')
	{
		this.n = die_qty;
		this.d = die_size;
		this.dm = modifier;
		this.description = description;
		this.rolls = [];
		this.total = 0;
		for (let i = 0; i < this.n; i++) {
			const v = getRandomIntInclusive(1, this.d);
			this.rolls.push(v);
			this.total += v;
		}
		this.total += this.dm;
	}

	toString()
	{
		return this.dice() + ': ' + this.total + ' ' + this.results();
	}

	dice()
	{
		return this.n + 'd' + this.d;
	}

	results()
	{
		return '[' + this.rolls.join(' + ') + ']';
	}

	modifier()
	{
		return this.dm > 0
			? signed(this.dm)
			: (this.dm < 0 ? this.dm : '');
	}
}

class OrbitingBody
{
	constructor(host = null)
	{
		this.host = host;
		this.mass = 0;
		this.mass_deviation = 0;
		this.orbit = 0;
		this.orbit_au = 0;
		this.orbit_deviation = 0;
		this.orbit_eccentricity = 0;
		this.orbit_eccentricity_dm = 0;
		// Exclusion zone is the absolute Minimum Allowable Orbit#, typically based on the object's diameter
		this.orbit_exclusion_zone = 0;
		this.orbit_inclination = 0;
		this.orbit_lagrange = 0;
		this.orbit_lock = 0;
		this.orbit_major_min = 0;
		this.orbit_major_max = 0;
		this.orbit_parent_index = null;
		this.orbit_period = 0;
		this.orbit_retrograde = false;
		// Min and Max allowed Orbit#s, centered on this object, for any other bodies that may orbit it
		this.allowed_orbits_min = 0;
		this.allowed_orbits_max = 0;
		this.bodies = [];
		this.n_bodies = 0;
		this.n_empty = 0;
		this.orbit_slots = 0;
		// Fields used when baseline, spread, etc. are determined separately for each Secondary and Companion star with independent orbits
		this.baseline_number = 0;
		this.baseline_orbit = 0;
		this.orbit_spread = 0;
		this.orbit_spread_max = 0;
		// Optional roll history from factory generation
		this.history = [];
	}

	getDesignation(n_stars = 1)
	{
		return '';
	}

	getDesignationPrimary()
	{
		return '';
	}

	/**
	 * @return string Human-readable version of the body's orbital period
	 */
	getOrbitalPeriod()
	{
		if (this.orbit_period > 0.5) {
			let n = this.orbit_period > 9999 ? this.orbit_period.toFixed(0).length : (this.orbit_period < 1 ? 3 : 4);
			return format(this.orbit_period, n) + 'y';
		} else if (this.orbit_period > 0.005) {
			return format(this.orbit_period * 365.25, 4) + 'd';
		}
		return format(this.orbit_period * 8766, 4) + 'h';
	}

	getOrbitalMass()
	{
		return this.getTotalMass();
	}

	getTotalMass()
	{
		return this.mass + this.mass_deviation;
	}

	getTotalOrbit()
	{
		return this.orbit + this.orbit_deviation;
	}

	getMinimumAllowableOrbit(n = 3)
	{
		return round(Math.max(this.allowed_orbits_min, this.orbit_exclusion_zone), n);
	}

	getMaximumAllowableOrbit(n = 3)
	{
		return round(this.allowed_orbits_max, n);
	}

	/**
	 * @return string The range of Orbit#s, if any, in which other objects may orbit around this body
	 */
	getAllowedOrbits()
	{
		const min = this.getMinimumAllowableOrbit();
		const max = this.getMaximumAllowableOrbit();
		if (min >= max) {
			return '-';
		}
		return min.toFixed(2) + ' - ' + max.toFixed(2);
	}

	/**
	 * @return float The total number of available Orbit#s around this object, if any
	 */
	getTotalAllowedOrbits()
	{
		return Math.max(0, this.getMaximumAllowableOrbit() - this.getMinimumAllowableOrbit());
	}

	/**
	 * @return int Value to add to allowed orbital slots when #getTotalAllowedOrbits is greater than 0
	 */
	getAllowedOrbitMod()
	{
		return 0;
	}

	/**
	 * @return float The smaller of #orbit_spread and #orbit_spread_max
	 */
	getMinimumOrbitSpread()
	{
		if (this.orbit_spread < 0.001) return this.orbit_spread_max;
		if (this.orbit_spread_max < 0.001) return this.orbit_spread;
		return Math.min(this.orbit_spread, this.orbit_spread_max);
	}

	getSignificantBodyCount()
	{
		return this.bodies.length;
	}
}

class AbstractStar extends OrbitingBody
{
	constructor()
	{
		super(null);
		this.hzco = 0;
		this.n_stars = 1;
		this.anomalous = [];
	}

	addAnomalousPlanetData(orbit, data)
	{
		const index = 1 + this.bodies.findLastIndex((value) => round(value, 3) <= round(orbit, 3));
		this.bodies.splice(index, 0, orbit);
		// Special Case: Trojans need to know their parent orbit, and that orbit cannot be empty
		if (data.orbit_is_trojan) {
			data.orbit_parent_index = index - 1;
		}
		this.anomalous.forEach(entry => {
			if (entry.index >= index) {
				entry.index++;
				if (entry.data.orbit_is_trojan && entry.data.orbit_parent_index > index) {
					entry.data.orbit_parent_index++;
				}
			}
		});
		this.anomalous.push({'index': index, 'data': data});
		log('Anomalous planet assigned to Orbit# ' + orbit.toFixed(3) + ' around star ' + this.getDesignation() + ' at index ' + index);
		log(data);
	}

	getAnomalousPlanetDataAt(index)
	{
		const entry = this.anomalous.find((v, k) => v.index === index);
		return entry === undefined ? null : entry.data;
	}

	getHzco(n = 3)
	{
		return round(this.hzco, n);
	}

	/**
	 * @param float mod The number of Orbit#s by which to modify the HZCO
	 *
	 * @return float the correctly modified HZCO, accounting for "whole" increments of 0.1 when HZCO < 1
	 */
	getHzcoPlus(mod, n = 3)
	{
		const hzco = this.getHzco(n);
		return getOrbitPlus(hzco, mod);
	}

	isHzcoValid()
	{
		const fudge = getHzcoFudgeFactor();
		const max = this.getMaximumAllowableOrbit();
		const min = this.getMinimumAllowableOrbit();
		return max > min && this.getHzcoPlus(fudge) > min && this.getHzcoPlus(-fudge) < max;
	}

	/**
	 * @return bool True if this star or star group is or contains the system's primary star (or, if it has a companion, the primary pair)
	 */
	isPrimaryComponent()
	{
		return false;
	}
}

class Star extends AbstractStar
{
	constructor(type = MAIN_TYPE_M, subtype = 0, classification = 5, primary = true)
	{
		super();
		this.primary = primary;
		this.type = clamp(type, -1, 15);
		this.subtype = clamp(subtype, -1, 9);
		this.classification = clamp(classification, -1, 9);
		this.companion = null;
		this.designation = 0;
		this.diameter = 0;
		this.diameter_deviation = 0;
		this.luminosity = 0;
		this.luminosity_deviation = 0;
		this.temperature = 0;
		this.temperature_deviation = 0;
		// Lifespans
		this.life_main = -1;     // All classes
		this.life_subgiant = -1; // Class III and IV, White Dwarfs and other dead stars
		this.life_giant = -1;    // Class III, White Dwarfs and other dead stars
		this.age = 0;
		// Orbital bands used during system generation: 0 = Primary, 1 = Close, 2 = Near, 3 = Far
		this.orbit_band = 0;
		this.orbit_exclusion_zone = 0.01;
	}

	/**
	 * @return string Standard star code format D-O-E-T# C-M-D-L; D-O-E included for secondary objects only
	 */
	getProfileLong()
	{
		let parts = [];
		// D-O-E for non-primary stars only
		if (!this.primary) {
			parts.push(this.getDesignation());
			parts.push(this.getTotalOrbit().toFixed(2));
			parts.push(format(this.orbit_eccentricity, 3));
		}
		// T# C is the same as the short profile
		parts.push(this.getProfileShort());
		parts.push(format(this.getTotalMass(), 3));
		parts.push(format(this.getTotalDiameter(), 3));
		parts.push(format(this.getTotalLuminosity(), 3));
		return parts.join('-');
	}

	getProfileShort()
	{
		let suffix = '';
		// Special Case: Protostars should display the type of star they will become
		if (this.type === PROTOSTAR) {
			const future = new Star(this.proto_type, this.proto_subtype, this.proto_classification);
			suffix = ' (' + future.getProfileShort() + ')';
		}
		return STAR_TYPE[this.type]
			+ (this.subtype > -1 ? this.subtype : '')
			+ (this.classification > -1 ? ' ' + STAR_CLASS[this.classification] : '')
			+ suffix;
	}

	getColor()
	{
		const colors = [
			'Blue',
			'Blue White',
			'White',
			'Yellow White',
			'Yellow',
			'Light Orange',
			'Orange Red',
			'White', // White Dwarf, should probably be based on temperature as their colors can range from O-M type
			'Brown', // Brown Dwarf
			'Other', // Everything else
		];
		const index = clamp(this.type, 0, 9);
		return colors[index];
	}

	getDesignation(n_stars = 1)
	{
		const suffix = (this.designation > 7 ? 'b' : (this.designation > 3 ? 'a' : ''));
		return this.getDesignationPrimary() + suffix;
	}

	getDesignationPrimary()
	{
		const prefixes = ['A', 'B', 'C', 'D'];
		const preIndex = clamp(this.designation % 4, 0, 3);
		return prefixes[preIndex];
	}

	getName()
	{
		return STAR_NAME[this.type];
	}

	/**
	 * @return float The star's total mass plus that of any companion star
	 */
	getOrbitalMass()
	{
		return this.getTotalMass() + (this.companion ? this.companion.getTotalMass() : 0);
	}

	getTotalDiameter()
	{
		return this.diameter + this.diameter_deviation;
	}

	getTotalLuminosity()
	{
		return this.luminosity + this.luminosity_deviation;
	}

	getAllowedOrbitMod()
	{
		// Add 1 for stars with at least some available orbit#s and no companion
		return (this.companion || this.host ? 0 : 1);
	}

	getTotalTemperature()
	{
		return this.temperature + this.temperature_deviation;
	}

	/**
	 * @param Star|null other may be null for convenience
	 *
	 * @return bool True if this star is in an adjacent orbital band to another stellar object
	 */
	isAdjacent(other = null)
	{
		return other !== null && Math.abs(this.orbit_band - other.orbit_band) === 1;
	}

	isGiant()
	{
		return this.type <= MAIN_TYPE_M && this.classification > -1 && this.classification < 4;
	}

	/**
	 * Post-Stellar objects for the purpose of star system generation are D, PSR, NS, BH
	 */
	isPostStellar()
	{
		const types = [WHITE_DWARF, PULSAR, NEUTRON_STAR, BLACK_HOLE];
		return types.includes(this.type);
	}

	/**
	 * @return bool True if this star is the primary star and does not have a companion
	 */
	isPrimaryComponent()
	{
		return this.primary && this.companion === null;
	}
}

class StarGroup extends AbstractStar
{
	/**
	 * @param array<OrbitingBody>
	 */
	constructor(...bodies)
	{
		super();
		// Orbital characteristics are based on only the furthest body, so sort them based on total orbit
		bodies.sort((a, b) => {
			const x = a.getTotalOrbit();
			const y = b.getTotalOrbit();
			return (x < y ? -1 : (x > y ? 1 : 0));
		});
		this.primary = bodies[0].primary;
		this.designation = '';
		this.luminosity = 0;
		this.n_stars = 0;
		bodies.forEach(body => {
			this.designation += body.getDesignationPrimary();
			this.mass += body.getOrbitalMass();
			this.n_stars += body.n_stars;
			this.luminosity += body.getTotalLuminosity();
		});
		const last = bodies[bodies.length - 1];
		this.orbit = last.getTotalOrbit();
		this.orbit_au = last.orbit_au;
		this.orbit_band = last.orbit_band;
		this.orbit_eccentricity = last.orbit_eccentricity;
		this.orbit_major_min = last.orbit_major_min;
		this.orbit_major_max = last.orbit_major_max;
		this.orbit_period = last.orbit_period;
		this.hzco = calculateHabitableCenterZone(this.getTotalLuminosity());
	}

	getProfileShort()
	{
		return '-';
	}

	getDesignation(n_stars = 1)
	{
		return this.getDesignationPrimary();
	}

	getDesignationPrimary()
	{
		return this.designation;
	}

	getTotalDiameter()
	{
		return -1;
	}

	getTotalLuminosity()
	{
		return this.luminosity;
	}

	getAllowedOrbitMod()
	{
		// Star groups either add to the primary or are themselves a companion pair
		return 0;
	}

	getTotalTemperature()
	{
		return -1;
	}

	isHzcoValid()
	{
		// StarGroup's min and max allowed orbits already account for the star's exclusion zone etc.
		const fudge = getHzcoFudgeFactor();
		return this.allowed_orbits_max > this.allowed_orbits_min
			&& this.getHzcoPlus(fudge) > this.allowed_orbits_min
			&& this.getHzcoPlus(-fudge) < this.allowed_orbits_max;
	}

	/**
	 * @return bool True if this star group contains the system's primary star
	 */
	isPrimaryComponent()
	{
		return this.primary;
	}
}

class StarGroupCompanion extends StarGroup
{
	/**
	 * @param Star star Any host to a companion star
	 */
	constructor(star)
	{
		super(star, star.companion);
		this.designation = star.getDesignationPrimary();
		this.designation_suffix = '(' + this.designation + ')';
		this.mass = star.getOrbitalMass();
		// Companion groups have special rules for calculating MAO
		this.allowed_orbits_min = round(this.getAllowedOrbitsMin(star), 3);
	}

	getAllowedOrbitsMin(star)
	{
		// Orbit#s < (0.5 + companion's ecc) are not available
		let min = star.orbit_exclusion_zone + (0.5 + star.companion.orbit_eccentricity);
		log('Determining MAO for companion; ' + star.orbit_exclusion_zone + '(exclusion zone) + 0.5 + ' + star.companion.orbit_eccentricity + ' (companion eccentricity) = ' + min);
		// If either star has an individual MAO > 0.2, add the larger star's MAO to the range of unavailable Orbit#s
		const max_mao = Math.max(star.orbit_exclusion_zone, star.companion.orbit_exclusion_zone);
		log('Determining MAO for companion; highest MAO of the two stars = ' + max_mao);
		return min + (max_mao > 0.2 ? max_mao : 0);
	}

	getDesignation(n_stars = 1)
	{
		return this.designation + 'ab' + (n_stars > 1 ? ' ' + this.designation_suffix : '');
	}
}

class StarSystem
{
	constructor(stars = [], seed = 'default')
	{
		this.stars = stars;
		this.seed = seed;
		this.age = this.determineAge();
		// Determine the various body counts: Stellar, Planetoid Belt, Gas Giants, and Terrestrial Planets
		this.n_stellar = stars.reduce((n, star) => n + (star.companion ? 2 : 1), 0);
		this.n_planets = 0;
		this.n_planet_belt = 0;
		this.n_planet_gas = 0;
		this.n_planet_rock = 0;
		this.n_empty = 0;
		this.baseline_number = 0;
		this.baseline_orbit = 0;
		this.orbit_spread = 0;
		this.orbit_spread_max = 0;
		this.star_groups = this.buildStarGroups();
		// Optional roll history from factory generation
		this.history = [];
	}

	buildStarGroups()
	{
		let groups = []
		for (let i = 0; i < this.stars.length; i++) {
			const star = this.stars[i];
			const prev = (groups.length > 0 ? groups[groups.length - 1] : null);
			// Determine max allowable Orbit#s centered around any secondary stars (already determined for stars with companions)
			if (!star.primary && star.companion === null) {
				const secondary_orbits_max = Math.max(0, star.getTotalOrbit() - this.getSecondaryMaxOrbitMod(star, i));
				log('Changing MAX allowed orbit of Secondary from ' + star.allowed_orbits_max + ' to ' + secondary_orbits_max);
				star.allowed_orbits_max = secondary_orbits_max;
			}
			// Add the current star
			groups.push(star);
			// Add any companion (and corresponding star group)
			if (star.companion !== null) {
				groups.push(star.companion);
				groups.push(new StarGroupCompanion(star));
			}
			// Add combined star group if this is not the first entry
			if (prev) {
				const last = groups[groups.length - 1];
				const mod = this.getSecondaryGroupExclusionOrbitMod(star);
				log('Secondary exclusion zone for ' + star.getDesignation(this.stars.length) + ': Orbit# ' + star.getTotalOrbit() + ' +/- ' + mod);
				// Previous group's maximum allowable orbit is the inner edge of the current Secondary star's exclusion zone
				prev.allowed_orbits_max = star.getTotalOrbit() - mod;
				const group = new StarGroup(prev, star);
				// The combined group's minimum allowable orbit is the outer edge of the current Secondary star's exclusion zone
				group.allowed_orbits_min = star.getTotalOrbit() + mod;
				group.allowed_orbits_max = Math.max(0, group.getTotalOrbit() - this.getSecondaryMaxOrbitMod(star, i));
				groups.push(group);
			}
		};
		// The final (or perhaps only) group's maximum allowable orbit is always Orbit# 20.0
		if (groups.length > 0) {
			groups[groups.length - 1].allowed_orbits_max = 20;
		}
		return groups;
	}

	getPrimaryStar()
	{
		return this.stars[0];
	}

	/**
	 * @return Star|StarGroupCompanion Either the primary star itself or, if it has a companion, the pair of them as one
	 */
	getPrimaryStarComponent()
	{
		return this.star_groups.find(group => group.isPrimaryComponent());
	}

	getSecondaryMaxOrbitMod(star, i)
	{
		const prev = (i > 0 ? this.stars[i - 1] : null);
		const next = (i + 1 < this.stars.length ? this.stars[i + 1] : null);
		// Only adjacent Secondary stars are counted; Primary stars are ignored here
		const isPrevAdj = star.isAdjacent(prev) && !prev.primary;
		const isNextAdj = star.isAdjacent(next) && !next.primary;
		let mod = 3;
		// Reduce by 1.0 more if there is another Secondary star in any adjacent zone, but only once
		if (isPrevAdj || isNextAdj) {
			mod++;
		}
		// Reduce by 1.0 more if it or any adjacent Secondary star has an eccentricity > 0.2, but only once
		if (this.orbit_eccentricity > 0.2 || (isPrevAdj && prev.orbit_eccentricity > 0.2) || (isNextAdj && next.orbit_eccentricity > 0.2)) {
			mod++;
		}
		// Reduce by 1.0 more if it or any adjacent Secondary star has an eccentricity > 0.5, but only once
		if (this.orbit_eccentricity > 0.5 || (isPrevAdj && prev.orbit_eccentricity > 0.5) || (isNextAdj && next.orbit_eccentricity > 0.5)) {
			mod++;
		}
		return mod;
	}

	/**
	 * The modifier to apply to the Orbit# exclusionary zone around a secondary star when calculating Orbit#s available to the Primary star
	 */
	getSecondaryGroupExclusionOrbitMod(star)
	{
		const ecc_mod = (star.orbit_eccentricity && star.orbit_band < 3 > 0.5 ? 2 : (star.orbit_eccentricity > 0.2 ? 1 : 0));
		const mao_mod = (star.orbit_exclusion_zone > 0.2 ? star.orbit_exclusion_zone : 0);
		return 1 + ecc_mod + mao_mod;
	}

	determineAge()
	{
		if (this.stars.length < 1) {
			return 0;
		}
		// System age is the greater of the primary star and any post-stellar objects
		const primary = this.getPrimaryStar();
		const p_comp = primary.companion;
		const p_age = Math.max(primary.age, (p_comp && p_comp.isPostStellar() ? p_comp.age : 0));
		return this.stars.reduce((a, b) => {
			const x = (b.isPostStellar() ? b.age : 0);
			const y = (b.companion !== null && b.companion.isPostStellar() ? b.companion.age : 0);
			log('Determining age [prior max vs. current Post-Stellar secondary or its companion]: ' + a + ' vs. ' + x + ' vs. ' + y);
			return Math.max(a, Math.max(x, y));
		}, p_age);
	}

	/**
	 * @return float The smaller of #orbit_spread and #orbit_spread_max
	 */
	getMinimumOrbitSpread()
	{
		if (this.orbit_spread < 0.001) return this.orbit_spread_max;
		if (this.orbit_spread_max < 0.001) return this.orbit_spread;
		return Math.min(this.orbit_spread, this.orbit_spread_max);
	}

	getProfileLong()
	{
		return (this.n_stellar > 1 ? this.n_stellar + '-' : '')
			+ this.stars.map(star => 
				star.getProfileLong() +
				(star.primary ? '-' + format(this.age, 3) : '') +
				(star.companion ? ':' + star.companion.getProfileLong() : '')
			).join(':');
	}

	getProfileShort()
	{
		return this.stars.map(star => star.getProfileShort()).join(':');
	}

	/**
	 * G-P-T-N-S: # Gas Giants, # Planetoid Belts, # Terrestrial Planets, Baseline Number, System Spread
	 *
	 * @return string Short version of the Planetary System Profile
	 */
	getPlanetaryProfileShort()
	{
		return this.n_planet_gas
			+ '-' + this.n_planet_belt
			+ '-' + this.n_planet_rock
			+ '-' + Math.max(0, this.baseline_number)
			+ '-' + this.getMinimumOrbitSpread();
	}
}

class World extends OrbitingBody
{
	/**
	 * @param OrbitingBody host Typically a Star or StarGroup
	 * @param float orbit The world's Orbit# around its host
	 * @param int index The numeric position of this body around its host used when determining its designation
	 * @param int type The world type, e.g. PLANET_GAS
	 */
	constructor(host, orbit, index = 1, type = PLANET_GAS)
	{
		super(host);
		this.atmosphere = null;
		this.orbit = orbit;
		this.orbit_au = orbitToAU(this.getTotalOrbit());
		this.index = index;
		this.designation_suffix = convertToRoman(this.index);
		this.size = 0;
		this.temperature = 0;
		this.temperature_mean = null;
		this.temperature_high = null;
		this.temperature_low = null;
		this.type = type;
		this.albedo = 0;
		this.composition = 0;
		this.density = 0;
		this.diameter = 0;
		this.diameter_deviation = 0;
		this.escape_velocity = 0;
		this.gravity = 0;
		this.obliquity = -1;
		this.period_sidereal = null;
		this.period_solar = null;
		this.period_solar_year = null;
		this.habitability = 0;
		this.hydrographics = 0;
		this.surface_distribution = -1;
		this.hill_sphere = 0;
		this.moon_orbit_range = 0;
		this.resource_rating = 0;
		this.main_world_rating = 0;
		this.main_candidate = false;
		// Starport and PGL-T Social Characteristics
		this.starport = -1;
		this.population = -1;
		this.government = -1;
		this.law = -1;
		this.technology = -1;
		// Biological Ratings
		this.biocompatibility = -1;
		this.biocomplexity = -1;
		this.biodiversity = -1;
		this.biomass = -1;
		this.sophont_presence = -1;
		// Continuation Method: World Profile for main world, if any
		this.world_profile = null;
	}

	/**
	 * Applies the Starport and PGL-T traits from the existing main world profile, if any and if applicable
	 */
	applyMainWorldProfile()
	{
		if (this.world_profile && this.world_profile.isApplicable(this)) {
			this.starport = this.world_profile.starport;
			this.population = this.world_profile.population;
			this.government = this.world_profile.government;
			this.law = this.world_profile.law;
			this.technology = this.world_profile.technology;
		}
	}

	/**
	 * @return string Human-readable name for this body's composition
	 */
	getCompositionName()
	{
		if (this.composition === 0) return 'Exotic Ice';
		if (this.composition === 1) return 'Mostly Ice';
		if (this.composition === 2) return 'Mostly Rock';
		if (this.composition === 3) return 'Rock and Metal';
		if (this.composition === 4) return 'Mostly Metal';
		return 'Compressed Metal';
	}

	/**
	 * @param int n_stars The total number of stars in the system
	 */
	getDesignation(n_stars = 1)
	{
		const prefix = (n_stars > 1 ? this.host.getDesignation(n_stars) + ' ' : '');
		return prefix + this.designation_suffix + (this.orbit_lagrange > 0 ? '-L' + (3 + this.orbit_lagrange) : '');
	}

	/**
	 * @return string Any additional notes that should be displayed for this world's entry on the survey form
	 */
	getProfileNotes()
	{
		let desc = [];
		if (this.isInHzco()) desc.push('HZ');
		if (this.orbit_inclination > 0) desc.push('Inclined ' + this.orbit_inclination + '°');
		if (this.orbit_lock === 1) desc.push('1:1 Tidal Lock');
		if (this.orbit_lock === 2) desc.push('3:2 Tidal Lock');
		if (this.habitability > 0) desc.push('HR:' + toHexCode(this.habitability));
		desc.push(this.getTypeName());
		if (this.type === PLANET_ROCK || this.type === PLANET_MOON) {
			desc.push(this.getCompositionName());
			desc.push(this.getTemperatureName() + ' (' + this.temperature + ')');
			if (this.atmosphere?.type > 0) desc.push(this.atmosphere.getProfileLong());
		}
		const bio = this.getBiologicalProfile();
		if (bio.length > 0) {
			desc.push('Life: ' + bio);
		}
		if (this.sophont_presence > -1) {
			desc.push(this.sophont_presence > 0 ? 'Living Sophonts' : 'Extinct Sophonts');
		}
		return desc.join(', ');
	}

	/**
	 * @return string The 3-character (usually) code corresponding to this world's Size, Atmosphere, and Hydrographics
	 */
	getProfileShort()
	{
		if (this.type === PLANET_GAS) return this.getSizeCode();
		return (this.starport > -1 ? toHexCode(this.starport) : '')
			+ this.getPhysicalProfile()
			+ this.getSocialProfile();
	}

	getBiologicalProfile()
	{
		if (this.biomass < 0) return '';
		const mxdc = [
			toHexCode(this.biomass),
			toHexCode(this.biocomplexity),
			toHexCode(this.biodiversity),
			toHexCode(this.biocompatibility),
		];
		return mxdc.join('');
	}

	getPhysicalProfile()
	{
		const sah = [
			this.getSizeCode(),
			(this.atmosphere ? this.atmosphere.getCode() : '0'),
			toHexCode(this.hydrographics),
		];
		return sah.join('');
	}

	getSocialProfile()
	{
		if (this.population < 0) return '';
		const pgl = [
			toHexCode(this.population),
			toHexCode(this.government),
			toHexCode(this.law),
			(this.technology > -1 ? '-' + toHexCode(this.technology) : ''),
		];
		return pgl.join('');
	}

	getSizeCode()
	{
		switch (this.type) {
		case PLANET_GAS: return (this.size > 1 ? 'GL' : (this.size < 1 ? 'GS' : 'GM')) + toHexCode(round(this.getTotalDiameter(), 0));
		// Special Case: Terrestrial planets and Moons can be Size -1, indicating Size Small
		case PLANET_ROCK: return (this.size < 0 ? 'S' : toHexCode(this.size));
		}
		return '-';
	}

	/**
	 * Standard size profile for a Terrestrial World or Moon, in the format S-Dkm-D-G-M
	 */
	getSizeProfile()
	{
		if (this.type !== PLANET_ROCK && this.type !== PLANET_MOON) return '';
		return this.getSizeCode()
			+ '-' + round(this.getTotalDiameter(), 3)
			+ '-' + round(this.density, 3)
			+ '-' + round(this.gravity, 3)
			+ '-' + round(this.getTotalMass(), 3);
	}

	/**
	 * @return float Escape Velocity in km/s
	 */
	getEscapeVelocity()
	{
		const d = this.getTotalDiameter();
		if (d < Number.EPSILON) return 0;
		const num = this.getTotalMass(); // Mass is already in units of Terra
		const den = (this.type === PLANET_GAS ? d : d / TERRA_DIAMETER);
		return Math.sqrt(num / den) * 11186 / 1000;
	}

	/**
	 * @return string Human-readable version of the body's sidereal rotational period
	 */
	getPeriodSidereal()
	{
		return this.getPeriodInHours(this.period_sidereal);
	}

	/**
	 * @return string Human-readable version of the body's solar rotational period
	 */
	getPeriodSolar()
	{
		return this.getPeriodInHours(this.period_solar);
	}

	getPeriodInHours(period)
	{
		if (period === null) return '-';
		if (Math.abs(period) > 4383) {
			const y = period / 8766;
			let n = y > 9999 ? y.toFixed(0).length : (y < 1 ? 3 : 4);
			return format(y, n) + 'y';
		} else if (Math.abs(period) > 99.99) {
			return format(period / 24, 4) + 'd';
		}
		const h = Math.floor(period);
		const r = (period - h) * 60;
		const m = Math.floor(r);
		const s = Math.floor((r - m) * 60);
		return ('' + h) + 'h'
			+ ('' + m).padStart(2, '0') + 'm'
			+ ('' + s).padStart(2, '0') + 's';
	}

	getTemperatureName()
	{
		if (this.temperature <  3) return 'Frozen';
		if (this.temperature <  5) return 'Cold';
		if (this.temperature < 10) return 'Temperate';
		if (this.temperature < 12) return 'Hot';
		return 'Boiling';
	}

	getTotalDiameter()
	{
		return this.diameter + this.diameter_deviation;
	}

	getTypeName()
	{
		switch (this.type) {
		case PLANET_EMPTY: return 'Empty';
		case PLANET_BELT: return 'Planetoid Belt';
		case PLANET_GAS: return 'Gas Giant';
		case PLANET_ROCK: return 'Terrestrial';
		case PLANET_MOON: return 'Moon';
		case PLANET_RING: return 'Planetary Ring';
		}
		return 'Unknown';
	}

	/**
	 * @return AbstractStar This world's (or moon's) host star
	 */
	getHostStar()
	{
		return (this.host instanceof AbstractStar ? this.host : this.host.getHostStar());
	}

	/**
	 * @return float The sum of the total Luminosity of all stars this world orbits, including its own star and its star's host or companion, if any
	 */
	getTotalLuminosity(system)
	{
		const host = this.getHostStar();
		return system.stars.reduce((n, star) => {
			return star.orbit_band <= host.orbit_band
				? n + star.getTotalLuminosity() + (star.companion ? star.companion.getTotalLuminosity() : 0)
				: n;
		}, 0);
	}

	/**
	 * Shortcut to the host star's #getHzco function
	 */
	getHzco()
	{
		return this.getHostStar().getHzco();
	}

	/**
	 * Retrieves the value of #getTotalOrbit appropriate for comparing to HZCO, i.e. that of the world or, if orbiting another world, its host
	 */
	getHzcoOrbit()
	{
		return (this.host instanceof AbstractStar ? this.getTotalOrbit() : this.host.getHzcoOrbit());
	}

	/**
	 * Shortcut to the host star's #getHzcoPlus function
	 */
	getHzcoPlus(mod, n = 3)
	{
		return this.getHostStar().getHzcoPlus(mod, n);
	}

	isInHzco()
	{
		const lower = this.getHzcoPlus(-1);
		const upper = this.getHzcoPlus(1);
		const orbit = this.getHzcoOrbit();
		return orbit > lower && orbit < upper;
	}
}

class PlanetoidBelt extends World
{
	/**
	 * @param OrbitingBody host Typically a World
	 * @param float orbit The planets's Orbit# around its host
	 * @param int index The numeric position of this body around its host used when determining its designation
	 */
	constructor(host, orbit, index = 1)
	{
		super(host, orbit, index, PLANET_BELT);
		this.bulk = 0;
		this.composition_m = 0;
		this.composition_s = 0;
		this.composition_c = 0;
		this.composition_o = 0;
		this.designation_suffix = 'P' + this.designation_suffix;
		this.span = 0;
		// Size 1 ("large" in this context) and Size S significant body counts
		this.n_bodies_large = 0;
		this.n_bodies_small = 0;
	}

	getCompositionProfile()
	{
		return (''+format(this.composition_m, 2)).padStart(2, '0')
			+ '.' + (''+format(this.composition_s, 2)).padStart(2, '0')
			+ '.' + (''+format(this.composition_c, 2)).padStart(2, '0')
			+ '.' + (''+format(this.composition_o, 2)).padStart(2, '0');
	}

	getProfileNotes()
	{
		return super.getProfileNotes() + ', ' + this.getProfileLong();
	}

	getProfileLong()
	{
		return format(this.span, 2)
			+ '-' + this.getCompositionProfile()
			+ '-' + this.bulk
			+ '-' + this.resource_rating
			+ '-' + this.n_bodies_large
			+ '-' + this.n_bodies_small;
	}

	getSignificantBodyCount()
	{
		return this.n_bodies_large + this.n_bodies_small;
	}

	getSizeCode()
	{
		return '0';
	}
}

class Moon extends World
{
	/**
	 * @param OrbitingBody host Typically a World
	 * @param float orbit The moon's Orbit# around its host
	 * @param int index The numeric position of this body around its host used when determining its designation
	 * @param bool significant True if this is a significant moon
	 */
	constructor(host, orbit, index = 1, significant = true)
	{
		super(host, orbit, index, PLANET_MOON);
		this.orbit_au = 0;
		this.significant = significant;
	}

	/**
	 * @param int n_stars The total number of stars in the system
	 */
	getDesignation(n_stars = 1)
	{
		const suffix = (this.significant ? String.fromCharCode(this.index + 96) : this.index);
		return (n_stars > 0 ? this.host.getDesignation(n_stars) + ' ' : '') + suffix;
	}

	/**
	 * @Override Moon orbital periods are in hours rather than years
	 */
	getOrbitalPeriod()
	{
		return format(this.orbit_period, 4) + 'h';
	}

	getSizeCode()
	{
		return (this.size < 0 ? 'S' : toHexCode(this.size));
	}
}

class PlanetaryRing extends Moon
{
	/**
	 * @param OrbitingBody host Typically a World
	 * @param float orbit The ring's Orbit# around its host
	 * @param int index The numeric position of this body around its host used when determining its designation
	 */
	constructor(host, orbit, index = 1)
	{
		super(host, orbit, index, false);
		this.type = PLANET_RING;
		this.orbit_au = 0;
		this.span = 0;
	}

	/**
	 * @return string Any additional notes that should be displayed for this world's entry on the survey form
	 */
	getProfileNotes()
	{
		return this.getTypeName() + ', ' + this.getProfileLong();
	}

	getProfileLong()
	{
		return this.getTotalOrbit().toFixed(2) + '-' + format(this.span, 2);
	}

	getSizeCode()
	{
		return 'R';
	}
}

class AnomalousPlanetData
{
	constructor(eccentricity_dm, inclination = 0, retrograde = false, trojan = false)
	{
		this.orbit_eccentricity_dm = eccentricity_dm;
		this.orbit_inclination = inclination;
		this.orbit_parent_index = null;
		this.orbit_retrograde = retrograde;
		this.orbit_is_trojan = trojan;
	}
}

class WorldPlaceHolder
{
	constructor(group_index, orbit, data = null)
	{
		this.group_index = group_index;
		this.orbit = orbit;
		this.type = null;
		this.main = false;
		this.allow_empty = (data === null);
		this.orbit_eccentricity_dm = (data ? data.orbit_eccentricity_dm : 0);
		this.orbit_inclination = (data ? data.orbit_inclination : 0);
		this.orbit_parent_index = (data ? data.orbit_parent_index : null);
		this.orbit_retrograde = (data ? data.orbit_retrograde : false);
		this.orbit_is_trojan = (data ? data.orbit_is_trojan : false);
	}

	apply(world, world_profile = null)
	{
		world.orbit_eccentricity_dm = this.orbit_eccentricity_dm;
		world.orbit_inclination = this.orbit_inclination;
		world.orbit_parent_index = this.orbit_parent_index;
		world.orbit_retrograde = this.orbit_retrograde;
		if (this.main) {
			world.world_profile = world_profile;
		}
	}

	canPlaceEmpty()
	{
		return this.type === null && this.allow_empty;
	}

	canPlaceType(type)
	{
		return (type === PLANET_EMPTY
			? this.canPlaceEmpty()
			: this.type === null && (!this.orbit_is_trojan || type !== PLANET_BELT));
	}
}

class WorldProfile
{
	constructor(uwp, temperature = 7, host = -1)
	{
		if (![-1, PLANET_GAS, PLANET_ROCK].includes(host)) {
			throw new SyntaxError('Invalid host for satellite Main World; valid types are: Auto (-1), Gas Giant (1), and Terrestrial (3)');
		}
		this.type = PLANET_ROCK;
		this.host = host < 0 ? null : host;
		this.starport = -1;
		this.size = -1;
		this.atmosphere = -1;
		this.hydrographics = -1;
		this.population = -1;
		this.government = -1;
		this.law = -1;
		this.technology = -1;
		this.temperature = temperature;
		this.parseProfile(uwp);
		this.uwp = uwp;
		// Additional fields for use during world placement process:
		this.orbit_index = -1;
		this.star_group = null;
		this.n_planet_belt = 0;
		this.n_planet_gas = 0;
	}

	/**
	 * @return int The initial type of planet to place for the main world; this may be the planet the main world orbits, rather than the main world itself
	 */
	getMainPlanetType(system)
	{
		// Special Case: Planetary Rings placed preferentially around Gas Giant, but a Terrestrial will do if none
		if (this.host === null && this.type === PLANET_RING) {
			this.host = (system.n_planet_gas > 0 ? PLANET_GAS : PLANET_ROCK);
		}
		return this.host === null ? this.type : this.host;
	}

	getHzcoDeviation()
	{
		const atmosphere = new Atmosphere(this.atmosphere);
		const dm = atmosphere.getTemperatureMod();
		const roll = this.temperature - dm;
		const base = 7 - roll;
		const abs = Math.abs(base);
		if (abs < 3) return 0.1 * base;
		if (abs < 4) return (base < 0 ? -0.5 : 0.5);
		if (abs < 5) return (base < 0 ? -1.0 : 1.0);
		return (base < 0 ? -1.1 : 1.1);
	}

	/**
	 * @return bool True if this profile is applicable to the world in question
	 */
	isApplicable(world)
	{
		// Special Case: Moons can be either PLANET_MOON or PLANET_ROCK
		const types = (this.type === PLANET_MOON ? [PLANET_MOON, PLANET_ROCK] : [this.type]);
		return this.host === null
			? world.type === this.type && world.host instanceof AbstractStar
			: types.includes(world.type) && world.host instanceof World && world.host.type === this.host;
	}

	getProfile()
	{
		return this.uwp;
	}

	parseProfile(uwp)
	{
		uwp = this.clean(uwp);
		if (uwp.length === 7 || uwp.length === 9) {
			// Starport values range from 10-14 (A-E) and use 31 (X) to designate none instead of 0
			this.starport = this.parseValue(uwp[0], 10, 14, 'Starport', [31]);
			this.parsePhysical(uwp.substring(1));
			this.parseSocial(uwp.substring(4));
			// No practical cap on TL
			if (uwp.length === 9) {
				this.technology = this.parseValue(uwp[8], 0, 33, 'Technology Level');
			}
		} else if (uwp.length === 6) {
			this.parsePhysical(uwp);
			this.parseSocial(uwp.substring(3));
		} else if (uwp.length === 3) {
			this.parsePhysical(uwp);
		} else {
			throw new SyntaxError('World Profile format must be either SAH, ?SAHPGL, or ?SAHPGL-T');
		}
	}

	parsePhysical(part)
	{
		this.size = this.parseValue(part[0], 0, 15, 'Size', [25,26]);
		// Special Case: Size 0 is a Planetoid Belt
		if (this.size === 0) {
			this.type = PLANET_BELT;
			if (this.host !== null) {
				throw new SyntaxError('Planetoid Belt cannot be a satellite of another body');
			}
		}
		// Special Case: Use -1 for Size S (Small)
		if (this.size === 26) {
			this.size = -1;
		}
		// Special Case: Use 0 for Size R (Ring) and indicate it is a Planetary Ring
		if (this.size === 25) {
			this.size = 0;
			this.type = PLANET_RING;
		}
		// Special Case: Terrestrial worlds in orbit around another body are treated as Moons
		if (this.type === PLANET_ROCK && this.host !== null) {
			this.type = PLANET_MOON;
		}
		this.atmosphere = this.parseValue(part[1], 0, (this.size < 1 ? 0 : 17), 'Atmosphere');
		this.hydrographics = this.parseValue(part[2], 0, (this.size < 2 ? 0 : 10), 'Hydrographics');
	}

	parseSocial(part)
	{
		// Population typically caps at 12, but may be higher in some universes
		this.population = this.parseValue(part[0], 0, 15, 'Population');
		this.government = this.parseValue(part[1], 0, 15, 'Government');
		// Law Level is 2D-7 + government code, with a minimum of 0, so ranges from 0 to 20
		this.law = this.parseValue(part[2], 0, 20, 'Law Level');
	}

	parseValue(value, min, max, field, extra = [])
	{
		const v = fromHexCode(value);
		if (v < min && !extra.includes(v)) throw new SyntaxError('Minimum value for ' + field + ' is ' + min);
		if (v > max && !extra.includes(v)) throw new SyntaxError('Maximum value for ' + field + ' is ' + max);
		return v;
	}

	/**
	 * Sanitizes the UWP input string and returns it in the expected format, e.g. in all Upper Case
	 */
	clean(uwp)
	{
		return uwp.replace(/\s/g, '').toUpperCase();
	}
}

class Atmosphere
{
	/**
	 * @param int type Atmosphere type should be between 0 and 17 (H)
	 * @param int density A numeric rating of atmospheric density from 0-7, with 0 = None, 4 = Standard, and 7 = Extremely Dense
	 * @param bool irritant True if an irritant was indicated during initial generation, allowing it to be rolled later
	 */
	constructor(type = -1, density = -1, irritant = false)
	{
		this.type = type;
		this.type_orig = type;
		this.density = density;
		this.greenhouse_factor = 0;
		this.irritant = irritant;
		this.bar = 0;
		this.ppo = 0;
		this.subtype = -1;
		this.subtype_b = -1;
		this.taints = [];
	}

	getCode()
	{
		return toHexCode(this.type);
	}

	getProfileShort()
	{
		// Corrosive, Exotic, Insidious, and Unusual profiles
		const st = this.getSubtypeProfile();
		if (st.length > 0) {
			return this.getCode() + '-' + st + ':' + this.bar.toFixed(3);
		}
		return this.getCode()
			+ '-' + this.bar.toFixed(3)
			+ '-' + this.ppo.toFixed(3);
	}

	getProfileLong()
	{
		const taints = this.getTaintProfile();
		return this.getProfileShort() + (taints.length > 0 ? ' ' + taints : '');
	}

	getBiomassMod()
	{
		// DM-6 for Atmosphere 0
		if (this.type === 0) return -6;
		// DM-4 for Atmosphere 1
		if (this.type === 1) return -4;
		// DM-3 for Atmosphere 2, 3, or E
		if ([2, 3, 14].includes(this.type)) return -3;
		// DM-2 for Atmosphere 2, 3, or E
		if ([4, 5].includes(this.type)) return -2;
		// DM+2 for Atmosphere 8, 9, or D
		if ([8, 9, 13].includes(this.type)) return 2;
		// DM-3 for Atmosphere A
		if (this.type === 10) return -3;
		// DM-5 for Atmosphere B or F+
		if (this.type === 11 || this.type > 15) return -5;
		// DM-7 for Atmosphere C
		if (this.type === 12) return -7;
		// DM+0 for anything else
		return 0;
	}

	getBiocompatibilityMod()
	{
		// DM-2 for any Atmosphere with a taint
		const dm = (this.taints.length > 0 ? -2 : 0);
		// DM-10 for Atmosphere C
		if (this.type === 12) return dm - 10;
		// DM-8 for Atmosphere 0, 1, B, G, or H
		if ([0, 1, 11].includes(this.type) || this.type > 15) return dm - 8;
		// DM-6 for Atmosphere A or F
		if (this.type === 10 || this.type === 15) return dm - 6;
		// DM-1 for Atmosphere D or E
		if (this.type === 13 || this.type === 14) return dm - 1;
		// DM+1 for Atmosphere 3, 5, or 8
		if ([3, 5, 8].includes(this.type)) return dm + 1;
		// DM+2 for Atmosphere 6
		if (this.type === 6) return dm + 2;
		return dm;
	}

	getDensityName()
	{
		switch (this.density) {
		case 0: return 'None';
		case 1: return 'Extremely Thin';
		case 2: return 'Very Thin';
		case 3: return 'Thin';
		case 4: return 'Standard';
		case 5: return 'Dense';
		case 6: return 'Very Dense';
		case 7: return 'Extremely Dense';
		case 8: return 'Crushing';
		case 9: return 'Extremely Crushing';
		}
		return '';
	}

	getSubtypeProfile()
	{
		if (this.subtype < 0) return '';
		return 'St' + toHexCode(this.subtype) + (this.subtype_b > -1 ? '.' + toHexCode(this.subtype_b) : '');
	}

	getTaintProfile()
	{
		return this.taints.map(taint => taint.getProfileLong()).join(', ');
	}

	getTemperatureMod()
	{
		// DM-2 for Atmosphere 2 or 3
		if (this.type === 2 || this.type === 3) return -2;
		// DM-1 for Atmosphere 4, 5, or E
		if ([4, 5, 14].includes(this.type)) return -1;
		// DM+1 for Atmosphere 8 or 9
		if (this.type === 8 || this.type === 9) return 1;
		// DM+2 for Atmosphere A, D, or F
		if ([10, 13, 15].includes(this.type)) return 2;
		// DM+6 for Atmosphere B or C
		if (this.type === 11 || this.type === 12) return 6;
		// DM+0 for anything else
		return 0;
	}

	getTypeName()
	{
		switch (this.type) {
		case 1: return 'Trace';
		case 10: return 'Exotic, ' + this.getDensityName();
		case 11: return 'Corrosive, ' + this.getDensityName();
		case 12: return 'Insidious, ' + this.getDensityName();
		case 14: return 'Low';
		case 15: return 'Unusual';
		case 16: return 'Gas, Helium';
		case 17: return 'Gas, Hydrogen';
		}
		return this.getDensityName();
	}
}

class AtmosphereTaint
{
	constructor(subtype, severity, persistence)
	{
		this.subtype = subtype;
		this.severity = severity;
		this.persistence = persistence;
	}

	getName()
	{
		switch (this.subtype) {
		case TAINT_B: return 'Biologic';
		case TAINT_G: return 'Gas Mix';
		case TAINT_H: return 'High Oxygen';
		case TAINT_L: return 'Low Oxygen';
		case TAINT_P: return 'Particulates';
		case TAINT_R: return 'Radioactivity';
		case TAINT_S: return 'Sulphur Compounds';
		}
		return 'Unknown';
	}

	getProfileShort()
	{
		return toHexCode(this.subtype);
	}

	getProfileLong()
	{
		return this.getProfileShort()
			+ '.' + this.severity
			+ '.' + this.persistence;
	}
}

class Appraiser
{
	/**
	 * @param callback appraiser The function (object) used to assign each object a rating
	 * @param callback|null responder The function (object, rating), if any, to call after the rating is determined
	 */
	constructor(appraiser, responder = null)
	{
		this.appraiser = appraiser;
		this.responder = (responder === null
			? (object, rating) => rating
			: responder);
		this.max = 0;
		this.min = 0;
	}

	/**
	 * Applies the #appraiser function to the object and keeps track of the minimum and maximum scores.
	 * Calls the #responder function with the object and rating as arguments once complete.
	 */
	apply(object)
	{
		const rating = this.appraiser(object);
		this.max = Math.max(rating, this.max);
		this.min = Math.min(rating, this.min);
		if (this.responder !== null) {
			this.responder(object, rating);
		}
	}
}

class MainWorldFlagger
{
	/**
	 * @param callback|null fn_appraiser Function for the Appraiser constructor, or null to use a default main world rating algorithm
	 * @param float threshold Value from 0 (nearly every planet) to 1 (only the absolute best) indicating how close to the maximum rating a world needs to rate in order to qualify as a main world candidate
	 */
	constructor(fn_appraiser = null, threshold = 0.1)
	{
		const fn_a = (fn_appraiser === null
			? (world) => this.defaultAppraisal(world)
			: fn_appraiser);
		const fn_r = (world, rating) => world.main_world_rating = rating;
		this.appraiser = new Appraiser(fn_a, fn_r);
		this.threshold = clamp(threshold, 0, 1);
		this.candidates = [];
		this.cutoff = 0;
	}

	apply(groups)
	{
		groups.forEach(group => group.bodies.forEach(world => this.appraise(world)));
		const minimum = Math.ceil(this.threshold * this.appraiser.max);
		this.cutoff = Math.max(0, minimum - 1);
		groups.forEach(group => group.bodies.forEach(world => this.flag(world)));
		this.candidates.sort((a, b) => b.main_world_rating - a.main_world_rating);
		log('Main World Appraiser results: high = ' + this.appraiser.max + ', low = ' + this.appraiser.min + ', threshold = ' + this.threshold + ', cutoff = ' + this.cutoff);
	}

	appraise(world)
	{
		this.appraiser.apply(world);
		world.bodies.forEach(body => this.appraiser.apply(body));
	}

	flag(world)
	{
		world.main_candidate = world.main_world_rating > this.cutoff || (world.world_profile && world.world_profile.isApplicable(world));
		this.addCandidate(world);
		world.bodies.forEach(body => {
			body.main_candidate = body.main_world_rating > this.cutoff || (body.world_profile && body.world_profile.isApplicable(body));
			this.addCandidate(body);
		});
	}

	addCandidate(world)
	{
		if (world.main_candidate) {
			this.candidates.push(world);
		}
	}

	defaultAppraisal(world)
	{
		return world.habitability
			+ world.hydrographics
			+ world.resource_rating
			+ world.sophont_presence;
	}
}

class AbstractFactory
{
	constructor()
	{
		this.history = [];
	}

	generate() {}

	/**
	 * Adds the factory history onto the object, if any, then clears it
	 */
	flushHistory(object = null)
	{
		if (object) {
			object.history.push(...this.history);
		}
		this.history = [];
	}

	roll(n, d, dm, desc)
	{
		let result = new Roll(n, d, dm, desc);
		this.history.push(result);
		return result.total;
	}
}

class StarFactory extends AbstractFactory
{
	/**
	 * @param FormData options:
	 *   @option bool prime_main True to restrict the primary star to main-sequence types only
	 *   @option int  prime_peculiar For Peculiar resluts when rolling a Primary: 0 = Carry on, 1 = NS unless 1D = 6 (= BH), 2 = Reroll Unusual result
	 *   @option int  sec_giant_twin For Giant Secondary stars more massive than a Giant Primary: 0 = Twin method, 1 = Class V method
	 *   @option bool star_age_small True to increase precision when determing the age of small stars
	 *   @option bool star_age_large True to use 1D100/100 instead of ((1D-1)+(1D/6))/6 when determing the age of larger stars
	 *   @option bool star_flat_sub True to roll a straight d10-1 for the star's subtype instead of the appropriate 2D table
	 *   @option bool star_trad_gen True to use the traditional Traveller bell curve when generating star types
	 *   @option bool var_mass True to enable variations in star mass
	 *   @option bool var_nits True to enable variations in star luminosity
	 *   @option bool var_size True to enable variations in star diameter
	 *   @option bool var_temp True to enable variations in star temperature
	 */
	constructor(options)
	{
		super();
		this.prime_main = options.has('prime_main');
		this.prime_peculiar = +options.get('prime_peculiar');
		this.sec_giant_twin = +options.get('sec_giant_twin');
		this.star_age_small = options.has('star_age_small');
		this.star_age_large = options.has('star_age_large');
		this.flat_subtypes = options.has('star_flat_sub');
		this.trad_gen = options.has('star_trad_gen');
		this.enable_var_mass = options.has('var_mass');
		this.enable_var_nits = options.has('var_nits');
		this.enable_var_size = options.has('var_size');
		this.enable_var_temp = options.has('var_temp');
	}

	/**
	 * Complete the generation of a star with known type, subtype, and classification
	 *
	 * @param string entry Must be in the standard format TS C (i.e. Type Subtype Classification), e.g. M0 V
	 * @param bool primary True if this is for the primary star
	 *
	 * @throws SyntaxError if unable to parse the entry
	 */
	fromProfile(entry, primary = false)
	{
		const upper = entry.toUpperCase();
		const number = (entry.length > 1 ? Number.parseInt(upper.substring(1, 2)) : NaN);
		const subtype = (Number.isNaN(number) ? -1 : number);
		const type = this.parseType(subtype < 0 ? upper : upper.substring(0, 1));
		if (Number.isNaN(type)) {
			throw new SyntaxError('Failed to parse Type for star entry ' + entry + '; subtype = ' + subtype);
		} else if ((subtype < 0 && type <= MAIN_TYPE_M) || (subtype > -1 && type > MAIN_TYPE_M)) {
			throw new SyntaxError('Invalid Subtype for Type ' + type + ' star entry ' + entry);
		}
		const classification = this.parseClass(type, upper);
		const star = new Star(type, subtype, classification, primary);
		log('Successfully generated star from profile: ' + star.getProfileShort());
		this.genStarTraits(star);
		return star;
	}

	parseType(entry)
	{
		for (const k in STAR_TYPE) {
			if (STAR_TYPE[k] === entry) return k;
		}
		return NaN;
	}

	parseClass(type, entry)
	{
		if (type > MAIN_TYPE_M) return -1;
		// Special Case: Classes Ia and Ib
		if (entry.endsWith('IA')) return 0;
		if (entry.endsWith('IB')) return 1;
		return convertFromRoman(entry.substring(3));
	}

	/**
	 * @param Star|null primary Required when generating Secondary and/or Companion stars
	 * @param string method Required with @primary; valid values are: Random, Lesser, Sibling, Twin, D, and BD
	 */
	generate(primary = null, method = '')
	{
		// Step 1: Type, Class, and Subtype
		const star = this.genStar(primary, method);
		this.genStarTraits(star, primary, method);
		return star;
	}

	genStarTraits(star, primary = null, method = '')
	{
		// Step 2: Mass
		star.mass = this.genMass(star);
		star.mass_deviation = this.genMassDeviation(star);
		// Handle special cases for secondary stars
		const f = (star.classification > 3 ? 0.1 : 0.04);
		let floor = 0;
		let result = null;
		if (primary) {
			switch (method) {
			case 'Lesser':
				// fall-through
			case 'Random':
				// If more massive than primary star; subtract 1 deviation at a time until less massive or floor is reached
				const p_mass = primary.getTotalMass();
				const p_mass_lsd = 0.0001; // least significant digit
				if (star.getTotalMass() > (p_mass - p_mass_lsd)) {
					const one_deviation = (f * star.mass);
					const min_deviations = -5; // mininum result of 2D6-7; see #genMassDeviation
					let num_deviations = Math.round(star.mass_deviation / one_deviation);
					while (star.getTotalMass() > (p_mass - p_mass_lsd) && num_deviations > min_deviations) {
						log('Secondary star ' + star.getProfileShort() + ' more massive than primary; reducing mass by one deviation: -' + one_deviation);
						star.mass_deviation -= one_deviation;
						num_deviations--;
					}
				}
				if (star.getTotalMass() > p_mass) {
					log('Failed to reduce secondary star mass ' + star.getProfileShort() + ' below that of primary ' + primary.getProfileShort());
				}
				break;
			case 'Sibling':
				// Sibling's mass should not initially exceed that of its primary (which could be a companion host), but may be less
				star.mass = Math.min(star.mass, primary.mass);
				star.mass_deviation = Math.min(star.mass_deviation, primary.mass_deviation);
				// Reduce mass by 1D x 10%, but not past minimum
				floor = -f * 5 * star.mass;
				result = 0.1 * this.roll(1, 6, 0, 'Sibling Star Variance: Mass');
				star.mass_deviation = Math.max(floor, star.mass_deviation - (result * star.mass));
				break;
			case 'Twin':
				// Set the twin's mass to that of its primary (which could be a companion host), then reduce it slightly
				star.mass = primary.mass;
				star.mass_deviation = primary.mass_deviation;
				// Optionally reduce mass by 1D x 1%, but not past minimum
				floor = -f * 5 * star.mass;
				result = 0.01 * this.roll(1, 6, 0, 'Twin Star Variance: Mass');
				star.mass_deviation = Math.max(floor, star.mass_deviation - (result * star.mass));
				break;
			default:
				// no-op
			}
		}
		
		// Step 3: Age, since it depends only on Mass and some subsequent steps may require it (e.g. for White Dwarfs)
		star.age = this.genAge(star);
		
		// Step 4: Temperature
		star.temperature = this.genTemperature(star, primary);
		star.temperature_deviation = this.genTemperatureDeviation(star, primary);
		
		// Step 5: Diameter
		star.diameter = this.genDiameter(star, primary);
		star.diameter_deviation = this.genDiameterDeviation(star, primary);
		// Handle special cases for secondary stars
		if (primary && method === 'Twin') {
			// Optionally reduce diameter by 1D x 1%, but not past minimum
			floor = -f * 5 * star.diameter;
			result = 0.01 * this.roll(1, 6, 0, 'Twin Star Variance: Diameter');
			star.diameter_deviation = Math.max(floor, star.diameter_deviation - (result * star.diameter));
		}
		
		// Step 6: Luminosity and HZCO
		star.luminosity = this.genLuminosity(star, primary);
		star.luminosity_deviation = this.genLuminosityDeviation(star, primary);
		star.hzco = calculateHabitableCenterZone(star.getTotalLuminosity());
	}

	genStar(primary, method)
	{
		let star = null;
		// Attempt to generate a valid Secondary using the requested method; for Random, this will always return null
		if (primary) {
			// Special Case: Protostar primaries pass in their future state when generating secondary stars
			const dummy = (primary.type === PROTOSTAR ? new Star(primary.proto_type, primary.proto_subtype, primary.proto_classification) : primary);
			log('Generating secondary star using the [' + method + '] method for primary ' + dummy.getProfileShort());
			star = this.genSecondaryStar(dummy, method);
			// Special Case: Protostars reroll the secondary until the result is a supported star type
			const p_max_type = Math.max(BROWN_DWARF, WHITE_DWARF);
			while (star && star.type > p_max_type && primary.type === PROTOSTAR) {
				log('Protostar Primary: rerolling unsupported secondary star type of ' + star.getProfileShort());
				star = this.genSecondaryStar(dummy, method);
			}
			if (star) {
				// Special Case: Protostar primary requires all secondaries to be Protostars as well
				if (primary.type === PROTOSTAR) {
					this.setProtostarDataFrom(star, star);
				}
				log('Valid secondary stellar object generated: ' + star.getProfileShort());
				return star;
			}
		}
		// Standard star generation (i.e. Primary or Random Secondary)
		star = this.genTypeAndClass(primary);
		// Special Case: Protostars must be rerolled if the primary is NOT a protostar
		if (primary && primary.type !== PROTOSTAR) {
			while (star.type === PROTOSTAR) {
				log('Non-Protostar Primary: rerolling protostar secondary star result...');
				star = this.genTypeAndClass(primary);
			}
		}
		if (primary) {
			star.primary = false;
		}
		// Special Case: Protostars require rolling for the kind of star they will become, with DM+1 on first roll of the star type table
		let proto = null;
		let proto_tmp = null;
		if (star.type === PROTOSTAR) {
			// DM+1 ensures a main-sequence star
			proto = this.genTypeAndClass(primary, 1);
			// Special Case: Type O Protostars would develop too quickly; change to Type B
			if (proto.type === MAIN_TYPE_O) {
				proto.type = MAIN_TYPE_B;
			}
			// Swap the star and proto temporarily to allow the remaining rules to be applied
			proto_tmp = star;
			star = proto;
			proto = proto_tmp;
		}
		star.subtype = this.genSubtype(star);
		// Special Case: Type K Class IV stars subtract 5 from any subtype result of 4+
		if (star.type === MAIN_TYPE_K && star.subtype > 4 && star.classification === 4) {
			log('Invalid subtype ' + star.subtype + ' for K IV star; reducing by 5');
			star.subtype -= 5;
		}
		// Randomly-generated non-primary main-sequence stars treat any results of hotter type/subtype as lesser instead
		if (!star.primary && star.subtype > -1 && star.type <= MAIN_TYPE_M) {
			const p_star = (primary.type === PROTOSTAR ? new Star(primary.proto_type, primary.proto_subtype, primary.proto_classification) : primary);
			// Set to same stellar type and allow the subtype to make it cooler
			if (star.type < p_star.type) {
				log('Secondary ' + star.getProfileShort() + ' star is hotter than primary ' + p_star.getProfileShort() + ', reducing type to match primary');
				star.type = p_star.type;
			}
			// Special Case: Giant Class stars may become more massive as they cool; adjust so they do not become more massive than the primary, if possible
			let allow_sub_mod = this.adjustSecondaryGiant(p_star, star);
			// Adjust subtype if still hotter than primary, which may further change the star's type
			if (allow_sub_mod && star.type === p_star.type && star.subtype < p_star.subtype) {
				log('Secondary ' + star.getProfileShort() + ' star still hotter than primary, reducing subtype');
				star.subtype = p_star.subtype + 1;
				if (star.subtype > 9) {
					star.subtype -= 10;
					star.type += 1;
					log('Change in subtype resulted in cooler type: secondary star reduced to ' + star.getProfileShort());
				}
			}
			// Special Case: Class IV K5+ and M0+ (in case of above adjustments)
			this.adjustClassFourIfTooCool(star);
			// Special Case: Class VI changes any Type A to B and F to G
			this.adjustInvalidClassSix(star);
			// Any star that moves beyond the main sequence becomes a brown dwarf
			if (star.type > MAIN_TYPE_M) {
				log('Secondary star moved out of main sequence; reduced to Brown Dwarf');
				this.setStarData(star, BROWN_DWARF, -1, -1);
			}
		}
		// Special Case: Swap Prostar back in and store the type of star it will become
		if (proto) {
			proto_tmp = star; // i.e. the protostar's future state
			star = proto;     // i.e. the actual protostar
			this.setProtostarDataFrom(star, proto_tmp);
		}
		// Special Case: If the primary star is a Protostar, all secondary objects must also be protostars
		if (primary && primary.type === PROTOSTAR && star.type !== PROTOSTAR) {
			this.setProtostarDataFrom(star, star);
		}
		// Sanity check
		if (star.type <= MAIN_TYPE_M) {
			if (!STAR_DATA.hasOwnProperty(star.type)) {
				log('Invalid star type: ' + star.type);
			} else if (!STAR_DATA[star.type].hasOwnProperty(star.classification)) {
				log('Invalid star class: ' + star.classification + ' for type: ' + star.type);
			} else if (!STAR_DATA[star.type][star.classification].hasOwnProperty(star.subtype)) {
				log('Invalid star subtype: ' + star.subtype + ' for type: ' + star.type + ' and class: ' + star.classification);
			} else {
				log('Valid star generated: ' + star.getProfileShort());
			}
		} else if (star.subtype > -1) {
			log('Invalid subtype: ' + star.type + ' for otherwise valid stellar object: ' + star.getProfileShort());
		} else if (star.classification > -1) {
			log('Invalid class: ' + star.classification + ' for otherwise valid stellar object: ' + star.getProfileShort());
		} else {
			log('Valid stellar object generated: ' + star.getProfileShort());
		}
		return star;
	}

	genSecondaryStar(primary, method)
	{
		switch (method) {
		case 'BD':
			return new Star(BROWN_DWARF, -1, -1, false);
		case 'D':
			return new Star(WHITE_DWARF, -1, -1, false);
		case 'Lesser':
			// Same class but one type cooler, e.g. F becomes G, etc., and reroll subtype
			let lesser = new Star(primary.type, -1, primary.classification, false);
			if (lesser.type === BLACK_HOLE) {
				// Special Case: A lesser Black Hole becomes a Neutron Star
				lesser.type = NEUTRON_STAR;
			} else if (lesser.type === NEUTRON_STAR || lesser.type === PULSAR) {
				// Special Case: A lesser Neutron Star or Pulsar becomes a White Dwarf
				lesser.type = WHITE_DWARF;
			} else if (lesser.type === WHITE_DWARF) {
				// Special Case: A lesser White Dwarf becomes a Brown Dwarf
				lesser.type = BROWN_DWARF;
			} else if (lesser.type === MAIN_TYPE_M) {
				// M-type remains the same type (for now)
			} else if (lesser.type < MAIN_TYPE_M) {
				// All other main sequence stars become one type cooler, i.e. bigger numeric type
				lesser.type += 1;
			}
			// Reroll the new subtype
			lesser.subtype = this.genSubtype(lesser);
			// Special Case: Giant Class stars may become more massive as they cool in some cases
			let allow_sub_mod_lesser = this.adjustSecondaryGiant(primary, lesser);
			// Special Case: M-type becomes a brown dwarf if it is hotter (i.e. lower numeric subtype) than its parent
			if (allow_sub_mod_lesser && lesser.type === MAIN_TYPE_M && lesser.type === primary.type && lesser.subtype < primary.subtype) {
				log('Lesser Type M star reduced to Brown Dwarf');
				this.setStarData(lesser, BROWN_DWARF, -1, -1);
			}
			// Special Case: Class IV K5+ and M0+
			this.adjustClassFourIfTooCool(lesser);
			// Special Case: Class VI changes any Type A to B and F to G
			this.adjustInvalidClassSix(lesser);
			return lesser;
		case 'Random':
			// Roll as normal, but treat any results of hotter type/subtype as lesser instead
			return null;
		case 'Sibling':
			let sibling = new Star(primary.type, primary.subtype, primary.classification, false);
			// All non-main sequence stars retain their primary star's characteristics
			if (sibling.type > MAIN_TYPE_M) {
				return sibling;
			}
			// Special Case: Giant Class stars may become more massive as they cool in some cases
			let allow_sub_mod_sibling = this.adjustSecondaryGiant(primary, sibling);
			// Add 1D to the subtype (i.e. cooler), subtracting 10 instead if this moves to a lower type
			sibling.subtype += (allow_sub_mod_sibling ? this.roll(1, 6, 0, 'Sibling Star Subtype Modifier') : 0);
			if (sibling.subtype > 9) {
				sibling.subtype -= 10;
				sibling.type += 1;
				// Special Case: M-type becomes a Brown Dwarf if it moves out of the main sequence
				if (sibling.type > MAIN_TYPE_M) {
					this.setStarData(sibling, BROWN_DWARF, -1, -1);
				}
				log('Sibling star subtype reduction moved star to next lower class; new profile: ' + sibling.getProfileShort());
			}
			// Special Case: Class IV K5+ and M0+
			this.adjustClassFourIfTooCool(sibling);
			// Special Case: Class VI changes any Type A to B and F to G
			this.adjustInvalidClassSix(sibling);
			return sibling;
		case 'Twin':
			return new Star(primary.type, primary.subtype, primary.classification, false);
		}
		log('Unknown method for secondary star generation: ' + method);
		return null;
	}

	genTypeAndClass(primary = null, proto_dm = 0)
	{
		let classification = -1;
		let result = this.roll(2, 6, proto_dm, 'Star Type: ' + (this.trad_gen ? 'Traditional Table' : 'Realistic Table'));
		let type = (this.trad_gen ? TYPE_TRAD[result] : TYPE_REAL[result]);
		if (type > ANOMALY) {
			result = this.roll(2, 6, 0, 'Star Type: Hot Table');
			type = TYPE_HOT[result];
			classification = 5; // Class V
		} else if (type < 0) {
			if (this.prime_main) {
				result = this.roll(2, 6, 0, 'Star Type: Special Table');
				classification = CLASS_SPECIAL[result];
				if (classification > 15) {
					result = this.roll(2, 6, 0, 'Star Type: Giant Table');
					classification = CLASS_GIANT[result];
				}
			} else {
				result = this.roll(2, 6, 0, 'Star Type: Unusual Table');
				classification = CLASS_UNUSUAL[result];
				// Option 2: Reroll any Peculiar result when generating a Primary Star
				if (primary === null && this.prime_peculiar === 2) {
					while (classification < 0) {
						result = this.roll(2, 6, 0, 'Star Type: Rerolling Peculiar Result');
						classification = CLASS_UNUSUAL[result];
					}
				}
				if (classification < 0) {
					// Option 1: Roll 1D for any Peculiar result when generating a Primary Star; 1-5 = NS and 6 = BH
					if (primary === null && this.prime_peculiar === 1) {
						result = this.roll(1, 6, 0, 'Star Type: Peculiar, 1D version (1-5 = NS, 6 = BH)');
						type = (result > 5 ? BLACK_HOLE : NEUTRON_STAR);
					} else {
						// Option 0 and non-Primary stars - roll on!
						result = this.roll(2, 6, 0, 'Star Type: Peculiar Table');
						type = TYPE_PECULIAR[result];
					}
				} else if (classification > 15) {
					result = this.roll(2, 6, 0, 'Star Type: Giant Table');
					classification = CLASS_GIANT[result];
				} else if (classification === BROWN_DWARF || classification === WHITE_DWARF) {
					// Special Case: Types D and BD
					type = classification;
					classification = -1; // undefined
				}
			}
		} else {
			classification = 5; // Class V
		}
		const star = new Star(type, -1, classification);
		// Reroll for Type with DM+1 if only Class determined
		if (star.type < 0 && star.classification > -1) {
			result = this.roll(2, 6, 1, 'Star Type: Reroll w/DM+1');
			star.type = (this.trad_gen ? TYPE_TRAD[result] : TYPE_REAL[result]);
			if (star.type > ANOMALY) {
				result = this.roll(2, 6, 0, 'Star Type: Hot Table');
				star.type = TYPE_HOT[result];
			}
		}
		// Special Case: Class IV adds DM+5 to any Type M and changes Type O to B
		if (star.classification === 4) {
			if (star.type === MAIN_TYPE_M) {
				star.type = (this.trad_gen ? TYPE_TRAD[result + 5] : TYPE_REAL[result + 5]);
			}
			if (star.type === MAIN_TYPE_B) {
				star.type = MAIN_TYPE_B;
			}
		}
		// Special Case: Class VI changes any Type A to B and F to G
		this.adjustInvalidClassSix(star);
		log('Star type and class (initial values) determined: ' + star.type + ', ' + star.classification);
		return star;
	}

	genSubtype(star)
	{
		// Only main-sequence stars have a subtype
		if (star.type > MAIN_TYPE_M) {
			return -1;
		}
		const mtype = (star.primary && star.type === MAIN_TYPE_M);
		// M-Types always use the Straight Roll method when using traditional traveler generation
		if (this.flat_subtypes || (mtype && this.trad_gen)) {
			return this.roll(1, 10, -1, 'Star Subtype: Straight');
		}
		const result = this.roll(2, 6, 0, 'Star Subtype: ' + (mtype ? 'M-Type' : 'Numeric'));
		if (mtype) {
			return SUBTYPE_M_PRIMARY[result];
		}
		// Special Case for K IV stars handled externally to allow Lesser and Sibling secondaries of a cooler subtype, which then transition to Class V stars instead
		return SUBTYPE_NUMERIC[result];
	}

	setProtostarDataFrom(proto, star)
	{
		proto.proto_type = star.type;
		proto.proto_subtype = star.subtype;
		proto.proto_classification = star.classification;
		this.setStarData(proto, PROTOSTAR, -1, -1);
		log('Protostar future star profile set to: ' + star.getProfileShort());
	}

	setStarData(star, type, subtype, classification)
	{
		star.type = type;
		star.subtype = subtype;
		star.classification = classification;
	}

	genMass(star)
	{
		// Table lookup by Type + Subtype + Class for all OBAFGKM-type stars
		if (star.type <= MAIN_TYPE_M) {
			log('Star Data [Mass]: looking up Type ' + star.type + ', Subtype ' + star.subtype + ', and Class ' + star.classification);
			return STAR_DATA[star.type][star.classification][star.subtype]['M'];
		}
		// Special Case: Protostar systems determine mass as the star they will become, with up to +/- 50% variance (applied via #genMassDeviation)
		if (star.type === PROTOSTAR && star.proto_type <= MAIN_TYPE_M) {
			log('Star Data [Mass]: looking up Protostar Type ' + star.proto_type + ', Subtype ' + star.proto_subtype + ', and Class ' + star.proto_classification);
			return STAR_DATA[star.proto_type][star.proto_classification][star.proto_subtype]['M'];
		}
		const label = 'Star Mass: ' + star.getName();
		// Special Case: Brown Dwarf = 1D/100 + (4D-1)/1000 [0.013 to 0.08]
		if (star.type === BROWN_DWARF || (star.type === PROTOSTAR && star.proto_type === BROWN_DWARF)) {
			return (0.01 * this.roll(1, 6, 0, label))
				+ (0.001 * this.roll(4, 6, -1, label));
		}
		// Special Case: White Dwarf = (2D-1)/10 + d10/100
		if (star.type === WHITE_DWARF || (star.type === PROTOSTAR && star.proto_type === WHITE_DWARF)) {
			return (0.1 * this.roll(2, 6, -1, label))
				+ (0.01 * this.roll(1, 10, 0, label));
		}
		// Special Case: Neutron Star = 1 + (1D/10), and if that was a 6, then add another (1D-1)/10
		// Pulsars are a type of NS so use the same formula here
		if (star.type === NEUTRON_STAR || star.type === PULSAR) {
			let base = this.roll(1, 6, 0, label);
			let mass = 1 + (0.1 * base);
			if (base === 6) {
				mass += 0.1 * this.roll(1, 6, -1, label);
			}
			return mass;
		}
		// Special Case: Black Hole = 1.1 + 1Dp + d10/10; 1D penetrates on 6 - keep rolling!
		if (star.type === BLACK_HOLE) {
			let mass = 1.1 + (0.1 * this.roll(1, 10, 0, label));
			let roll = 0;
			do {
				roll = this.roll(1, 6, 0, label);
				mass += roll;
			} while (roll === 6);
			return mass;
		}
		// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
		return 0.001;
	}

	genMassDeviation(star)
	{
		// Skip if not enabled
		if (!this.enable_var_mass) {
			return 0;
		}
		// Ignore mass variance for any post-stellar objects
		if (star.isPostStellar()) {
			return 0;
		}
		const result = this.roll(2, 6, -7, 'Star Variance: Mass');
		return (star.classification > 3 || star.type === PROTOSTAR
			? result * 0.1 * star.mass    // Giant  = +/- 50%, 0.1  = 0.2 * 0.5 (and also any Protostar, not just future Giants)
			: result * 0.04 * star.mass); // Normal = +/- 20%, 0.04 = 0.2 * 0.2
	}

	/**
	 * Star temperature may depend on mass and/or age
	 */
	genTemperature(star, primary = null)
	{
		// Table lookup by Type + Subtype + Class for all OBAFGKM-type stars
		if (star.type <= MAIN_TYPE_M) {
			log('Star Data [Temp]: looking up Type ' + star.type + ', Subtype ' + star.subtype + ', and Class ' + star.classification);
			return STAR_DATA[star.type][star.classification][star.subtype]['T'];
		}
		// Special Case: Protostar systems determine temperature as the star they will become
		if (star.type === PROTOSTAR && star.proto_type <= MAIN_TYPE_M) {
			log('Star Data [Temp]: looking up Protostar Type ' + star.proto_type + ', Subtype ' + star.proto_subtype + ', and Class ' + star.proto_classification);
			return STAR_DATA[star.proto_type][star.proto_classification][star.proto_subtype]['M'];
		}
		// Special Case: Brown Dwarf = lookup table (by mass)
		if (star.type === BROWN_DWARF || (star.type === PROTOSTAR && star.proto_type === BROWN_DWARF)) {
			return this.getBrownDwarfData(star)['T'];
		}
		// Special Case: White Dwarf  = lookup table (by age) * (M / 0.6)
		// Special Case: Neutron Star = as White Dwarf
		// Pulsars are a type of NS and use the same formula here
		if ([WHITE_DWARF, NEUTRON_STAR, PULSAR].includes(star.type) || (star.type === PROTOSTAR && [WHITE_DWARF, NEUTRON_STAR, PULSAR].includes(star.proto_type))) {
			return this.getWhiteDwarfData(star, primary)['T'] * star.mass / 0.6;
		}
		// Special Case: Black Holes, by definition, do not radiate heat, but the accretion disk may generate a great deal of electromagnetic radiaion
		if (star.type === BLACK_HOLE) {
			return 0;
		}
		// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
		return 100;
	}

	genTemperatureDeviation(star, primary = null)
	{
		// Skip if not enabled
		if (!this.enable_var_temp) {
			return 0;
		}
		const type = (star.type === PROTOSTAR ? star.proto_type : star.type);
		// Ignore temperature variance for any non-main sequence object
		if (type > MAIN_TYPE_M) {
			return 0;
		}
		const classification = (star.type === PROTOSTAR ? star.proto_classification : star.classification);
		const subtype = (star.subtype === PROTOSTAR ? star.proto_subtype : star.subtype);
		const sub_lookup = (subtype > 0 ? subtype - 1 : subtype + 1);
		log('Star Data [Temp]: looking up Type ' + type + ', Subtype ' + subtype + ', and Class ' + classification + ' (deviation)');
		const a = star.temperature;
		const b = STAR_DATA[type][classification][sub_lookup]['T'];
		const max_diff = (a > b ? a - b : b - a) / 2;
		const result = this.roll(1, 101, -51, 'Star Variance: Temperature');
		return result * 0.01 * max_diff;
	}

	/**
	 * Star diameter depends on mass
	 */
	genDiameter(star, primary = null)
	{
		// Table lookup by Type + Subtype + Class for all OBAFGKM-type stars
		if (star.type <= MAIN_TYPE_M) {
			log('Star Data [Size]: looking up Type ' + star.type + ', Subtype ' + star.subtype + ', and Class ' + star.classification);
			return STAR_DATA[star.type][star.classification][star.subtype]['D'];
		}
		// Special Case: Protostar systems multiply any resulting diameter by 1 + (2D-2) ÷ 10
		const proto_f = (star.type === PROTOSTAR ? (1 + this.roll(2, 6, -2, 'Star Diameter: Protostar inherent variability') / 10) : 1);
		// Special Case: Protostar systems; treat as Class V of same type and subtype
		if (star.type === PROTOSTAR && star.proto_type <= MAIN_TYPE_M) {
			log('Star Data [Size]: looking up Protostar Type ' + star.proto_type + ', Subtype ' + star.proto_subtype + ', and Class ' + star.proto_classification + ' (but treated as Class V for this calculation)');
			return proto_f * STAR_DATA[star.proto_type][5][star.proto_subtype]['D'];
		}
		// Special Case: Brown Dwarf = 0.1, unless 0.05 < M < 0.07, in which case roll as large Gas Giant (the planet), i.e. 2D+6, w/DM-2
		if (star.type === BROWN_DWARF || (star.type === PROTOSTAR && star.proto_type === BROWN_DWARF)) {
			let m = star.getTotalMass();
			if (m > 0.05 && m < 0.07 ? -2 : 0) {
				// Convert planetary Terra-based diameter to stellar Sol units
				return proto_f * (TERRA_DIAMETER * this.roll(2, 6, 4, 'Star Diameter: ' + star.getName())) / SOL_DIAMETER;
			}
			return proto_f * 0.1;
		}
		// Special Case: White Dwarf = 0.01 / M
		if (star.type === WHITE_DWARF || (star.type === PROTOSTAR && star.proto_type === WHITE_DWARF)) {
			return proto_f * 0.01 / star.getTotalMass();
		}
		// Special Case: Neutron Star = 1D + 19 km (remember to CONVERT to Sol Diameters!!!)
		// Pulsars are a type of NS so use the same formula here
		if (star.type === NEUTRON_STAR || star.type === PULSAR) {
			return (19 + this.roll(1, 6, 0, 'Star Diameter: ' + star.getName())) / SOL_DIAMETER;
		}
		// Special Case: Black Hole = 5.9 km * M (remember to CONVERT to Sol Diameters!!!)
		if (star.type === BLACK_HOLE) {
			return (5.9 * star.getTotalMass()) / SOL_DIAMETER;
		}
		// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
		return 1;
	}

	genDiameterDeviation(star, primary = null)
	{
		// Skip if not enabled
		if (!this.enable_var_size) {
			return 0;
		}
		// Special Case: Protostar diameters have built-in variability (see #genDiameter) so don't need any extra added here
		// Ignore variance any non-main sequence object
		if (star.type > MAIN_TYPE_M) {
			return 0;
		}
		const result = this.roll(2, 6, -7, 'Star Variance: Diameter');
		return (star.classification > 3
			? result * 0.1 * star.diameter    // Giant  = +/- 50%, 0.1  = 0.2 * 0.5
			: result * 0.04 * star.diameter); // Normal = +/- 20%, 0.04 = 0.2 * 0.2
	}

	/**
	 * Luminosity depends on diameter and temperature; may also depend on mass and/or age for certain star types
	 */
	genLuminosity(star, primary = null)
	{
		let compute = !this.enable_var_nits;
		// Special Case: Neutron Star = can be computed, provided diameter is in Sol units instead of km (which was done in genDiameter)
		// Pulsars are a type of NS so use the same formula here
		// Special Case: Protostar systems have highly variable diameters and should thus always use the calculation
		if ([NEUTRON_STAR, PULSAR, PROTOSTAR].includes(star.type)) {
			compute = true;
		}
		// Non-variable luminosity is calculated based on diameter and temperature
		if (compute) {
			const SOL_TEMP = 5772;
			return Math.pow(star.getTotalDiameter(), 2) * Math.pow(star.getTotalTemperature() / SOL_TEMP, 4);
		}
		// Table lookup by Type + Subtype + Class for all OBAFGKM-type stars
		if (star.type <= MAIN_TYPE_M) {
			log('Star Data [Lum.]: looking up Type ' + star.type + ', Subtype ' + star.subtype + ', and Class ' + star.classification);
			return STAR_DATA[star.type][star.classification][star.subtype]['L'];
		}
		// Special Case: Brown Dwarf = lookup table (by mass)
		if (star.type === BROWN_DWARF) {
			return this.getBrownDwarfData(star)['L'];
		}
		// Special Case: White Dwarf = lookup table (by age)
		if (star.type === WHITE_DWARF) {
			return this.getWhiteDwarfData(star, primary)['L'];
		}
		// Special Case: Black Hole = 0, other than as remnants from e.g. shredded stars
		if (star.type === BLACK_HOLE) {
			return 0;
		}
		// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
		return 0;
	}

	genLuminosityDeviation(star, primary = null)
	{
		// Skip if not enabled
		if (!this.enable_var_nits) {
			return 0;
		}
		// Ignore variance for post-stellar objects
		if (star.isPostStellar()) {
			return 0;
		}
		const result = this.roll(2, 6, -7, 'Star Variance: Luminosity');
		return (star.classification > 3 || (star.type === PROTOSTAR && star.proto_classification > 3)
			? result * 0.1 * star.luminosity    // Giant  = +/- 50%, 0.1  = 0.2 * 0.5
			: result * 0.04 * star.luminosity); // Normal = +/- 20%, 0.04 = 0.2 * 0.2
	}

	/**
	 * The age of a star depends only upon its mass
	 */
	genAge(star)
	{
		const mass = star.getTotalMass();
		star.life_main = 10 / Math.pow(mass, 2.5);
		star.life_subgiant = star.life_main / (4 + mass);
		star.life_giant = star.life_main / (10 * Math.pow(mass, 3));
		if (star.type > MAIN_TYPE_M) {
			let age = 0;
			// White Dwarf, Neutron Star, Pulsar, and Black Hole all add the Dead Star formula
			if ([WHITE_DWARF, NEUTRON_STAR, PULSAR, BLACK_HOLE].includes(star.type)) {
				age += this.genAgeDead(star);
			}
			// Brown Dwarf, White Dwarf, Neutron Star, and Black Hole add the Small Star formula
			if ([BROWN_DWARF, WHITE_DWARF, NEUTRON_STAR, BLACK_HOLE].includes(star.type)) {
				age += this.genAgeSmall(star);
			}
			// Pulsars add (100,000,000 years i.e. 0.1 Gyr / 2d10)
			if (star.type === PULSAR) {
				age += 0.1 / this.roll(2, 10, 0, 'Age: Pulsar');
			}
			// Protostars add (10,000,000 years i.e. 0.01 Gyr / 2d10)
			if (star.type === PROTOSTAR) {
				age += 0.01 / this.roll(2, 10, 0, 'Age: Protostar');
			}
			// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
			return age;
		} else if (star.classification < 4) {
			// Giant
			return this.genAgeGiant(star);
		} else if (star.classification === 4) {
			// Subgiant
			return this.genAgeSubgiant(star);
		} else if (star.getTotalMass() > 0.9) {
			// Large Star
			return this.genAgeLarge(star);
		}
		// Small Star
		return this.genAgeSmall(star);
	}

	genAgeGiant(star)
	{
		const f = (this.star_age_large
			? 0.01 * this.roll(1, 100, 0, 'Age: Giant Star')
			: (this.roll(1, 6, -1, 'Age: Giant Star') + (this.roll(1, 6, 0, 'Age: Giant Star') / 6)) / 6);
		return star.life_main + star.life_subgiant + (f * star.life_giant);
	}

	genAgeSubgiant(star)
	{
		const f = (this.star_age_large
			? 0.01 * this.roll(1, 100, 0, 'Age: Subgiant Star')
			: (this.roll(1, 6, -1, 'Age: Subgiant Star') + (this.roll(1, 6, 0, 'Age: Subgiant Star') / 6)) / 6);
		return star.life_main + (f * star.life_subgiant);
	}

	genAgeLarge(star)
	{
		const min = (star.getTotalMass() < 4.7 ? 0.01 : 0.1);
		if (this.star_age_large) {
			return Math.max(min, star.life_main * 0.01 * this.roll(1, 100, 0, 'Age: Large Star'));
		} else {
			return Math.max(min, star.life_main * (this.roll(1, 6, -1, 'Age: Large Star') + (this.roll(1, 6, 0, 'Age: Large Star') / 6)) / 6);
		}
	}

	genAgeSmall(star)
	{
		const a = (2 * this.roll(1, 6, 0, 'Age: Small Star'));
		const b = this.roll(1, 3, (this.star_age_small ? -2 : -1), 'Age: Small Star');
		const c = (this.star_age_small ? this.roll(1, 10, 0, 'Age: Small Star') / 10 : 0);
		const min = 0.1;
		const max = 12;
		return clamp(a + b + c, min, max);
	}

	genAgeDead(star)
	{
		const mass = this.roll(1, 3, 2, 'Age: Dead Star, Prior Mass') * star.getTotalMass();
		const main = 10 / Math.pow(mass, 2.5);
		const sub = main / (4 + mass);
		const giant = main / (10 * Math.pow(mass, 3));
		return main + sub + giant;
	}

	getWhiteDwarfData(star, primary)
	{
		const eff_age = (primary ? primary.age : star.age);
		const lookup = WHITE_DWARF_DATA.findLast(row => eff_age >= row['A']);
		log('White Dwarf (or equivalent) data lookup for effective age ' + eff_age + ': ' + (lookup === undefined ? 'FAIL - fallback to last entry' : 'Matched Age: ' + lookup['A']));
		return lookup === undefined
			? WHITE_DWARF_DATA[WHITE_DWARF_DATA.length - 1]
			: lookup;
	}

	getBrownDwarfData(star)
	{
		// Allow for up to half of the interpolated deviation between each row to achieve better matching
		const deviation = 0.00375;
		const mass = star.getTotalMass() + deviation;
		const lookup = BROWN_DWARF_DATA.find(row => mass > row['M']);
		log('Brown Dwarf (or equivalent) data lookup for effective mass ' + mass + ': ' + (lookup === undefined ? 'FAIL - fallback to last entry' : 'Matched Mass: ' + lookup['M']));
		return lookup === undefined
			? BROWN_DWARF_DATA[BROWN_DWARF_DATA.length - 1]
			: lookup;
	}

	/** 
	 * Special Case: Class IV stars of type K5+ or M0+; these move to Class V instead
	 */
	adjustClassFourIfTooCool(star)
	{
		if (star.classification === 4 && (star.type === MAIN_TYPE_M || (star.type === MAIN_TYPE_K && star.subtype > 4))) {
			log('Class IV star ' + star.getProfileShort() + ' is too cool, changing to Class V');
			star.classification = 5;
		}
	}

	/** 
	 * Special Case: Class VI changes any Type A to B and F to G
	 */
	adjustInvalidClassSix(star)
	{
		if (star.classification === 6) {
			if (star.type === MAIN_TYPE_A) {
				log('Invalid Type A Class VI star changed to Type B');
				star.type = MAIN_TYPE_B;
			}
			if (star.type === MAIN_TYPE_F) {
				log('Invalid Type F Class VI star changed to Type G');
				star.type = MAIN_TYPE_G;
			}
		}
	}

	/**
	 * Special Case: Giant-class stars begin increasing in mass as they cool starting at G1 (K1 for Class III);
	 * this function ensures such a Secondary does not become more massive than its Giant-class Primary
	 *
	 * @return bool True if the star's resulting subtype is allowed to be further modified
	 */
	adjustSecondaryGiant(primary, star)
	{
		if (star.type < primary.type || star.classification > primary.classification || !primary.isGiant() || !star.isGiant()) {
			// no adjustment needed
		} else if ((star.classification < 3 && star.type >= MAIN_TYPE_G) || star.type >= MAIN_TYPE_K) {
			if (this.sec_giant_twin) {
				log('Giant-class Secondary ' + star.getProfileShort() + ' star will become more massive as it cools; changing it to be a Twin of the primary');
				this.setStarData(star, primary.type, primary.subtype, primary.classification);
				return false;
			} else {
				log('Giant-class Secondary ' + star.getProfileShort() + ' star will become more massive as it cools; changing it to Class V of at least the same Type as the Primary');
				this.setStarData(star, Math.max(star.type, primary.type), star.subtype, 5);
				// Allow modifying subtype for everything but Type M so the former Giant does not end up as
				// a Brown Dwarf; it is already guaranteed to be cooler and less massive than the Primary
				return star.type < MAIN_TYPE_M;
			}
		}
		return true;
	}

	adjustForPostStellarObject(object, primary)
	{
		if (!object.isPostStellar() || object.age <= primary.life_main) {
			return;
		}
		// Prevent running to infinity by setting a hard limit
		const max_mass = 1000000;
		while (object.age > primary.life_main && object.getTotalMass() < max_mass) {
			log('Increasing mass of post-stellar object (m = ' + object.getTotalMass() + ') to accomodate primary main sequence limit of ' + primary.life_main);
			this.increasePostStellarObjectMass(object, primary);
		}
		// Recalculate temperature, diameter, and luminosity based on increased mass and current post-stellar type
		// Exclusion zones (MAO) are calculated in a later step, so no need to worry about them here
		object.temperature = this.genTemperature(object, primary);
		object.diameter = this.genDiameter(object, primary);
		object.luminosity = this.genLuminosity(object, primary);
	}

	increasePostStellarObjectMass(object, primary)
	{
		const f = 0.01 * this.roll(2, 6, 3, 'Post-Stellar Mass Adjustment: ' + object.getName());
		object.mass = (1 + f) * object.mass;
		// Special Case: White Dwarfs become Neutron Stars when their mass exceeds 1.2
		if (object.type === WHITE_DWARF && object.getTotalMass() > 1.2) {
			object.type = NEUTRON_STAR;
		}
		// Special Case: Neutron Stars become Black Holes when their mass exceeds 2.16
		if (object.type === NEUTRON_STAR && object.getTotalMass() > 2.16) {
			object.type = BLACK_HOLE;
		}
		// Use the Final Age formula (i.e. Dead Star); do NOT include the Small Star Age for this step
		object.age = this.genAgeDead(object);
	}
}

class StarSystemFactory extends AbstractFactory
{
	/**
	 * @param StarFactory  star_factory
	 * @param WorldFactory world_factory
	 * @param FormData options:
	 *   @option bool enable_ecc True to calculate orbital eccentricities
	 *   @option bool var_orbit True to enable variations in star orbits
	 *   @option bool cumulative_orbit True to calculate each planetary orbit from the previous orbit, i.e. with cumulative variance
	 *   @option bool per_star_baseline True to calculate baseline number, baseline Orbit#, and system spread for each secondary and companion star separately
	 *   @option bool per_star_empty_orbits True to determine empty orbits for each star (or group) individually, rather than for the system as a whole
	 *   @option bool cont_sec True to enable checking for secondary stars when only the primary was provided (Continuation Method)
	 * @param string seed Seed used for random number generation
	 */
	constructor(star_factory, world_factory, options, seed = 'default')
	{
		super();
		this.star_factory = star_factory;
		this.world_factory = world_factory;
		this.enable_eccentricity = options.has('enable_ecc');
		this.enable_var_orbit = options.has('var_orbit');
		this.cumulative_orbit = options.has('cumulative_orbit');
		this.per_star_baseline = options.has('per_star_baseline');
		this.per_star_empty_orbits = options.has('per_star_empty_orbits');
		this.continuation_add_secondaries = options.has('cont_sec');
		this.seed = seed;
		this.bands = ['Primary', 'Close', 'Near', 'Far'];
	}

	/**
	 * @param array profile_stars Optional profiles for existing stars when using the Continuation method
	 * @param array profile_planets Optional System Planetary Profile data for number of existing planets, Baseline Number, and System Spread when using the Continuation method
	 * @param WorldProfile|null world_profile Optional main world profile
	 */
	generate(profile_stars = [], profile_planets = [], world_profile = null)
	{
		//=== STAR GEN ===//
		// Step 1: Determine Primary Star
		let stars = [];
		const primary = (profile_stars.length > 0
			? this.star_factory.fromProfile(profile_stars[0], true)
			: this.star_factory.generate());
		this.star_factory.flushHistory(primary);
		stars.push(primary);
		
		// Step 2: Determine presence of Secondary and/or Companion Star(s)
		let secondaries = (profile_stars.length > (this.continuation_add_secondaries ? 1 : 0)
			? this.getSecondariesFromProfiles(primary, profile_stars)
			: this.checkForSecondaryObjects(primary));
		
		// Step 3: Determine Orbit#(s) and Eccentricity
		secondaries = this.genSecondaryOrbits(primary, secondaries);
		
		// Step 4: Determine Type, Class, etc. of any Secondary and/or Companion Star(s)
		// For companions, treat their partner as the Primary for all relevant calculations
		for (let i = 0; i < secondaries.length; i++) {
			let method = '';
			let star = null;
			let entry = secondaries[i];
			if (i === 0) {
				star = primary;
			} else if (entry['present']) {
				if (entry['present'] instanceof AbstractStar) {
					star = entry['present'];
				} else {
					method = this.genSecondaryStarMethod(primary, entry);
					star = this.star_factory.generate(primary, method);
				}
				this.assignSecondaryCharacteristics(star, entry);
				star.designation = stars.length;
				star.orbit_band = i;
				this.star_factory.flushHistory(star);
				stars.push(star);
			}
			// Generate companion star, if any
			if (star && entry['companion']) {
				let companion = null;
				if (entry['companion'] instanceof AbstractStar) {
					companion = entry['companion'];
				} else {
					method = this.genSecondaryStarMethod(star, entry, true);
					companion = this.star_factory.generate(star, method);
				}
				companion.host = star;
				// Special Case: Orbit# for companions of giants (Ia, Ib, II, or III) = 1D x MAO of the primary star (i.e. the giant)
				if (star.type <= MAIN_TYPE_M && star.classification < 4) {
					// MAO of many giants can be > 3.5 which, multiplied by 1D, could exceed the maximum Orbit# of 20
					// To avoid this, first convert MAO to AU, multiply by the specified 1D, then convert back to Orbit#
					const giant_dev = this.roll(1, 6, 0, 'Companion Orbit#: ' + this.bands[i] + ' Giant');
					const giant_mao = this.getOrbitalExclusionZone(star);
					const giant_min_au = orbitToAU(giant_mao);
					entry['companion_orbit'] = auToOrbit(giant_dev * giant_min_au);
				}
				this.assignSecondaryCharacteristics(companion, entry, 'companion_');
				star.designation += 4;
				companion.designation = star.designation + 4;
				companion.orbit_band = i; // same orbital band as host star
				this.star_factory.flushHistory(companion);
				star.companion = companion;
			}
		};
		
		// Special Case: Binary star systems use only A and B designations, even for the primary's companion
		const n_stars = stars.reduce((n, star) => n + (star.companion ? 2 : 1), 0);
		if (n_stars === 2) {
			stars[0].designation = 0;
			if (stars[0].companion) {
				stars[0].companion.designation = 1;
			} else {
				stars[1].designation = 1;
			}
		}
		
		// Step 5: Adjust mass of any post-stellar objects to accommodate a main sequence primary star
		if (primary.type <= MAIN_TYPE_M) {
			stars.forEach(star => {
				if (star.isPostStellar() && star.age > primary.life_main) {
					this.star_factory.adjustForPostStellarObject(star, primary);
					this.star_factory.flushHistory(star);
				}
				if (star.companion && star.companion.isPostStellar() && star.companion.age > primary.life_main) {
					this.star_factory.adjustForPostStellarObject(star.companion, primary);
					this.star_factory.flushHistory(star.companion);
				}
			});
		}
		
		// Step 6: Adjust overlapping Orbit#s
		let n_adj = 0;
		while (this.adjustStellarOrbits(stars)) {
			// continues adjusting until no further adjustments are made
			n_adj++;
			log(n_adj + ' Adjusted stellar orbits');
		}
		
		// Step 7: Determine orbital periods only after mass and Orbit#s all finalized, and calculate the base MAO of each while we're at it
		const p_mass = primary.getOrbitalMass();
		stars.forEach(star => {
			star.orbit_exclusion_zone = this.getOrbitalExclusionZone(star);
			if (!star.primary) {
				// Primary star is at AU 0, so need only use the secondary's orbit_au as the separation value
				star.orbit_period = Math.sqrt(Math.pow(star.orbit_au, 3) / (p_mass + star.getOrbitalMass()));
			}
			if (star.companion) {
				// When determining the period of a companion around its host, the companion's orbit_au accounts for the entire separation
				star.companion.orbit_period = Math.sqrt(Math.pow(star.companion.orbit_au, 3) / star.getOrbitalMass());
				star.companion.orbit_exclusion_zone = this.getOrbitalExclusionZone(star.companion);
				// Maximum allowed orbit only relevant for stars with companions
				star.allowed_orbits_max = this.getMaximumAllowableOrbit(star);
				star.companion.allowed_orbits_max = this.getMaximumAllowableOrbit(star.companion);
			}
		});
		// Step 8: Determine number of planets, if any, orbiting each star and/or star group
		let system = this.genWorldCounts(new StarSystem(stars, this.seed), profile_planets, world_profile);
		system.n_orbits = this.determineTotalSystemOrbits(system);
		this.flushHistory(system);
		
		//=== WORLD GEN ===//
		if (system.n_orbits > 0) {
			// Step 1: Determine allowable orbits (i.e. orbit_slots) and allocated orbits (i.e. n_bodies) for each star
			this.determineOrbitsPerStar(system);
			
			// Step 2: Determine system baseline number
			// Only care about Primary group's HZCO for this step, even though it has the combined orbit slots for all of A, AB, ABC, and ABCD groups
			const p_group = system.getPrimaryStarComponent();
			system.baseline_number = (profile_planets.length > 3 && profile_planets[3] !== null
				? profile_planets[3]
				: this.determineBaselineNumber(system, p_group, false));
			
			// Step 3: Determine system baseline Orbit#
			// Since the primary group itself may not have any orbits, use the first primary group that does for HZCO and Min/Max Allowable Orbit#s
			const active_group = system.star_groups.find(group => group.isPrimaryComponent() && group.getTotalAllowedOrbits() > 0);
			if (active_group === undefined) {
				log('Failed to determine System Baseline Orbit# - no primary group with Allowable Orbit#s could be found');
			} else {
				system.baseline_orbit = round(this.determineBaselineOrbit(system, active_group, system.baseline_number, p_group.n_bodies, false), 3);
				log('System Baseline Orbit# set to: ' + system.baseline_orbit);
			}
			
			// Step 4: Empty orbits
			this.determineEmptyOrbits(system);
			
			// Step 5: Determine system spread
			system.orbit_spread = (profile_planets.length > 4 && profile_planets[4] !== null
				? round(profile_planets[4], 3)
				: round(this.determineSystemSpread(system, active_group), 3));
			system.orbit_spread_max = round(this.determineSystemSpreadMax(system), 3);
			this.flushHistory(system);
			system.star_groups.forEach(group => {
				if (group.n_bodies > 0 && !group.isPrimaryComponent()) {
					// Determine max spread for each secondary even if not determining the other characteristics independently
					group.orbit_spread_max = this.determineSecondarySpreadMax(system, group);
					// Optionally determine Baseline #, Baseline Orbit#, and Spread for each companion and non-primary star with orbit_slots > 0
					if (this.per_star_baseline) {
						group.baseline_number = this.determineBaselineNumber(system, group, true);
						group.baseline_orbit = round(this.determineBaselineOrbit(system, group, group.baseline_number, group.n_bodies, true), 3);
						log('Secondary Baseline Orbit# for ' + group.getDesignation(system.n_stellar) + ' set to: ' + group.baseline_orbit);
						group.orbit_spread = round(this.determineSecondarySpread(group.baseline_number, group.baseline_orbit, group), 3);
						this.flushHistory(group);
					}
				}
			});
			
			// Continuation Method: Main worlds with atmosphere 4-9 need to be placed inside an HZCO
			if (world_profile && world_profile.atmosphere > 3 && world_profile.atmosphere < 10) {
				const group = this.determineMainWorldStarGroup(system, world_profile);
				if (group) {
					const baseline_new = round(this.determineMainWorldBaselineOrbit(group, world_profile), 3);
					world_profile.star_group = group;
					if (group.isPrimaryComponent()) {
						system.baseline_orbit = baseline_new;
						system.orbit_spread = round(this.determineSystemSpread(system, group), 3);
					} else {
						group.baseline_orbit = baseline_new;
						group.orbit_spread = round(this.determineSecondarySpread(group.baseline_number, group.baseline_orbit, group), 3);
					}
					log('Continuation Method, Step 3D: Successfully determined main world Baseline Orbit# ' + baseline_new + ' around ' + group.getDesignation(system.n_stellar));
				} else {
					log('Continuation Method, Step 3D: Failed to determine main world Baseline Orbit# - no suitable HZCO found');
				}
			}
			
			// Add a bit more variability when the minimum orbit_spread is significantly less than the potential maximum
			if (profile_planets.length > 3 && profile_planets[3] !== null) {
				// Do not adjust user-entered system spread
			} else if ((system.orbit_spread_max / system.orbit_spread) > (system.n_planets + system.n_empty)) {
				const spread_half = system.orbit_spread_max / 2;
				const spread_mod = 0.1 * spread_half * this.roll(2, 6, -7, 'System Spread: Additional Amount (default was too small)');
				log('System Spread of ' + system.orbit_spread + ' is far smaller than Max of ' + system.orbit_spread_max + '; increasing by +' + (spread_half + spread_mod));
				system.orbit_spread = round(system.orbit_spread + spread_half + spread_mod, 3);
			}
			
			// Step 6: Placing Orbit#s
			// Primary star(s) first
			const p_groups = system.star_groups.filter(group => group.isPrimaryComponent());
			const spread = system.getMinimumOrbitSpread();
			if (p_groups[0].n_bodies > 0) {
				this.determineOrbitNumbers(p_groups[0], spread, p_groups, world_profile);
				this.recalculatePrimaryBodyCounts(p_groups[0], p_groups);
			}
			// Then any secondary and/or companion star with independent orbits
			system.star_groups.forEach(group => {
				if (!group.isPrimaryComponent() && group.n_bodies > 0) {
					// Use the group's individual spread value if available (i.e. > 0)
					const group_spread = (this.per_star_baseline ? group.getMinimumOrbitSpread() : 0);
					this.determineOrbitNumbers(group, (group_spread > 0 ? group_spread : spread), [], world_profile);
				}
			});
			
			// Step 7: Anomalous Planets
			const n_anomalous = clamp(this.roll(2, 6, -9, 'Anomalous Planet Count'), 0, 3);
			if (n_anomalous > 0) {
				this.genAnomalousPlanets(system, n_anomalous);
			}
			
			// Step 8: Placing Worlds
			this.placeWorlds(system, world_profile);
			
			// Step 9: Determine Planetary Physical and Orbital Characteristics
			system.star_groups.forEach(group => {
				group.bodies.forEach(body => {
					// Generate the world's physical characteristics (other than Size) such as Diameter and Mass
					this.world_factory.genTraits(system, body);
					this.world_factory.flushHistory(body);
					// Eccentricity and related characteristics
					const ecc_world = this.world_factory.getEccentricityMod(system, body);
					// Special Case: Trojan Planets use the parent's eccentricity and inclination
					if (body.orbit_parent_index !== null) {
						body.orbit_eccentricity = group.bodies[body.orbit_parent_index].orbit_eccentricity;
						body.orbit_inclination = group.bodies[body.orbit_parent_index].orbit_inclination;
					} else {
						body.orbit_eccentricity = this.genEccentricity(ecc_world, 'Planetary Orbital Eccentricity');
					}
					this.calculateOrbitalCharacteristics(body);
					this.flushHistory(body);
					// Orbital Period
					const p_mass = body.getTotalMass() * TERRA_MASS_TO_SOL;
					body.orbit_period = Math.sqrt(Math.pow(body.orbit_au, 3) / (p_mass + body.host.getOrbitalMass()));
					this.world_factory.genRotationTraits(system, body);
					// Special Case: 1:1 lock attenuates eccentricity; reroll with DM-2 and use the lower value
					if (body.orbit_lock === 1 && body.orbit_eccentricity > 0.1) {
						const ecc_lock_body = this.genEccentricity(ecc_world - 2, '1:1 Tidal Lock: Eccentricity');
						body.orbit_eccentricity = Math.min(ecc_lock_body, body.orbit_eccentricity);
						this.calculateOrbitalCharacteristics(body);
						this.flushHistory(body);
					}
					this.world_factory.genTemperatureExtremes(system, body);
					this.world_factory.genTerrestrialLifeTraits(system, body);
					// Determine Hill Sphere and Moon Orbit Range
					body.hill_sphere = this.world_factory.genHillSphere(system, body);
					body.moon_orbit_range = Math.floor(body.hill_sphere / 2) - 2;
					// Significant Moons
					this.world_factory.genSignificantMoons(system, body);
					body.bodies.forEach(moon => {
						const ecc_moon = this.world_factory.getMoonEccentricityMod(moon);
						moon.orbit_eccentricity = this.genEccentricity(ecc_world + ecc_moon, 'Moon Orbital Eccentricity');
						moon.orbit_retrograde = (this.roll(2, 6, ecc_moon, 'Moon Orbit Direction') > 9);
						this.flushHistory(moon);
						this.world_factory.genRotationTraits(system, moon);
						// Special Case: 1:1 lock attenuates eccentricity; reroll with DM-2 and use the lower value
						if (moon.orbit_lock === 1 && moon.orbit_eccentricity > 0.1) {
							const ecc_lock_moon = this.genEccentricity(ecc_world + ecc_moon - 2, '1:1 Tidal Lock: Eccentricity');
							moon.orbit_eccentricity = Math.min(ecc_lock_moon, moon.orbit_eccentricity);
							this.flushHistory(moon);
						}
						this.world_factory.genTemperatureExtremes(system, moon);
						this.world_factory.genTerrestrialLifeTraits(system, moon);
					});
					this.flushHistory(body);
				});
			});
		} else if (system.n_planets > 0) {
			log('Generated system with ' + system.n_planets + ' planetary bodies but no available orbits');
		}
		this.flushHistory(system);
		
		// Additional debug information
		system.star_groups.forEach(group => log(group));
		return system;
	}

	/**
	 * @return bool True if any changes to Orbit#s were made
	 */
	adjustStellarOrbits(stars)
	{
		let changed = false;
		for (let i = stars.length - 1; i > 0; i--) {
			let outer = stars[i];
			let inner = stars[i - 1];
			// Crossed orbits, add 1.0 until they are not or the maximum Orbit# is reached
			while (outer.orbit_major_min < inner.orbit_major_max && outer.orbit <= 19.00) {
				log('Adjusting outer orbit for ' + outer.getProfileShort() + '; min orbit ' + outer.orbit_major_min + ' crosses inner ' + inner.getProfileShort() + ' max orbit ' + inner.orbit_major_max);
				outer.orbit = outer.orbit + 1;
				this.calculateOrbitalCharacteristics(outer);
				changed = true;
			}
		}
		return changed;
	}

	assignSecondaryCharacteristics(star, entry, prefix = '')
	{
		star.orbit = entry[prefix + 'orbit'];
		star.orbit_deviation = entry[prefix + 'orbit_deviation'];
		star.orbit_eccentricity = entry[prefix + 'orbit_eccentricity'];
		this.calculateOrbitalCharacteristics(star);
	}

	/**
	 * Calculates the values for the orbiting body's orbit_au, orbit_major_min, and orbit_major_max fields
	 *
	 * @param OrbitingBody body
	 */
	calculateOrbitalCharacteristics(body)
	{
		body.orbit_au = orbitToAU(body.getTotalOrbit());
		body.orbit_major_min = body.orbit_au * (1 - body.orbit_eccentricity);
		body.orbit_major_max = body.orbit_au * (1 + body.orbit_eccentricity);
	}

	getOrbitalExclusionZone(star)
	{
		// Special Case: Brown Dwarf MAO is 0.005 instead of 0.01
		// Special Case: Dead Star system MAO is 0.001 instead of 0.01
		const min = (star.type === BROWN_DWARF ? 0.005 : (star.isPostStellar() ? 0.001 : 0.01));
		return Math.max(0.01, auToOrbit(0.01 * star.getTotalDiameter()));
	}

	/**
	 * Determines the maximum allowable orbit#, if any, in which planets can orbit around a star
	 */
	getMaximumAllowableOrbit(star)
	{
		if (star.getHzco() > 0.129 || !this.isCandidateForIndependentOrbit(star)) {
			return 0;
		}
		const companion = (star.companion === null ? star : star.companion);
		return 0.25 * companion.getTotalOrbit() * (1 - companion.orbit_eccentricity);
	}

	isCandidateForIndependentOrbit(star)
	{
		// Brown Dwarfs always qualify
		if (star.type === BROWN_DWARF) {
			return true;
		}
		// Other stars must be dimmer than M5 V (0.0029) or M5 VI (0.00072)
		if (star.type === MAIN_TYPE_M && star.subtype > 5 && star.classification > 4) {
			return true;
		}
		// Any Post-Stellar objects such as White Dwarfs can qualify if they are dimmer than an M5 V star (i.e. 0.0029)
		return star.isPostStellar() && star.getTotalLuminosity() < 0.0029;
	}

	getSecondariesFromProfiles(primary, profiles)
	{
		let secondaries = [
			{'present': primary, 'companion': false},
			{'present': false, 'companion': false},
			{'present': false, 'companion': false},
			{'present': false, 'companion': false},
		];
		const close_ok = !primary.isGiant();
		const max_stars = Math.min(profiles.length, (close_ok ? 8 : 6));
		for (let i = 1; i < max_stars; i++) {
			const star = this.star_factory.fromProfile(profiles[i], false);
			let flag = false;
			while (!flag) {
				let roll = this.roll(1, 6, 0, 'Existing Star Location: ' + star.getProfileShort());
				// 3+ Star Systems use Far instead of Roll Again on a roll of 6
				if (roll === 6 && profiles.length > 2) {
					roll = 4;
				}
				if (roll < 5) {
					for (let j = roll - 1; !flag && j < secondaries.length; j++) {
						// Close band is not allowed if primary is a giant
						if (!close_ok && j === 1) j++;
						if (!secondaries[j]['present']) {
							flag = true;
							secondaries[j]['present'] = star;
							log('Placed secondary star ' + star.getProfileShort() + ' in band #' + j);
						} else if (!secondaries[j]['companion']) {
							flag = true;
							// Swap them if the companion would be more massive
							if (star.getTotalMass() > secondaries[j]['present'].getTotalMass()) {
								secondaries[j]['companion'] = secondaries[j]['present'];
								secondaries[j]['present'] = star;
								log('Placed secondary star ' + star.getProfileShort() + ' as host in band #' + j + '; less massive host swapped to companion');
							} else {
								secondaries[j]['companion'] = star;
								log('Placed secondary star ' + star.getProfileShort() + ' as companion in band #' + j);
							}
						}
						// Check again starting from the primary
						if (j === secondaries.length - 1) j = -1;
					}
				} else if (roll === 5) {
					// Attempt to match secondary star as a companion to an existing star, but only if same type and class
					for (let k = 0; !flag && k < secondaries.length; k++) {
						if (secondaries[k]['present'] instanceof AbstractStar && !secondaries[k]['companion']) {
							flag = (secondaries[k]['present'].type === star.type && secondaries[k]['present'].classification === star.classification);
							if (flag) {
								// Swap them if the companion would be more massive
								if (star.getTotalMass() > secondaries[k]['present'].getTotalMass()) {
									secondaries[k]['companion'] = secondaries[k]['present'];
									secondaries[k]['present'] = star;
									log('Placed secondary star ' + star.getProfileShort() + ' as host in band #' + k + '; less massive host swapped to companion');
								} else {
									secondaries[k]['companion'] = star;
									log('Placed secondary star ' + star.getProfileShort() + ' as companion in band #' + k);
								}
							}
						}
					}
				}
				// Roll again on a 6 or 5 that didn't find a match
			}
			this.flushHistory(star);
		}
		return secondaries;
	}

	getSecondaryPresenceMod(primary)
	{
		let dm = 0;
		// Primary star of Class Ia ,Ib, II, III or IV
		if (primary.classification < 5) dm++;
		// Primary star of Class V or VI and type O, B, A or F
		if (primary.type <= MAIN_TYPE_F && (primary.classification === 5 || primary.classification === 6)) dm++;
		// Primary star of Class V or VI and type M
		if (primary.type === MAIN_TYPE_M && (primary.classification === 5 || primary.classification === 6)) dm--;
		// Primary star is a Brown Dwarf, White Dwarf, Neutron Star, Pulsar or Black Hole
		if ([BROWN_DWARF, WHITE_DWARF, NEUTRON_STAR, PULSAR, BLACK_HOLE].includes(primary.type)) dm--;
		// Protostar, Nebula, Star Cluster, and Anomaly have no additional modifier
		return dm;
	}

	checkForSecondaryObjects(primary)
	{
		const threshold = 9;
		const dm = this.getSecondaryPresenceMod(primary);
		return this.checkForCompanionObjects(dm, [
			{'present': true},
			{'present': (primary.classification > 4 && this.roll(2, 6, dm, 'Secondary Presence: ' + this.bands[1])) > threshold},
			{'present': (this.roll(2, 6, dm, 'Secondary Presence: ' + this.bands[2]) > threshold)},
			{'present': (this.roll(2, 6, dm, 'Secondary Presence: ' + this.bands[3]) > threshold)},
		]);
	}

	checkForCompanionObjects(dm, entries)
	{
		for (let i = 0; i < entries.length; i++) {
			entries[i]['companion'] = (entries[i]['present'] && (this.roll(2, 6, dm, 'Companion Presence: ' + this.bands[i]) > 9));
		};
		return entries;
	}

	genSecondaryOrbits(primary, entries)
	{
		// DM+2 Star Eccentricity, presumably this applies to ALL stars
		const ecc_mod_star = 2;
		// DM-1 For all Orbit#s below 1.0 if system is > 1 Gyr in age (using the Primary's age since the remaining stars have not yet been determined)
		const is_older_system = (primary.age > 1);
		let ecc_mod_near = 0;
		// DM+1 For each star an object directly orbits beyond the first, i.e. all of the stars with Orbit# less than itself, including companions
		let n_stars = 0; // Technically 1, but the Primary is not counted for the eccentricity DM so exclude it now
		for (let i = 0; i < entries.length; i++) {
			if (entries[i]['present']) {
				if (i > 0) {
					const dm = ((i - 1) * 6) - 1;
					entries[i]['orbit'] = Math.max(0.5, this.roll(1, 6, dm, 'Secondary Orbit#: ' + this.bands[i]));
					entries[i]['orbit_deviation'] = (this.enable_var_orbit ? 0.1 * this.roll(2, 6, -7, 'Secondary Orbit# Variance: ' + this.bands[i]) : 0);
					// Minimum total Orbit# is 0.01
					if ((entries[i]['orbit'] + entries[i]['orbit_deviation']) < 0.01) {
						log('Enforcing minimum 0.01 Orbit# for ' + this.bands[i] + ' Secondary at Orbit# ' + entries[i]['orbit'] + ' with deviation ' + signed(entries[i]['orbit_deviation']));
						entries[i]['orbit_deviation'] = -(entries[i]['orbit'] - 0.01);
					}
					ecc_mod_near = (is_older_system && (entries[i]['orbit'] + entries[i]['orbit_deviation']) < 1 ? -1 : 0);
					entries[i]['orbit_eccentricity'] = this.genEccentricity(n_stars + ecc_mod_star + ecc_mod_near, 'Secondary Orbital Eccentricity: ' + this.bands[i]);
					n_stars++; // Each Secondary star counts as DM+1 for eccentricity of stars further out, as well as for its own companion, if any
				} else {
					entries[i]['orbit'] = 0;
					entries[i]['orbit_deviation'] = 0;
					entries[i]['orbit_eccentricity'] = 0;
				}
				// Handle the companion, if any, first to increase the stellar body count
				if (entries[i]['companion']) {
					const a = this.roll(1, 6, 0, 'Companion Orbit#: ' + this.bands[i]);
					const b = this.roll(2, 6, -7, 'Companion Orbit#: ' + this.bands[i]);
					entries[i]['companion_orbit'] = (a * 0.1) + (b * 0.01);
					entries[i]['companion_orbit_deviation'] = 0; // built in to companion orbit#
					ecc_mod_near = (is_older_system && entries[i]['companion_orbit'] < 1 ? -1 : 0);
					entries[i]['companion_orbit_eccentricity'] = this.genEccentricity(n_stars + ecc_mod_star + ecc_mod_near, 'Companion Orbital Eccentricity: ' + this.bands[i]);
					n_stars++; // Each Companion counts as DM+1 for eccentricity of stars further out, but not for its own host star
				}
			}
		};
		return entries;
	}

	genEccentricity(dm, label)
	{
		if (!this.enable_eccentricity) {
			return 0;
		}
		const chart = {
			5: {'base': -0.001, 'roll': 1, 'divisor': 1000},
			6: {'base': 0, 'roll': 1, 'divisor': 200},
			7: {'base': 0, 'roll': 1, 'divisor': 200},
			8: {'base': 0.03, 'roll': 1, 'divisor': 100},
			9: {'base': 0.03, 'roll': 1, 'divisor': 100},
			10: {'base': 0.05, 'roll': 1, 'divisor': 20},
			11: {'base': 0.05, 'roll': 2, 'divisor': 20},
			12: {'base': 0.3, 'roll': 2, 'divisor': 20},
		};
		const i = clamp(this.roll(2, 6, dm, label), 5, 12);
		const a = chart[i]['base'];
		const b = this.roll(chart[i]['roll'], 6, 0, label) / chart[i]['divisor'];
		return clamp(a + b, 0.000, 0.999);
	}

	/**
	 * @param Star primary The primary star or, when generating a companion, the companion's host star
	 * @param array entry An entry from the #checkForSecondaryObjects result
	 * @param bool companion True if generating a companion
	 */
	genSecondaryStarMethod(primary, entry, companion = false)
	{
		// Brown Dwarf primary (or companion host) may only have a Sibling result
		if (primary.type === BROWN_DWARF) {
			return 'Sibling';
		}
		const chart = this.genNonPrimaryStarTable(primary, entry);
		// DM-1 if primary star (or companion host) is Class III or IV
		const dm = (primary.classification === 3 || primary.classification === 4 ? -1 : 0);
		const label = (companion ? 'Companion' : 'Secondary');
		const result = clamp(this.roll(2, 6, dm, label + ' Non-Primary Star Determination'), 2, 12);
		if (chart[result] === 'Other') {
			const other = this.roll(2, 6, 0, label + ' Non-Primary Star Determination: Other');
			return (other > 7 ? 'BD' : 'D');
		} else {
			return chart[result];
		}
	}

	genNonPrimaryStarTable(primary, entry)
	{
		// White Dwarf, Neutron Star, Pulsar, and Black Hole primaries use the Post-Stellar chart
		if ([WHITE_DWARF, NEUTRON_STAR, PULSAR, BLACK_HOLE].includes(primary.type)) {
			return NON_PRIMARY_DEAD;
		}
		// Companions use the Companion chart
		if (entry['companion']) {
			return NON_PRIMARY_COMPANION;
		}
		// Everything else uses the Secondary chart, but may have special cases handled elsewhere
		return NON_PRIMARY_SECONDARY;
	}

	/**
	 * @param StarSystem system A newly created star system with all of the star-data already determined
	 * @param array planets See StarSystemFactory::generate, #planet_profiles
	 * @param WorldProfile|null world_profile Optional main world profile
	 *
	 * @return StarSystem with the number of each type of world determined
	 */
	genWorldCounts(system, planets = [], world_profile = null)
	{
		// Special Case: A Main World that is a Planetoid Belt adds 1 to the belt count
		const bonus_belt = (world_profile && world_profile.type === PLANET_BELT ? 1 : 0);
		const primary = system.getPrimaryStar();
		const n_planets = planets.reduce((n, value, index) => n + (index < 3 && value !== null ? value : 0));
		// Special Case: Dead star systems (i.e. those with a post-stellar primary) may not have any planets at all
		if (n_planets + bonus_belt < 1 && primary.isPostStellar()) {
			let dm = 0;
			// DM-2 if multiple post-stellar objects
			dm -= (system.stars.reduce((n, star) => n + (star.isPostStellar() ? 1 : 0), 0) > 1 ? 2 : 0);
			// DM-2 if a Neutron Star (including Pulsars etc.) is present
			dm -= (system.stars.reduce((n, star) => n + (star.type === NEUTRON_STAR || star.type === PULSAR ? 1 : 0), 0) > 0 ? 2 : 0);
			// DM-4 if a Black Hole is present
			dm -= (system.stars.reduce((n, star) => n + (star.type === BLACK_HOLE ? 1 : 0), 0) > 0 ? 4 : 0);
			let roll = this.roll(2, 6, dm, 'World Presence: Dead Star System');
			// No planets on any roll of 7- that was not a natural 12
			if (roll < 8 && (roll - dm) !== 12) {
				log('No planets detected in dead star system');
				return system;
			}
		}
		system.n_planet_gas = (planets.length > 0 && planets[0] !== null ? planets[0] : this.genGasGiantCount(system));
		if (system.n_planet_gas < 1 && world_profile && world_profile.host === PLANET_GAS) {
			system.n_planet_gas = 1;
			log('Continuation Method: Main World requires at least 1 Gas Giant');
		}
		system.n_planet_belt = (planets.length > 1 && planets[1] !== null ? planets[1] : this.getPlanetoidBeltCount(system));
		if (bonus_belt > 0) {
			system.n_planet_belt += bonus_belt;
			log('Continuation Method: Main World requires an additional Planetoid Belt');
		}
		system.n_planet_rock = (planets.length > 2 && planets[2] !== null ? planets[2] : this.genTerrestrialPlanetCount(system));
		system.n_planets = system.n_planet_gas + system.n_planet_belt + system.n_planet_rock;
		return system;
	}

	genGasGiantCount(system)
	{
		const primary = system.getPrimaryStar();
		// Gas Giant(s) are absent if 2D > 9
		let absent_over = 9;
		// Special Case: Brown Dwarf systems have none on 8+
		if (primary.isPostStellar()) {
			absent_over = 7;
		}
		// Special Case: Dead star systems have none on 6+
		if (primary.isPostStellar()) {
			absent_over = 5;
		}
		if (this.roll(2, 6, 0, 'World Presence: Gas Giants') > absent_over) {
			return 0;
		}
		let dm = 0;
		// DM+1 System consists of a single Class V star
		if (system.n_stars === 1 && primary.classification === 5) dm += 1;
		// DM-2 Primary star is a brown dwarf
		if (primary.type === BROWN_DWARF) dm -= 2;
		// DM-2 Primary star is a poststellar object
		if (primary.isPostStellar()) dm -= 2;
		// DM-1 per post-stellar object (including primary star)
		dm -= system.stars.reduce((n, star) => n + (star.isPostStellar() ? 1 : 0), 0);
		// DM-1 System consists of four or more stars
		if (system.n_stellar > 4) dm -= 1;
		let roll = this.roll(2, 6, dm, 'World Count: Gas Giants');
		return PLANET_QTY_GAS[clamp(roll, 4, 13)];
	}

	getPlanetoidBeltCount(system)
	{
		const primary = system.getPrimaryStar();
		// Planetoid Belt(s) are absent if 2D < 8
		let absent_under = 8;
		// Special Case: Dead star systems have none under 6
		if (primary.isPostStellar()) {
			absent_under = 6;
		}
		if (this.roll(2, 6, 0, 'World Presence: Planetoid Belts') < absent_under) {
			return 0;
		}
		let dm = 0;
		// DM+1 System has 1 or more gas giants
		if (system.n_planet_gas > 0) dm += 1;
		// DM+3 Primary star is a protostar
		if (primary.type === PROTOSTAR) dm += 3;
		// DM+2 (p37, or DM+4 per p225) Primary star is primordial (i.e. system is < 100 million years old [0.1 Gyrs] but beyond its protostar stage)
		if (primary.type !== PROTOSTAR && system.age < 0.1) dm += 2;
		// DM+1 Primary star is a poststellar object
		if (primary.isPostStellar()) dm += 1;
		// DM+1 Per post-stellar object (including primary star)
		dm += system.stars.reduce((n, star) => n + (star.isPostStellar() ? 1 : 0), 0);
		// DM+1 System consists of two or more stars
		if (system.n_stellar > 1) dm += 1;
		let roll = this.roll(2, 6, dm, 'World Count: Planetoid Belts');
		return (roll < 7 ? 1 : (roll > 11 ? 3 : 2));
	}

	genTerrestrialPlanetCount(system)
	{
		const primary = system.getPrimaryStar();
		// All systems have some quantity of terrestrial planets
		let dm = -2;
		// DM-1 Per post-stellar object (including primary star)
		dm -= system.stars.reduce((n, star) => n + (star.isPostStellar() ? 1 : 0), 0);
		let n = 2;
		// Special Case: Dead star systems roll only 1D instead of 2D
		if (primary.isPostStellar()) {
			n = 1;
		}
		let roll = this.roll(n, 6, dm, 'World Count: Terrestrial Planets');
		// If the resultant terrestrial planets are less than 3, reroll as D3+2
		if (roll < 3) {
			roll = this.roll(1, 3, 2, 'World Count: Terrestrial Planets - Reroll');
		}
		// If the resultant terrestrial planets are 3 or more, add another D3-1
		if (roll > 2) {
			roll += this.roll(1, 3, -1, 'World Count: Terrestrial Planets - Additional');
		}
		return roll;
	}

	determineTotalSystemOrbits(system)
	{
		let n_orbits = 0;
		// Any group with the Primary star included adds its orbit slots to the Primary star instead
		const p_orbits = system.star_groups.reduce((n, group) => (group.isPrimaryComponent() ? n + group.getTotalAllowedOrbits() : n), 0);
		if (p_orbits > 0) {
			const p_group = system.getPrimaryStarComponent();
			p_group.orbit_slots = Math.floor(p_orbits + p_group.getAllowedOrbitMod());
			n_orbits += p_group.orbit_slots;
		}
		// All others determine their allowed number of orbital slots normally
		system.star_groups.filter(group => !group.isPrimaryComponent()).forEach(group => {
			const orbits = group.getTotalAllowedOrbits();
			const mod = (orbits > 0 ? group.getAllowedOrbitMod() : 0);
			group.orbit_slots = Math.floor(orbits + mod);
			n_orbits += group.orbit_slots;
		});
		return n_orbits;
	}

	determineOrbitsPerStar(system)
	{
		let assigned_bodies = 0;
		system.star_groups.forEach(group => {
			const n_bodies = system.n_planets * group.orbit_slots / system.n_orbits;
			// The primary star (or its group, which at this point contains all bodies allocated to any primary group) rounds the number of bodies up; others all round down
			group.n_bodies = (group.isPrimaryComponent() ? Math.ceil(n_bodies) : Math.floor(n_bodies));
			log('Assigned ' + group.n_bodies + ' planetary bodies to ' + group.getDesignation(system.n_stellar));
			assigned_bodies += group.n_bodies;
		});
		const r_bodies = (system.n_planets - assigned_bodies);
		if (r_bodies > 0) {
			const last = system.star_groups.findLast(group => group.orbit_slots > 0);
			last.n_bodies += r_bodies;
			log('Assigned remaining ' + r_bodies + ' planetary bodies to furthest star or companion pair: ' + last.getDesignation(system.n_stellar));
		}
	}

	/**
	 * @param StarSystem system
	 * @param Star|StarGroup group Either the system's primary star component, or a secondary or companion star that may have independent orbits
	 * @param bool secondary True if determining the baseline for a secondary or companion star
	 */
	determineBaselineNumber(system, group, secondary = false)
	{
		const label = (secondary ? 'Secondary' : 'System');
		const p_group = (secondary ? group : system.getPrimaryStarComponent());
		if (!p_group.isHzcoValid()) {
			// Special Case: Invalid HZCO and no allowed orbits - baseline is 0
			if (p_group.orbit_slots < 1) return 0;
			// Special Case: Invalid HZCO and some allocated orbits - place a random number of worlds around the star and use that number +1 (or more) as the baseline
			const p_worlds = Math.ceil((p_group.n_bodies / 10) * this.roll(2, 6, -2, label + ' Baseline Number: invalid HZCO, rolling a random planet # to use as the baseline'));
			return p_worlds + 1;
		}
		const primary = (secondary ? (group instanceof StarGroup ? group.bodies[0] : group) : system.getPrimaryStar());
		const dm = this.getBaselineNumberMod(system, primary);
		const n_planets = (this.per_star_baseline && secondary ? group.n_bodies : system.n_planets);
		const dm_planet = this.getBaselineNumberWorldCountMod(n_planets);
		return this.roll(2, 6, dm + dm_planet, label + ' Baseline Number: valid HZCO, rolling for baseline');
	}

	getBaselineNumberMod(system, primary)
	{
		let dm = 0;
		// DM-2 if Primary star has or is itself a companion
		if (primary.companion || primary.host) dm -= 2;
		// DM+3 if Primary star is Class Ia, Ib, or II
		if (primary.type <= MAIN_TYPE_M && primary.classification < 3) dm += 3;
		// DM+2 if Primary star is Class III
		if (primary.type <= MAIN_TYPE_M && primary.classification === 3) dm += 2;
		// DM+1 if Primary star is Class IV
		if (primary.type <= MAIN_TYPE_M && primary.classification === 4) dm += 1;
		// DM-1 if Primary star is Class VI
		if (primary.type <= MAIN_TYPE_M && primary.classification === 6) dm -= 1;
		// DM-2 if Primary star is a post-stellar object
		if (primary.isPostStellar()) dm -= 2;
		// DM-1 for each secondary star (excluding companions)
		dm -= (system.stars.length - 1);
		return dm;
	}

	getBaselineNumberWorldCountMod(n_worlds)
	{
		if (n_worlds < 6) return -4;
		if (n_worlds < 10) return -3;
		if (n_worlds < 13) return -2;
		if (n_worlds < 16) return -1;
		if (n_worlds < 18) return 0;
		if (n_worlds < 21) return 1;
		return 2;
	}

	/**
	 * @param StarSystem system
	 * @param Star|StarGroup group Either the first primary star component with allowable orbits, or a secondary or companion star that may have independent orbits
	 * @param float baseline_number Either from the system or the secondary group
	 * @param int n_bodies The number of bodies (excluding empty orbits) around the group or, when determining it for the entire system, the first primary star component
	 * @param bool secondary True if determining the baseline orbit# for a secondary or companion star
	 */
	determineBaselineOrbit(system, group, baseline_number, n_bodies, secondary = false)
	{
		const label = (secondary ? 'Secondary' : 'System');
		const n_planets = (this.per_star_baseline && secondary ? n_bodies : system.n_planets);
		const orbit_min = group.getMinimumAllowableOrbit();
		const orbit_max = group.getMaximumAllowableOrbit();
		const hzco = group.getHzco();
		const eff_hzco  = clamp(hzco, orbit_min, orbit_max);
		log('Determining ' + label + ' Baseline Orbit# from Baseline Number: ' + baseline_number + ', HZCO: ' + hzco + ', Min Orbit: ' + orbit_min + ', Max Orbit: ' + orbit_max);
		if (baseline_number < 1.0) {
			const roll_b = this.roll(2, 6, -2, label + ' Baseline Orbit: Method B');
			if (orbit_min < 1.0) {
				const mod_b = (Math.abs(baseline_number) / 10) + (roll_b / 100);
				if (hzco >= orbit_max) {
					log(label + ' Baseline Orbit# determined by Method B, MAO < 1 and HZCO >= Max Orbit, returning Max ' + orbit_max + ' - ' + mod_b);
					return clamp(orbit_max - mod_b, orbit_min, orbit_max);
				}
				log(label + ' Baseline Orbit# determined by Method B, MAO < 1 and HZCO < Max Orbit, returning effective HZCO ' + eff_hzco + ' + ' + mod_b);
				return clamp(eff_hzco + mod_b, orbit_min, orbit_max);
			}
			const result_b = eff_hzco - baseline_number + n_planets + (roll_b / 10);
			if (result_b > 20.0) {
				log(label + ' Baseline Orbit# determined by Method B, MAO >= 1 and ' + result_b + ' exceeds 20; reducing to 20 - ' + (roll_b / 10));
				return 20.0 - (roll_b / 10);
			}
			log(label + ' Baseline Orbit# determined by Method B, MAO >= 1; returning valid result: ' + result_b);
			return clamp(result_b, orbit_min, orbit_max);
		} else if (baseline_number > n_planets) {
			const roll_c = this.roll(2, 6, -7, label + ' Baseline Orbit: Method C');
			const method_c = baseline_number + n_planets;
			if (eff_hzco - method_c >= 1.0) {
				log(label + ' Baseline Orbit# determined by Method C, total >= 1.0');
				return clamp(eff_hzco - method_c + (roll_c / 5), orbit_min, orbit_max);
			}
			const result_c = eff_hzco - ((method_c + (roll_c / 5)) / 10);
			if (result_c < 0) {
				// Note that this calculation uses the group's total worlds, not the system's
				log(label + ' Baseline Orbit# determined by Method C, total < 1.0 and subsequent result < 0');
				return clamp(Math.max(eff_hzco - 0.1, orbit_min + (0.1 * n_bodies)), orbit_min, orbit_max);
			}
			log(label + ' Baseline Orbit# determined by Method C, total < 1.0 and subsequent result >= 0');
			return clamp(result_c, orbit_min, orbit_max);
		}
		const roll_a = this.roll(2, 6, -7, label + ' Baseline Orbit: Method A');
		const mod_a = (roll_a / (eff_hzco < 1.0 ? 100 : 10));
		if (hzco >= orbit_max) {
			log(label + ' Baseline Orbit# determined by Method A, HZCO >= Max Orbit, returning Max ' + orbit_max + ' - ' + Math.abs(mod_a));
			return clamp(orbit_max - Math.abs(mod_a), orbit_min, orbit_max);
		}
		log(label + ' Baseline Orbit# determined by Method A, HZCO < Max Orbit, returning effective HZCO ' + eff_hzco + (mod_a < 0 && eff_hzco + mod_a >= orbit_min ? ' - ' : ' + ') + Math.abs(mod_a));
		const result_a = (eff_hzco + mod_a < orbit_min ? eff_hzco - mod_a : eff_hzco + mod_a);
		return clamp(result_a, orbit_min, orbit_max);
	}

	determineEmptyOrbits(system)
	{
		if (this.per_star_empty_orbits) {
			system.star_groups.forEach(group => {
				if (group.n_bodies > 0) {
					group.n_empty = Math.max(0, this.roll(2, 6, -9, 'Empty Orbits: Star ' + group.getDesignation(system.n_stellar)));
					system.n_empty += group.n_empty;
				}
			});
		} else {
			system.n_empty = Math.max(0, this.roll(2, 6, -9, 'Empty Orbits: Entire System'));
			let empty = system.n_empty;
			let i = 0;
			// Allocate first to Close, Near, and Far star(s), then finally Primary star(s)
			while (empty > 0 && i < 3) {
				empty = this.allocateEmptyOrbits(system, empty, (group) => group.orbit_band > 0);
				empty = this.allocateEmptyOrbits(system, empty, (group) => group.orbit_band < 1);
				i++;
			}
		}
	}

	allocateEmptyOrbits(system, empty, callback)
	{
		system.star_groups.forEach(group => {
			if (empty > 0 && group.n_bodies > 0 && callback(group)) {
				log('Allocating +1 empty orbit around ' + group.getDesignation(system.n_stellar));
				group.n_empty++;
				empty--;
			}
		});
		return empty;
	}

	determineSystemSpread(system, active_group = null)
	{
		return this.determineSecondarySpread(system.baseline_number, system.baseline_orbit, active_group);
	}

	determineSystemSpreadMax(system)
	{
		const p_group = system.getPrimaryStarComponent();
		return (p_group.orbit_slots / (p_group.n_bodies + p_group.n_empty + system.n_stellar));
	}

	determineSecondarySpread(baseline_number, baseline_orbit, group = null)
	{
		const mao = (group ? group.getMinimumAllowableOrbit() : 0);
		return Math.max(0.01, (baseline_orbit - mao) / Math.max(1, baseline_number));
	}

	determineSecondarySpreadMax(system, star)
	{
		const total_orbits = star.getTotalAllowedOrbits();
		// The "number of worlds" refers to the star or pair in question
		if ((total_orbits / star.n_bodies) > system.orbit_spread) {
			return round(total_orbits / (1 + star.n_bodies + star.n_empty), 3);
		}
		return 0;
	}

	/**
	 * @return bool True if all of the star's bodies were allocated a valid Orbit#
	 */
	determineOrbitNumbers(star, spread, p_groups = [], world_profile = null)
	{
		const n_bodies = star.n_bodies + star.n_empty;
		const main_max = (world_profile && world_profile.star_group ? world_profile.star_group.getHzcoPlus(world_profile.hzco_delta + (spread / 2)) : 0);
		const main_min = (world_profile && world_profile.star_group ? world_profile.star_group.getHzcoPlus(world_profile.hzco_delta - (spread / 2)) : 0);
		let allocated = 0;
		let orbit = star.getMinimumAllowableOrbit();
		let p_index = 1;
		log('Attempting to place ' + n_bodies + ' Orbit#s around star/group ' + star.getDesignation() + '; Cumulative Variance? ' + (this.cumulative_orbit ? 'Y' : 'N'));
		for (let n = 0; n < n_bodies; n++) {
			const mao = (this.cumulative_orbit ? orbit : star.getMinimumAllowableOrbit() + (star.bodies.length * spread));
			const orbit_var = 0.1 * spread * this.roll(2, 6, -7, 'Placing Orbits for ' + star.getDesignation() + ': Variance');
			orbit = mao + spread + orbit_var;
			// Special Case: Primary Star group(s) move to next furthest primary star group if orbit is outside of the current group's maximum allowable orbit
			while (p_index < p_groups.length && orbit > star.getMaximumAllowableOrbit()) {
				log('Placing Orbits for ' + star.getDesignation() + ': Orbit# ' + orbit.toFixed(3) + ' exceeds maximum allowed by ' + star.getDesignation() + '; proceeding to next group, if any');
				star = p_groups[p_index++];
				orbit = star.getMinimumAllowableOrbit() + spread + orbit_var;
			}
			// Continuation Method: If final orbit slot is reached without placing Main World, place it in the final slot using its predetermined Orbit#
			if (world_profile && world_profile.star_group === star && world_profile.orbit_index < 0 && orbit < main_min && n + 1 === n_bodies) {
				log('Continuation Method: Placing the final body for ' + star.getDesignation() + '; Orbit# ' + orbit.toFixed(3) + ' is still lower than Main World Orbit# ' + world_profile.star_group.getHzcoPlus(world_profile.hzco_delta) + '; using the latter as the final Orbit#');
				orbit = world_profile.star_group.getHzcoPlus(world_profile.hzco_delta);
			}
			// If orbit exceeds max allowed on the final orbit, make an attempt to get it back within acceptable bounds
			const star_max = star.getMaximumAllowableOrbit();
			if (orbit > star_max && n + 1 === n_bodies) {
				log('Final Orbit# ' + orbit.toFixed(3) + ' around ' + star.getDesignation() + ' out of bounds; attempting to lower it to below Max Orbit# ' + star_max.toFixed(3));
				orbit = star_max - Math.abs(orbit_var);
				if (orbit <= star_max && orbit > (mao + spread / 2)) {
					log('Success! Orbit# changed to ' + orbit.toFixed(3));
				}
			}
			if (orbit > star_max) {
				log('Placing Orbits for ' + star.getDesignation() + ': ran out of allowable orbit slots at n=' + n + ' and Orbit# ' + orbit);
				// Continuation Method: Ensure Main World with predetermined orbit was allocated an Orbit# around its star if it missed earlier
				if (world_profile && world_profile.star_group === star && world_profile.orbit_index < 0) {
					world_profile.star_group = star;
					world_profile.orbit_index = star.bodies.length - 1;
					log('Continuation Method: Failed to place Main World Orbit for ' + star.getDesignation() + ' before exceeding Max Orbit#; placing at Orbit# ' + star.bodies[star.bodies.length - 1].toFixed(3) + ' in final Slot #' + world_profile.orbit_index);
				}
			} else {
				log('Valid orbit for ' + star.getDesignation() + ' at ' + orbit.toFixed(3) + ' (Min: ' + mao.toFixed(3) + ', Spread: ' + spread.toFixed(3) + ', Variance: ' + orbit_var.toFixed(3) + ')');
				// Continuation Method: Main World with predetermined orbit should be placed in first qualifying slot
				if (world_profile && world_profile.star_group === star && world_profile.orbit_index < 0) {
					let flag = (main_min < orbit && orbit < main_max);
					// If the current Orbit# passes beyond the Main World's maximum orbit, place the world in the last orbit slot using its predetermined Orbit#
					if (!flag && orbit > main_max) {
						log('Continuation Method: Orbit# ' + orbit.toFixed(3) + ' has passed beyond Main World maximum ' + main_max.toFixed(3));
						const last_orbit = (star.bodies.length > 0 ? star.bodies[star.bodies.length - 1] : null);
						const main_orbit = world_profile.star_group.getHzcoPlus(world_profile.hzco_delta);
						if (last_orbit === null) {
							// No prior orbits, use predetermined main Orbit# as is
							orbit = main_orbit;
							flag = true;
							log('Continuation Method: No prior bodies; using the Main World predetermined Orbit# as is');
						} else if (last_orbit < main_orbit) {
							// If last orbit is less than the predetermined main Orbit#, use the main as is and adjust the last orbit if it is too close
							orbit = main_orbit;
							flag = true;
							log('Continuation Method: Previous Orbit# ' + last_orbit.toFixed(3) + ' is less than Main World predetermined Orbit#; use the latter as is');
							if (1.1 * last_orbit > main_orbit) {
								star.bodies[star.bodies.length - 1] = last_orbit / 1.1;
								log('Continuation Method: Adjusted too-close prior Orbit# ' + last_orbit.toFixed(3) + ' to ' + star.bodies[star.bodies.length - 1].toFixed(3));
							}
						} else {
							// If last orbit is greater than the predetermined main Orbit#, set the last orbit to the main_orbit and recalculate the current orbit
							world_profile.star_group = star;
							world_profile.orbit_index = star.bodies.length - 1;
							star.bodies[star.bodies.length - 1] = main_orbit;
							orbit = main_orbit + spread + orbit_var;
							log('Continuation Method: Previous Orbit# ' + last_orbit.toFixed(3) + ' exceeds Main World predetermined Orbit#; placing Main World and its Orbit# in previous slot and setting current Orbit# to ' + orbit.toFixed(3));
						}
					}
					if (flag) {
						world_profile.star_group = star;
						world_profile.orbit_index = star.bodies.length;
						log('Continuation Method: Successfully placed Main World Orbit for ' + star.getDesignation() + ' at Orbit# ' + orbit.toFixed(3) + ' in Slot #' + world_profile.orbit_index);
					}
				}
				star.bodies.push(orbit);
				allocated++;
			}
		}
		log('World Orbit#s for ' + star.getDesignation());
		log(star.bodies);
		return allocated === n_bodies;
	}

	determineMainWorldStarGroup(system, world_profile)
	{
		world_profile.hzco_delta = world_profile.getHzcoDeviation();
		log('Continuation Method, Step 3D: Searching for suitable Baseline Orbit# for main world with HZCO Deviation of ' + signed(world_profile.hzco_delta));
		return system.star_groups.find(group => {
			if (group.n_bodies > 0 && group.isHzcoValid()) {
				const main = group.getHzcoPlus(world_profile.hzco_delta);
				return null !== group.bodies.find(orbit => {
					const max = getOrbitPlus(orbit, 1);
					const min = getOrbitPlus(orbit, -1);
					return (min < main && main < max);
				});
			}
			return false;
		});
	}
	
	determineMainWorldBaselineOrbit(group, world_profile)
	{
		const hzco_star = group.getHzco();
		const hzco_main = group.getHzcoPlus(world_profile.hzco_delta);
		if (hzco_star > 1 && hzco_main > 1) {
			return hzco_main;
		} else if (world_profile.hzco_delta > 0) {
			return hzco_star * (1 + world_profile.hzco_delta);
		} else {
			return hzco_star / (1 - world_profile.hzco_delta);
		}
	}

	recalculatePrimaryBodyCounts(primary, p_groups)
	{
		const n_bodies = primary.n_bodies;
		const n_empty = primary.n_empty;
		// Recalculate n_bodies and n_empty for each primary group
		let empty = n_empty;
		p_groups.forEach(group => {
			group.n_empty = Math.floor(n_empty * group.bodies.length / n_bodies);
			group.n_bodies = group.bodies.length - group.n_empty;
			empty -= group.n_empty;
		});
		// Allocate any remaining empty orbits working from the furthest star inwards
		let i = 3; // fail-safe
		while (empty > 0 && i > 0) {
			p_groups.reverse().forEach(group => {
				if (empty > 0 && group.n_bodies > 1) {
					group.n_empty++;
					group.n_bodies--;
					empty--;
				}
			});
			i--;
		}
		if (empty > 0) {
			log('Failed to place all empty orbits for Primary Star Group(s): ' + empty + ' remaining');
		}
	}

	genAnomalousPlanets(system, n_anomalous)
	{
		const group_indexes = system.star_groups
			.map((group, index) => (group.getTotalAllowedOrbits() > 0 ? index : null))
			.filter((v) => v !== null);
		if (group_indexes.length < 1) {
			log('Failed to place Anomalous Planets - no stars or star groups contained any Allowable Orbits');
			return;
		}
		log('Anomalous Planets: Attempting to place ' + n_anomalous + ' planets around ' + group_indexes.length + ' possible star(s) and/or star group(s)');
		for (let i = 0; i < n_anomalous; i++) {
			const j = this.roll(1, group_indexes.length, -1, 'Anomalous Planet: Star / Group Index');
			this.flushHistory(system);
			const index = group_indexes[j];
			const group = system.star_groups[index];
			const roll = this.roll(2, 6, 0, 'Anomalous Planet Type');
			const data = this.genAnomalousPlanetData(group, roll);
			const group_spread = (this.per_star_baseline ? group.getMinimumOrbitSpread() : 0);
			const spread = (group_spread > 0 ? group_spread : system.getMinimumOrbitSpread());
			const orbit = this.genAnomalousPlanetOrbitNumber(group, spread, data.orbit_is_trojan);
			group.addAnomalousPlanetData(orbit, data);
			this.incrementAnomalousPlanetCount(system, group);
			this.flushHistory(group);
		}
	}

	genAnomalousPlanetOrbitNumber(group, spread, trojan = false)
	{
		if (trojan && group.bodies.length > 0) {
			const index = this.roll(1, group.bodies.length, -1, 'Anomalous Planet: Trojan Orbit#');
			return group.bodies[index];
		}
		const max = group.getMaximumAllowableOrbit();
		const min = group.getMinimumAllowableOrbit();
		const diff = max - min;
		const roll = 0.01 * this.roll(1, 100, 0, 'Anomalous Planet: Random Orbit#');
		return min + (roll * diff);
	}

	genAnomalousPlanetData(group, roll)
	{
		// Trojans do not roll for eccentricity so don't worry about their DM
		const eccentricity_dm = (roll === 8 ? 5 : 2);
		const inclination = (roll === 9 ? this.genAnomalousPlanetInclination() : 0);
		const retrograde = (roll > 9 && roll < 12);
		// Special Case: If a trojan is rolled as the first planet around a host star, treat it as Random instead
		const trojan = (roll > 11 && group.bodies.length > 0);
		return new AnomalousPlanetData(eccentricity_dm, inclination, retrograde, trojan);
	}

	genAnomalousPlanetInclination()
	{
		return (10 * this.roll(1, 6, 2, 'Anomalous Orbit: Inclination')) + this.roll(1, 10, 0, 'Anomalous Orbit: Inclination');
	}

	incrementAnomalousPlanetCount(system, group)
	{
		if (system.n_planet_rock < 13) {
			log('Anomalous Planet adding +1 Terrestrial to ' + group.getDesignation(system.n_stellar));
			system.n_planet_rock++;
		} else {
			log('Anomalous Planet adding +1 Planetoid Belt to ' + group.getDesignation(system.n_stellar));
			system.n_planet_belt++;
		}
		system.n_planets++;
		group.n_bodies++;
	}

	placeWorlds(system, world_profile = null)
	{
		// Special Case: Young Protostar systems (i.e. < 0.002 Gyr old) have special rules for world generation
		const primary = system.getPrimaryStar();
		const is_young_protostar = (primary.type === PROTOSTAR && system.age < 0.002);
		const proto_cap = (primary.type === PROTOSTAR ? round(system.age * 1000, 0) : 0);
		const worlds = this.getWorldsForPlacement(system, world_profile);
		this.determineWorldTypes(system, worlds, world_profile);
		this.flushHistory(system);
		// Clear the temporary data out of the bodies array for each star and group
		system.star_groups.forEach(group => group.bodies = []);
		// Create the actual World objects for each star/group
		let b_index = 1;
		let p_index = 0;
		let trojans = 0;
		let host = null;
		worlds.forEach(entry => {
			if (host === null || host.getDesignation(system.n_stellar) !== system.star_groups[entry.group_index].getDesignation(system.n_stellar)) {
				host = system.star_groups[entry.group_index];
				b_index = 1;
				p_index = 0;
				trojans = 0;
			}
			if (entry.type === PLANET_EMPTY) {
				trojans = 0;
			} else if (entry.type === PLANET_BELT) {
				const belt = new PlanetoidBelt(host, entry.orbit, b_index++);
				entry.apply(belt, world_profile);
				host.bodies.push(belt);
				trojans = 0;
			} else {
				// Special Case: Trojans increment the Lagrange index while within the same orbit, rather than the p_index
				if (entry.orbit_is_trojan) {
					trojans++;
					// If the trojan is in a Planetoid Belt or the first planet in around a star, still need to increase p_index
					if (host.bodies.length < 1 || host.bodies[host.bodies.length - 1].type === PLANET_BELT) {
						p_index++;
					}
				} else {
					p_index++;
					trojans = 0;
				}
				const world = new World(host, entry.orbit, p_index, entry.type);
				entry.apply(world, world_profile);
				world.size = this.world_factory.genSize(system, world);
				world.orbit_lagrange = trojans;
				// Special Case: Protostar systems cap the size of terrestrial planets and moons at 1 per million years
				let proto_adds = [];
				const proto_diff = (world.size - proto_cap);
				if (primary.type === PROTOSTAR && proto_diff > 0 && (world.type === PLANET_ROCK || world.type === PLANET_MOON)) {
					world.size = proto_cap;
					for (let i = 0; i < proto_diff; i++) {
						// Add up to +/- 10% orbital variance
						const orbit_var = 0.02 * entry.orbit * this.roll(2, 6, -7, 'Protostar Planetary Chunk: Additional orbit variance');
						// Use the same planet index
						const proto_add = new World(host, entry.orbit + orbit_var, p_index, entry.type);
						// Chunks < Size 0 become Size 0 to make lots of little asteroids
						proto_add.size = Math.max(0, proto_cap - this.roll(1, 6, -1, 'Protostar Planetary Chunk: Size reduction'));
						proto_adds.push(proto_add);
					}
				}
				// Add all rolls (including for any Protostar additions) to main world history
				this.world_factory.flushHistory(world);
				this.flushHistory(world);
				// Special Case: Young Protostar systems (i.e. < 0.002 Gyr old) may have reduced a world's size below 0, indicating it should not be added
				if (!is_young_protostar || world.size > -1) {
					host.bodies.push(world);
				} else if (!entry.orbit_is_trojan) {
					p_index--; // planet not added; reduce planet index by 1
				}
				// Special Case: Young Protostar systems (i.e. < 0.002 Gyr old) add a belt in every slot with a gas giant or terrestrial planet, even if that planet was removed
				if (is_young_protostar && (world.type === PLANET_GAS || world.type === PLANET_ROCK)) {
					log('Protostar System < 0.002 Gyr in age: adding a Planetoid Belt in same orbit as ' + world.getDesignation(system.n_stellar));
					host.bodies.push(new PlanetoidBelt(host, entry.orbit, b_index++));
				}
				// Protostars add any extra terrestrial chunks
				host.bodies.push(...proto_adds);
			}
		});
	}

	getWorldsForPlacement(system, world_profile = null)
	{
		let worlds = [];
		for (let i = 0; i < system.star_groups.length; i++) {
			const group = system.star_groups[i];
			const n_bodies = group.n_bodies + group.n_empty;
			for (let j = 0; j < n_bodies; j++) {
				const placeholder = new WorldPlaceHolder(i, group.bodies[j], group.getAnomalousPlanetDataAt(j));
				worlds.push(placeholder);
				// Special Case: Trojans must prevent an EMPTY orbit from being placed in the parent slot
				if (placeholder.orbit_parent_index !== null) {
					const parent_index = placeholder.orbit_parent_index + worlds.length - j;
					worlds[parent_index].allow_empty = false;
					log('Anomalous Planet: Trojan will prevent empty orbits from being placed in parent orbit index ' + parent_index);
				}
			}
			// Continuation Method: Place Main World with predetermined orbit
			if (world_profile && world_profile.star_group === group) {
				const main_index = world_profile.orbit_index + worlds.length - n_bodies;
				const type = world_profile.getMainPlanetType(system);
				worlds[main_index].type = type;
				worlds[main_index].main = true;
				log('Continuation Method: Main World placed at predetermined world index ' + main_index + ' with initial world type of ' + (new World(null, 0, 1, type)).getTypeName());
				// Set the appropriate count when a Gas Giant or Belt is placed so star does not generate an extra one
				if (type === PLANET_GAS) {
					world_profile.n_planet_gas = 1;
				}
				if (type === PLANET_BELT) {
					world_profile.n_planet_belt = 1;
				}
			}
			// If empty orbits are per-star rather than system-wide, allocate them now
			if (this.per_star_empty_orbits) {
				for (let k = 0; k < group.n_empty; k++) {
					let index = this.roll(1, n_bodies, -1, 'World Placement: Empty Orbit for ' + group.getDesignation(system.n_stellar));
					// Ensure empty orbit placed in an undetermined slot
					while (!worlds[worlds.length - n_bodies + index].canPlaceEmpty()) {
						index = (index + 1 === n_bodies ? 0 : index + 1);
					}
					worlds[worlds.length - n_bodies + index].type = PLANET_EMPTY;
				}
			}
		};
		return worlds;
	}

	determineWorldTypes(system, worlds, world_profile = null)
	{
		// Continuation Method: Main World without predetermined orbit can be placed anywhere
		const main_type = (world_profile && world_profile.star_group === null ? world_profile.getMainPlanetType(system) : null);
		const map = {
			[PLANET_EMPTY]: (this.per_star_empty_orbits ? 0 : system.n_empty),
			[PLANET_GAS]: system.n_planet_gas - (world_profile ? world_profile.n_planet_gas : 0),
			[PLANET_BELT]: system.n_planet_belt - (world_profile ? world_profile.n_planet_belt : 0),
			// Terrestrial planets fill all remaining slots once the others are allocated
		};
		for (const type in map) {
			for (let n = 0; n < map[type]; n++) {
				const label = (+type === PLANET_EMPTY ? 'Empty Orbit' : (+type === PLANET_GAS ? 'Gas Giant' : 'Planetoid Belt'));
				let i = this.roll(1, worlds.length, -1, 'World Placement: ' + label);
				// Find next available slot if already occupied
				while (!worlds[i].canPlaceType(+type)) {
					i++;
					if (i === worlds.length) i = 0;
				}
				worlds[i].type = +type;
				if (main_type === +type && world_profile.orbit_index < 0) {
					worlds[i].main = true;
					world_profile.orbit_index = i;
					log('Continuation Method: Main World placed at random world index ' + i + ' with initial world type of ' + (new World(null, 0, 1, +type)).getTypeName());
				}
			}
		}
		// Fill the remaining slots with Terrestrial planets
		for (let j = 0; j < worlds.length; j++) {
			if (worlds[j].canPlaceType(PLANET_ROCK)) {
				worlds[j].type = PLANET_ROCK;
			}
		}
		// Continuation Method: Choose a random Terrestrial as the Main World if not yet determined
		if (world_profile && world_profile.orbit_index < 0) {
			let index = this.roll(1, worlds.length, -1, 'Continuation Method: Random Terrestrial for Main World');
			for (let x = index; x < worlds.length && world_profile.orbit_index < 0; x++) {
				if (worlds[x].type === PLANET_ROCK) {
					worlds[x].main = true;
					world_profile.orbit_index = x;
					log('Continuation Method: Main World placed at random Terrestrial world index ' + x);
				}
				// Wrap back around to beginning if none yet found
				if (x + 1 === worlds.length) {
					x = -1;
				}
			}
		}
	}
}

class WorldFactory extends AbstractFactory
{
	/**
	 * @param FormData options:
	 *   @option bool bio_all True to check all worlds for life rather than only the Main World and those within an HZ
	 *   @option bool basic_temp True to use the Basic Temperature formula to calculate Mean Temperature
	 *   @option bool flat_temp True to use 7+DMs when determining the initial temperature roll of worlds outside the HZ
	 *   @option bool hill_moon_qty True to use only the Hill Sphere when determining DM-1 per die for Significant Moon Qty
	 *   @option bool var_hr True to enable optional variation in world habitability rating (adds D3-2)
	 *   @option bool var_mass True to enable variations in world mass
	 *   @option bool var_orbit True to enable variations in moon orbit#s
	 *   @option bool var_size True to enable variations in world diameter
	 *   @option bool var_temp True to enable variations in world temperature
	 *   @option bool per_star_baseline True to calculate baseline number, baseline Orbit#, and system spread for each secondary and companion star separately
	 * @param AtmosphereFactory|null
	 */
	constructor(options, atmosphere_factory = null)
	{
		super();
		this.bio_all = options.has('bio_all');
		this.hill_moon_qty = options.has('hill_moon_qty');
		this.enable_basic_temp = options.has('basic_temp');
		this.enable_flat_temp = options.has('flat_temp');
		this.enable_var_habitability = options.has('var_hr');
		this.enable_var_mass = options.has('var_mass');
		this.enable_var_orbit = options.has('var_orbit');
		this.enable_var_size = options.has('var_size');
		this.enable_var_temp = options.has('var_temp');
		this.per_star_baseline = options.has('per_star_baseline');
		this.atmosphere_factory = (atmosphere_factory ? atmosphere_factory : new AtmosphereFactory(options));
	}

	generate()
	{
		// TODO
	}

	genAlbedo(world)
	{
		let albedo = this.genAlbedoBase(world);
		// Not all worlds will have a defined atmosphere, e.g. Gas Giants
		if (world.atmosphere) {
			// Atmosphere types 1-3 and E add 0.01 * (2D-3)
			if ([1, 2, 3, 14].includes(world.atmosphere.type)) albedo += 0.01 * this.roll(2, 6, -3, 'Albedo: Atmosphere (1-3,E) Modifier');
			// Atmosphere types 4-9 add 0.01 * 2D
			if (world.atmosphere.type > 3 && world.atmosphere.type < 10) albedo += 0.01 * this.roll(2, 6, 0, 'Albedo: Atmosphere (4-9) Modifier');
			// Atmosphere types A-C or F+ add 0.05 * (2D-2)
			if (world.atmosphere.type > 14 || [10, 11, 12].includes(world.atmosphere.type)) albedo += 0.05 * this.roll(2, 6, -2, 'Albedo: Atmosphere (A-C,F+) Modifier');
			// Atmosphere type D add 0.03 * 2D
			if (world.atmosphere.type === 13) albedo += 0.03 * this.roll(2, 6, 0, 'Albedo: Atmosphere (D) Modifier');
		}
		// Hydrographics 2-5 add 0.02 * (2D-2)
		if (world.hydrographics > 1 && world.hydrographics < 6) albedo += 0.02 * this.roll(2, 6, -2, 'Albedo: Hydrographics (2-5) Modifier');
		// Hydrographics 6+ add 0.03 * (2D-4)
		if (world.hydrographics > 5) albedo += 0.03 * this.roll(2, 6, -4, 'Albedo: Hydrographics (6+) Modifier');
		return clamp(albedo, 0.02, 0.98);
	}

	genAlbedoBase(world)
	{
		// Gas Giant: 0.05 * (2D+1)
		if (world.type === PLANET_GAS) return 0.05 * this.roll(2, 6, 1, 'Albedo: Gas Giant');
		// Rocky Terrestrial (i.e. Density > 0.5): 0.04 + 0.02 * (2D-2)
		if (world.density > 0.5) return 0.04 + (0.02 * this.roll(2, 6, -2, 'Albedo: Rocky Terrestrial'));
		// Icy Terrestrial (i.e. Density <= 0.5) up to HZCO+2: 0.2 + 0.05 * (2D-3)
		const orbit = world.getHzcoOrbit();
		if (orbit <= world.getHzcoPlus(2)) return 0.2 + (0.05 * this.roll(2, 6, -3, 'Albedo: Icy Terrestrial up to HZCO+2'));
		// Icy Terrestrial (i.e. Density <= 0.5) beyond HZCO+2: 0.25 + 0.07 * (2D-2)
		let albedo = 0.25 + (0.07 * this.roll(2, 6, -2, 'Albedo: Icy Terrestrial beyond HZCO+2'));
		if (albedo <= 0.4) {
			albedo -= 0.05 * this.roll(1, 6, -1, 'Albedo: Icy Terrestrial beyond HZCO+2, additional reduction')
		}
		return albedo;
	}

	genAxialTilt(world, n = 2)
	{
		const tilt = this.genAxialTiltBase(world, n);
		const min = (10 * this.roll(1, 6, -1, 'Axial Tilt: +Minutes')) + this.roll(1, 10, -1, 'Axial Tilt: +Minutes');
		const sec = (10 * this.roll(1, 6, -1, 'Axial Tilt: +Seconds')) + this.roll(1, 10, -1, 'Axial Tilt: +Seconds');
		return (tilt > 180 ? 180 - (tilt - 180) : tilt) + (min / 60) + (sec / 3600);
	}

	genAxialTiltBase(world, n = 2)
	{
		const first = this.roll(n, 6, 0, 'Axial Tilt Range');
		const roll = this.roll(1, 6, 0, 'Axial Tilt Value');
		if (first < 5) return (roll - 1) / 50;
		if (first < 6) return roll / 5;
		if (first < 7) return roll;
		if (first < 8) return 6 + roll;
		if (first < 10) return 5 + (roll * 5) + this.roll(1, 6, -1, 'Axial Tilt: +Degrees');
		const second = this.roll(1, 6, 0, 'Axial Tilt Range: Extreme');
		const bonus = this.roll(1, 10, -1, 'Axial Tilt: +Degrees');
		if (second < 3) return 10 + bonus + (roll * 10);
		if (second < 4) return 30 + bonus + (roll * 10);
		if (second < 5) return 90 + bonus + (roll * this.roll(1, 6, 0, 'Axial Tilt Value'));
		if (second < 6) return 180 + bonus - roll + this.roll(1, 6, 0, 'Axial Tilt Value');
		return 120 + bonus + (roll * 10);
	}

	getEccentricityMod(system, world)
	{
		let dm = world.orbit_eccentricity_dm;
		const primary = system.getPrimaryStar();
		// DM-1 For all Orbit#s below 1.0 if system is > 1 Gyr in age
		if (system.age > 1 && world.getTotalOrbit() < 1) dm--;
		// DM+1 For any significant body in an asteroid or planetoid belt, either any Gas Giant or Terrestrial planet in a Protostar system or when using the Continuation method
		if (primary.type === PROTOSTAR && (world.type === PLANET_GAS || world.type === PLANET_ROCK)) dm++;
		// DM+2 for planets in a Protostar system
		if (primary.type === PROTOSTAR) dm += 2;
		// DM+1 for planets in a Primordial system (any system < 0.1 Gyr and not a Protostar)
		if (system.age < 0.1 && primary.type !== PROTOSTAR) dm++;
		// DM+1 For each star an object directly orbits beyond the first, excluding this planet's own companion/host unless it is in a circumbinary orbit
		if (world.host.orbit_band > 0) {
			dm += system.stars.reduce((n, star) => n + (star.orbit_band < world.host.orbit_band ? (star.companion ? 2 : 1) : 0), 0);
		}
		// DM+1 for worlds in a circumbinary orbit since it was not accounted for above
		if (world.host instanceof StarGroupCompanion) dm++;
		return dm;
	}

	/**
	 * Depends on world.density and world.diameter
	 */
	genGravity(world)
	{
		return world.density * world.getTotalDiameter() / TERRA_DIAMETER;
	}

	/**
	 * Depends on both physical (e.g. mass, diameter) and orbital (e.g. orbit_au) characteristics
	 */
	genHillSphere(system, world)
	{
		// Only Gas Giants and Terrestrial planets support additional orbiting bodies
		if (world.type !== PLANET_GAS && world.type !== PLANET_ROCK) return 0;
		const mass_solar = world.getTotalMass() * TERRA_MASS_TO_SOL;
		const mass_stars = system.stars
			.filter(star => star.orbit_band < world.host.orbit_band)
			.reduce((n, star) => n + star.getTotalMass() + (star.companion ? star.companion.getTotalMass() : 0), world.host.getTotalMass());
		// Gas Giant diameters are in units of Terra, while others are already in km
		const diameter = (world.type === PLANET_GAS ? world.getTotalDiameter() * TERRA_DIAMETER : world.getTotalDiameter());
		const hill_sphere_au = world.orbit_au * (1 - world.orbit_eccentricity) * Math.cbrt(mass_solar / (3 * mass_stars));
		const hill_sphere_pd = hill_sphere_au * AU / diameter;
		log('Calculating Hill Sphere for ' + world.getDesignation(system.n_stellar) + '; Orbit AU = ' + format(world.orbit_au, 6) + ', Eccentricity = ' + format(world.orbit_eccentricity, 6) + ', World Mass (Solar) = ' + format(mass_solar, 6) + ', Star Mass = ' + format(mass_stars, 6));
		log('Hill Sphere results: AU = ' + hill_sphere_au + ', PD = ' + hill_sphere_pd + ', Moon Limit = ' + (hill_sphere_pd / 2));
		// Worlds orbiting just one of a companion pair need to calculate their hill sphere compared to both and use the smallest
		const companion = (world.host.companion ? world.host.companion : world.host.host);
		if (companion) {
			// Host's mass was previously included in mass_stars; replace it with the companion mass for this calculation
			const comp_mass = companion.getTotalMass() - world.host.getTotalMass();
			const comp_sphere_au = world.orbit_au * (1 - world.orbit_eccentricity) * Math.cbrt(mass_solar / (3 * (mass_stars + comp_mass)));
			const comp_sphere_pd = comp_sphere_au * AU / diameter;
			log('Hill Sphere for companion: AU = ' + comp_sphere_au + ', PD = ' + comp_sphere_pd);
			return Math.min(hill_sphere_pd, comp_sphere_pd);
		}
		return hill_sphere_pd;
	}

	/**
	 * Call after the world's orbit_period has been determined
	 */
	genRotationTraits(system, world)
	{
		// Planetoid Belts and Planetary Rings do not need to calculate these traits
		if (world.type === PLANET_BELT || world.type === PLANET_RING) return;
		world.period_sidereal = this.genPeriodSidereal(system, world);
		world.period_solar_year = this.genPeriodSolarDaysPerYear(world);
		world.period_solar = this.genPeriodSolar(world);
		world.obliquity = this.genAxialTilt(world);
		this.genTidalLock(system, world);
		this.flushHistory(world);
	}

	genPeriodSidereal(system, world)
	{
		// DM+1 per full 2 Gyrs of system age
		const dm = Math.floor(system.age / 2);
		const f = (world.type === PLANET_GAS || world.size < 1 ? 2 : 4);
		const period = this.genPeriodSiderealBase(world, dm, f);
		const min = (10 * this.roll(1, 6, -1, 'Rotation Period: +Minutes')) + this.roll(1, 10, -1, 'Rotation Period: +Minutes');
		const sec = (10 * this.roll(1, 6, -1, 'Rotation Period: +Seconds')) + this.roll(1, 10, -1, 'Rotation Period: +Seconds');
		return period + (min / 60) + (sec / 3600);
	}

	genPeriodSiderealBase(world, dm, f)
	{
		const period = (f * this.roll(2, 6, -2, 'Rotation Period')) + this.roll(1, 6, 2 + dm, 'Rotation Period');
		if (period > 39 && 4 < this.roll(1, 6, 0, 'Additional Rotation Period Check')) {
			return period + this.genPeriodSiderealBase(world, dm, f);
		}
		return period;
	}

	genPeriodSolarDaysPerYear(world)
	{
		// Special Case: Treat sidereal day as negative for Axial Tilts greater than 90 degrees
		const sidereal = (world.obliquity > 90 ? -world.period_sidereal : world.period_sidereal);
		const year_length = 8766 * world.orbit_period;
		log('Orbit Period: ' + world.orbit_period + ', Sidereal Period: ' + world.period_sidereal + ', Year Length: ' + year_length + ', Axial Tilt: ' + world.obliquity);
		return (year_length / sidereal) - 1;
	}

	genPeriodSolar(world)
	{
		const year_length = 8766 * world.orbit_period;
		return (world.period_solar_year === null || Math.abs(world.period_solar_year) < Number.EPSILON ? -1 : (year_length / world.period_solar_year));
	}

	genSize(system, world)
	{
		// Continuation Method: Use predetermined value as is, if applicable
		if (world.world_profile && world.world_profile.isApplicable(world)) {
			return world.world_profile.size;
		}
		if (world.type === PLANET_GAS) {
			return this.genSizeGasGiant(system);
		} else if (world.type === PLANET_ROCK) {
			return this.genSizeTerrestrial(system);
		}
		return 0;
	}

	genSizeGasGiant(system)
	{
		let dm = 0;
		const primary = system.getPrimaryStar();
		// DM-1 if Primary Star is a Brown Dwarf, M-Type Class V, or any Class VI star
		if (primary.type === BROWN_DWARF || primary.classification === 6 || (primary.type <= MAIN_TYPE_M && primary.classification === 5)) dm--;
		// DM-1 if System Spread is less than 0.1
		if (system.orbit_spread < 0.1) dm--;
		const roll_a = this.roll(1, 6, dm, 'Gas Giant Size: First Roll');
		let size = (roll_a < 3 ? 0 : (roll_a < 5 ? 1 : 2));
		// Special Case: Young Protostar systems (i.e. < 0.002 Gyr old) reduce Medium gas giants to Small and Small to none
		if (size < 2 && primary.type === PROTOSTAR && system.age < 0.002) {
			size--;
		}
		return size;
	}

	genSizeTerrestrial(system)
	{
		const roll_a = this.roll(1, 6, 0, 'Terrestrial Size: First Roll');
		if (roll_a < 3) {
			return this.roll(1, 6, 0, 'Terrestrial Size: Second Roll');
		} else if (roll_a < 5) {
			return this.roll(2, 6, 0, 'Terrestrial Size: Second Roll');
		}
		return this.roll(2, 6, 3, 'Terrestrial Size: Second Roll');
	}

	/**
	 * Depends on nearly all physical and orbital characteristics, including rotation period and axial tilt
	 */
	genTemperatureExtremes(system, world)
	{
		// No-op if only using basic temperature formula
		if (this.enable_basic_temp) return;
		// Likewise, only calculate High and Low temperature for terrestrial planets and moons
		if (world.type !== PLANET_ROCK && world.type !== PLANET_MOON) return;
		// Variance Factor = Axial Tilt Factor + Rotation Factor + Geographic Factor, clamped between 0.0 and 1.0
		const f_tilt = Math.abs(Math.sin(world.obliquity * Math.PI / 180));
		const f_period = (world.period_solar > 2500 || (world.orbit_lock === 1 && world.period_solar === null)
			? 1.0
			: Math.sqrt(Math.abs(world.period_solar)) / 50);
		const geo_mod = (world.surface_distribution < 2 ? -0.1 : (world.surface_distribution > 8 ? 0.1 : 0));
		const f_geo = ((10 - world.hydrographics) / 20) + geo_mod;
		const f_var = clamp(f_tilt + f_period + f_geo, 0, 1);
		// Include the luminosity from each star or group the world orbits, as well as its own star's companion or host if it orbits one or the other independently
		const f_bar = 1 + world.atmosphere.bar;
		const lum_mod = f_var / f_bar;
		// Remaining factors are the same as or similar to those for calculating Mean Temperature
		const au = orbitToAU(world.getHzcoOrbit());
		const ecc = (world.host instanceof World ? world.host.orbit_eccentricity : world.orbit_eccentricity);
		const f_num = (1 - world.albedo) * (1 + world.atmosphere.greenhouse_factor);
		const lum = world.getTotalLuminosity(system);
		log('Calculating High and Low Temperature for ' + world.getDesignation(system.n_stellar) + ': L = ' + lum + ' (mod = ' + lum_mod + '), A = ' + world.albedo + ', GF = ' + world.atmosphere.greenhouse_factor + ', Var Factors = ' + f_var + ', AU = ' + au + ', Ecc = ' + ecc);
		world.temperature_high = 279 * Math.pow(lum * Math.min(1.999, 1 + lum_mod) * f_num / Math.pow(au * (1 - ecc), 2), 0.25);
		world.temperature_low  = 279 * Math.pow(lum * Math.max(0.001, 1 - lum_mod) * f_num / Math.pow(au * (1 + ecc), 2), 0.25);
	}

	/**
	 * Depends on star luminosities, world orbit, world albedo, and world atmosphere for greenhouse factor
	 */
	genTemperatureMean(system, world)
	{
		const au = orbitToAU(world.getHzcoOrbit());
		const f_num = (1 - world.albedo) * (1 + world.atmosphere.greenhouse_factor);
		const lum = world.getTotalLuminosity(system);
		log('Calculating Mean Temperature for ' + world.getDesignation(system.n_stellar) + ': L = ' + lum + ', A = ' + world.albedo + ', GF = ' + world.atmosphere.greenhouse_factor + ', AU = ' + au);
		return 279 * Math.pow(lum * f_num / Math.pow(au, 2), 0.25);
	}

	/**
	 * Gives an estimated mean temperature based solely on the value of world.temperature
	 */
	genTemperatureMeanEstimate(world)
	{
		const chart = [188, 198, 218, 238, 263, 278, 283, 288, 293, 298, 313, 338, 388];
		const index = clamp(world.temperature, 0, 12);
		let t = chart[index];
		if (world.temperature < 1) {
			t += 5 * world.temperature;
			t = (t < 10 ? this.roll(1, 6, 5, 'Mean Temperature: reroll < 10') : t);
		}
		if (world.temperature > 12) {
			t += 50 * (world.temperature - 12);
		}
		log('Mean Temperature for temperature index ' + world.temperature + ' is ' + chart[index] + '; T = ' + t);
		if (this.enable_var_temp) {
			const diffs = [5, 10, 20, 20, 25, 15, 5, 5, 5, 5, 15, 25, 50];
			const diff = (world.temperature < 0 ? 5 : (world.temperature > 12 ? 50 : diffs[index]));
			t += diff * 0.1 * this.roll(2, 6, -7, 'Mean Temperature: Variance')
		}
		return t;
	}

	/**
	 * Depends on world orbit and atmosphere
	 */
	genTemperature(world)
	{
		const dm_atmo = world.atmosphere.getTemperatureMod();
		const dm_hzco = this.getTemperatureModHzco(world);
		return !this.enable_flat_temp || world.isInHzco()
			? this.roll(2, 6, dm_atmo + dm_hzco, 'Mean Temperature')
			: (7 + dm_atmo + dm_hzco);
	}

	getTemperatureModHzco(world)
	{
		let dm = 0;
		const orbit = world.getHzcoOrbit();
		const hzco_inner = world.getHzcoPlus(-1);
		const hzco_outer = world.getHzcoPlus(1);
		if (orbit < hzco_inner) {
			// DM+4 if world at Hot edge of HZCO, i.e. orbit < HZCO-1
			dm += 4;
			// Additional DM+1 per 0.5 Orbit# below HZCO-1, round to nearest
			const inner_in = Math.min(1, hzco_inner) - orbit;
			if (inner_in > 0) dm += Math.round(20 * inner_in);
			const inner_out = hzco_inner - Math.max(1, orbit);
			if (inner_out > 0) dm += Math.round(2 * inner_out);
		}
		if (orbit > hzco_outer) {
			// DM-4 if world at Cold edge of HZCO, i.e. orbit > HZCO+1
			dm -= 4;
			// Additional DM-1 per 0.5 Orbit# beyond HZCO+1, round to nearest
			const outer_in = Math.min(1, orbit) - hzco_outer;
			if (outer_in > 0) dm -= Math.round(20 * outer_in);
			const outer_out = orbit - Math.max(1, hzco_outer);
			if (outer_out > 0) dm -= Math.round(2 * outer_out);
		}
		return dm;
	}

	/**
	 * @return int World profile temperature value that most closely represents the world's actual mean temperature
	 */
	getTemperatureFromMean(world)
	{
		if (this.enable_basic_temp) return world.temperature;
		// Special Case: Off the charts in Frozen territory
		if (world.temperature_mean < 188) {
			return 0 - Math.floor((188 - world.temperature_mean) / 5);
		}
		// Special Case: Off the charts in Boiling territory
		if (world.temperature_mean > 388) {
			return 12 + Math.floor((world.temperature_mean - 388) / 50);
		}
		const chart = [188, 198, 218, 238, 263, 278, 283, 288, 293, 298, 313, 338, 388];
		const diffs = [  5,  10,  20,  20,  25,  15,   5,   5,   5,   5,  15,  25,  50];
		return chart.findIndex((v, i, arr) => {
			const t = v + (this.enable_var_temp ? diffs[i] / 2 : 0);
			return t >= world.temperature_mean;
		});
	}

	genTidalLock(system, world)
	{
		// Moons are checked for tidal lock by their host planet
		if (!(world.host instanceof AbstractStar)) return;
		// Tidal Lock is checked only for Terrestrial worlds of Size 1+
		if (world.type !== PLANET_ROCK || world.size < 1) return;
		// Check the planet's moon(s) first for tidal lock to the planet
		const tidal_dm = this.getTidalLockMod(system, world);
		this.genTidalLockMoons(world, tidal_dm);
		// Check the planet for tidal lock against any tidally-locked moons and/or its host star(s)
		this.genTidalLockPlanet(world, tidal_dm);
	}

	applyTidalLock(world, roll, locked_body = null)
	{
		// Retrograde rotation may invert axial tilt
		if (roll > 8 && roll < 11 && world.obliquity < 90) {
			world.obliquity = 180 - world.obliquity;
		}
		// 3:2 and 1:1 locks attenuate axial tilt
		if (roll > 10 && world.obliquity > 3) {
			world.obliquity = 0.1 * this.roll(2, 6, -2, 'Tidal Lock: Axial Tilt');
		}
		// 1:1 lock attenuates eccentricity; reroll with DM-2 and use the lower value
		if (roll > 11 && world.orbit_eccentricity > 0.1) {
			// Handled externally by StarSystemFactory since that's where the #genEccentricity method is...
		}
		// 1:1 lock rerolls axial tilt, rolling only 1D instead of 2D
		if (roll > 11) {
			world.obliquity = this.genAxialTilt(world, 1);
		}
		// Tidal Lock value is 0 for none, 1 for 1:1, and 2 for 3:2
		world.orbit_lock = (roll > 11 ? 1 : (roll < 11 ? 0 : 2));
		// Except for planets locked to their star(s), recalculate the world's solar day and year length
		if (world.orbit_lock > 0 && locked_body instanceof AbstractStar) {
			log('Tidally Locked to Star - undefined solar year for world ' + world.getDesignation());
			world.period_solar_year = null;
			world.period_solar = null;
		} else if (roll > 2) {
			log('Recalculating solar year for world ' + world.getDesignation() + '; Tidal Lock Roll: ' + roll + ', Solar Year: ' + world.period_solar + ', Days / Year: ' + world.period_solar_year);
			world.period_solar_year = this.genPeriodSolarDaysPerYear(world);
			world.period_solar = this.genPeriodSolar(world);
			log('New values are Solar Year: ' + world.period_solar + ', Days / Year: ' + world.period_solar_year);
		}
	}

	genTidalLockMoons(world, tidal_dm)
	{
		// Special Case: Planetary Rings cannot be tidally locked
		const moons = world.bodies.filter(moon => moon.size !== 0);
		moons.forEach(moon => {
			const dm = tidal_dm + this.getTidalLockModPlanet(moon);
			let roll = 0;
			if (dm < -9) {
				// No lock for DM-10 or less
			} else if (dm > 9) {
				// Automatic 1:1 lock for DM+10 or higher, subject to the special case as though it were the result of a roll
				roll = 12;
			} else {
				roll = this.roll(2, 6, dm, 'Tidal Lock');
			}
			// Special Case: For 1:1 lock, roll 2D - on a 12, reroll for tidal lock with no DMs
			let sidereal = null;
			if (12 === this.roll(2, 6, 0, '1:1 Tidal Lock*')) {
				roll = this.roll(2, 6, 0, 'Tidal Lock');
				sidereal = this.getTidalLockPeriod(moon, moon.orbit_period, roll);
				// Special Case: If the resulting tidal lock effect causes the moon's sidereal day to exceed its orbital period, it instead remains in a 1:1 lock
				if (sidereal > moon.period_sidereal) {
					roll = 12;
					sidereal = null;
				}
			}
			// Update the moon's sidereal period
			moon.period_sidereal = (sidereal === null
				? this.getTidalLockPeriod(moon, moon.orbit_period, roll)
				: sidereal);
			// Apply other lock effects
			this.applyTidalLock(moon, roll);
			this.flushHistory(moon);
		});
	}

	genTidalLockPlanet(world, tidal_dm)
	{
		// Exclude Planetary Rings from the DM-2 per moon modifier (Size S do count, though)
		const n_moons = world.bodies.filter(moon => moon.size !== 0).length;
		// Planets may lock to one of either their star(s) or any tidally-locked moon(s)
		world.bodies.forEach(moon => {
			moon.orbit_lock_dm = (moon.orbit_lock > 0
				? tidal_dm + this.getTidalLockModMoon(world, moon, n_moons)
				: -10);
		});
		const moons = world.bodies
			.filter(moon => moon.orbit_lock_dm > -10)
			.sort((a, b) => a.orbit_lock_dm - b.orbit_lock_dm);
		// Special Case: If there are two moons that are tied, check the closest one first
		let moon_a = (moons.length > 0 ? moons[0] : null);
		let moon_b = null;
		if (moons.length > 1 && moons[0].orbit_lock_dm < 10 && moons[1].orbit_lock_dm === moons[0].orbit_lock_dm) {
			moon_a = (moons[0].orbit > moons[1].orbit ? moons[1] : moons[0]);
			moon_b = (moons[0].orbit > moons[1].orbit ? moons[0] : moons[1]);
		}
		// Check moons first, all else being equal
		let locked_body = null;
		let locked_roll = 0;
		const star_dm = tidal_dm + this.getTidalLockModStar(world);
		if (moon_a !== null && moon_a.orbit_lock_dm >= star_dm) {
			// Automatic 1:1 lock for DM+10 or higher, subject to the special case as though it were the result of a roll
			locked_body = moon_a;
			locked_roll = (moon_a.orbit_lock_dm < 10
				? this.roll(2, 6, moon_a.orbit_lock_dm, 'Tidal Lock: ' + moon_a.getDesignation(0))
				: 12);
			// Moon B only set if A had DM+9 or less, so B must roll
			const roll_b = (locked_roll < 11 && moon_b !== null
				? this.roll(2, 6, moon_b.orbit_lock_dm, 'Tidal Lock: ' + moon_b.getDesignation(0))
				: -10);
			if (roll_b > locked_roll) {
				locked_roll = roll_b;
				locked_body = moon_b;
			}
		}
		// Finally, check the star if no lock was found
		if (locked_roll < 11 && star_dm > -10) {
			// Automatic 1:1 lock for DM+10 or higher, subject to the special case as though it were the result of a roll
			const roll_c = (star_dm < 10 ? this.roll(2, 6, star_dm, 'Tidal Lock: Star(s)') : 12);
			if (roll_c > locked_roll) {
				locked_roll = roll_c;
				locked_body = world.host;
			}
		}
		// Special Case: For 1:1 lock, roll 2D - on a 12, reroll for tidal lock with no DMs
		if (locked_roll > 11 && 12 === this.roll(2, 6, 0, '1:1 Tidal Lock*')) {
			locked_roll = this.roll(2, 6, 0, 'Tidal Lock');
		}
		// Update the worlds's sidereal period
		const orbit_period = (locked_body instanceof AbstractStar ? world.orbit_period : locked_body.orbit_period);
		world.period_sidereal = this.getTidalLockPeriod(world, orbit_period, locked_roll);
		// Apply other lock effects
		this.applyTidalLock(world, locked_roll, locked_body);
		this.flushHistory(world);
	}

	/**
	 * @return int DM common to all types of Tidal Lock
	 */
	getTidalLockMod(system, world)
	{
		let dm = 0;
		// DM+1 for each 3 Sizes of Size 1+ worlds, rounded up
		if (world.size > 0) dm += Math.ceil(world.size / 3);
		// DM-1 for each 0.1 of Eccentricity, rounded down, only if Eccentricity > 0.1
		if (world.orbit_eccentricity > 0.1) dm -= Math.floor(10 * world.orbit_eccentricity);
		// DM-2 for Axial Tilt above 30
		if (world.obliquity > 30) dm -= 2;
		// DM-4 (additional) for Axial Tilt between 60 and 120
		if (world.obliquity >= 60 && world.obliquity <= 120) dm -= 4;
		// DM-4 (additional) for Axial Tilt between 80 and 100
		if (world.obliquity >= 80 && world.obliquity <= 100) dm -= 4;
		// DM-2 for Atmospheric pressure above 2.5 bar
		if (world.atmosphere.bar > 2.5) dm -= 2;
		// DM-2 for system age less than 1 Gyr
		if (system.age < 1) dm -= 2;
		// DM+2 for system age between 5 and 10 Gyrs
		if (system.age >= 5 && system.age <= 10) dm += 2;
		// DM+4 for system age greater than 10 Gyrs
		if (system.age > 10) dm += 4;
		return dm;
	}

	/**
	 * @return int DM for a planet's lock to one of its moons
	 */
	getTidalLockModMoon(world, moon, n_moons)
	{
		let dm = -10;
		// DM+ Moon Size
		if (moon.size > 0) dm += moon.size;
		// DM+5 or less if moon orbit less than 5 PD
		if (moon.orbit < 5) dm += 5 + Math.ceil(5 * (5 - moon.orbit));
		// DM+4 if moon orbit between 5 and 10
		if (moon.orbit >= 5 && moon.orbit < 10) dm += 4;
		// DM+2 if moon orbit between 10 and 20
		if (moon.orbit >= 10 && moon.orbit < 20) dm += 2;
		// DM+1 if moon orbit between 20 and 40
		if (moon.orbit >= 20 && moon.orbit < 40) dm += 1;
		// DM-6 if moon orbit greater than 60
		if (moon.orbit > 60) dm -= 6;
		// DM-2 per moon beyond the first
		if (n_moons > 0) dm -= 2 * n_moons;
		return dm;
	}

	/**
	 * @return int DM for a moon's lock to its host planet
	 */
	getTidalLockModPlanet(moon)
	{
		let dm = 6;
		// DM-1 for each 20 PD
		if (moon.orbit > 20) dm -= Math.floor(moon.orbit / 20);
		// DM-2 for moons in a retrograde orbit
		if (moon.orbit_retrograde) dm -= 2;
		const mass = moon.host.getTotalMass();
		// DM+2 for host planet mass between 1 and 10
		if (mass > 1 && mass <= 10) dm += 2;
		// DM+4 for host planet mass between 10 and 100
		if (mass > 10 && mass <= 100) dm += 4;
		// DM+6 for host planet mass between 100 and 1000
		if (mass > 100 && mass <= 1000) dm += 6;
		// DM+8 for host planet mass greater than 1000
		if (mass > 1000) dm += 8;
		return dm;
	}

	/**
	 * @return int DM for a planet's lock to its host star(s)
	 */
	getTidalLockModStar(world)
	{
		let dm = -4;
		const orbit = world.getHzcoOrbit();
		// DM+4 for Orbit# less than 1, plus 1 per 0.1 Orbit# below 1, rounded down
		if (orbit < 1) dm += 4 + Math.floor(10 * (1 - (orbit - Math.floor(orbit))));
		// DM+4 for Orbit# between 1 and 2
		if (orbit >= 1 && orbit < 2) dm += 4;
		// DM+1 for Orbit# between 2 and 3
		if (orbit >= 2 && orbit <= 3) dm += 1;
		// DM-2 per Orbit# (rounded down) for Orbit# greater than 3
		if (orbit > 3) dm += 2 * Math.floor(orbit);
		const host = world.getHostStar();
		const mass = host.getTotalMass();
		// DM-2 for star mass(es) less than 0.5
		if (mass < 0.5) dm -= 2;
		// DM-1 for star mass(es) between 0.5 and 1.0
		if (mass >= 0.5 && mass < 1) dm -= 1;
		// DM+1 for star mass(es) between 2 and 5
		if (mass > 2 && mass <= 5) dm += 1;
		// DM+2 for star mass(es) greater than 5
		if (mass > 5) dm += 2;
		// DM-1 for each star orbited beyond the first
		if (host.n_stars > 1) dm -= (host.n_stars - 1);
		// DM-1 per Size of each moon of Size 1+
		dm += world.bodies.reduce((n, moon) => n + Math.max(0, moon.size), 0);
		return dm;
	}

	/**
	 * @return float The new length of the world's sidereal day based on the Tidal Lock roll
	 */
	getTidalLockPeriod(world, orbit_period, roll)
	{
		if (roll < 3) return world.period_sidereal;
		if (roll < 4) return world.period_sidereal * 1.5;
		if (roll < 5) return world.period_sidereal * 2;
		if (roll < 6) return world.period_sidereal * 3;
		if (roll < 7) return world.period_sidereal * 5;
		if (roll < 8) return 5 * 24 * this.roll(1, 6, 0, 'Tidal Lock Prograde Rotation');
		if (roll < 9) return 20 * 24 * this.roll(1, 6, 0, 'Tidal Lock Prograde Rotation');
		if (roll < 10) return 10 * 24 * this.roll(1, 6, 0, 'Tidal Lock Retrograde Rotation');
		if (roll < 11) return 50 * 24 * this.roll(1, 6, 0, 'Tidal Lock Retrograde Rotation');
		// 3:2 lock
		if (roll < 12) return 8766 * 3 * orbit_period / 2;
		// 1:1 lock
		return 8766 * orbit_period;
	}

	genTraits(system, world)
	{
		if (world.type === PLANET_GAS) {
			this.genTraitsGasGiant(system, world);
		} else if (world.type === PLANET_ROCK) {
			this.genTraitsTerrestrial(system, world);
		} else if (world.type === PLANET_MOON) {
			this.genTraitsTerrestrial(system, world);
		} else if (world.type === PLANET_BELT) {
			this.genTraitsPlanetoidBelt(system, world);
		} else if (world.type === PLANET_RING) {
			this.genTraitsPlanetaryRing(system, world);
		}
		// Continuation Method: Assign Starport and PGL-T for the Main World, if applicable
		world.applyMainWorldProfile();
	}

	genTraitsGasGiant(system, world)
	{
		if (world.size < 1) {
			world.diameter = this.roll(2, 3, 0, 'Gas Giant Size: Diameter');
			world.mass = 5 * this.roll(1, 6, 1, 'Gas Giant Size: Mass');
		} else if (world.size === 1) {
			world.diameter = this.roll(1, 6, 6, 'Gas Giant Size: Diameter');
			world.mass = 20 * this.roll(3, 6, -1, 'Gas Giant Size: Mass');
		} else {
			world.diameter = this.roll(2, 6, 6, 'Gas Giant Size: Diameter');
			world.mass = 50 * this.roll(1, 3, 0, 'Gas Giant Size: Mass (1st roll)') * this.roll(3, 6, 4, 'Gas Giant Size: Mass (2nd Roll)');
		}
		// Special Case: If initial mass >= 3000, set mass to 4000 - (200 * (2D-2))
		if (world.getTotalMass() >= 3000) {
			world.mass = 4000 - (200 * this.roll(2, 6, -2, 'Gas Giant Size: Mass (3rd roll)'));
		}
		if (this.enable_var_mass) {
			const min = (world.size < 1 ? 10 : (world.size > 1 ? 350 : 40));
			const max = (world.size < 1 ? 35 : (world.size > 1 ? 4000 : 340));
			world.mass_deviation = 0.1 * min * this.roll(2, 6, -7, 'Gas Giant Size: Mass Variance');
			// Flip the deviation if it causes the gas giant's mass to go out of bounds
			if (world.getTotalMass() < min || world.getTotalMass() > max) {
				world.mass_deviation = -world.mass_deviation;
			}
		}
		world.albedo = this.genAlbedo(world);
	}

	genTraitsPlanetaryRing(system, ring)
	{
		ring.span = 0.07 + (0.01 * this.roll(3, 6, 0, 'Planetary Ring Span'));
	}

	genTraitsPlanetoidBelt(system, belt)
	{
		belt.span = this.genPlanetoidBeltSpan(system, belt);
		this.genPlanetoidBeltComposition(belt);
		belt.bulk = Math.max(1, this.genPlanetoidBeltBulk(system, belt));
		belt.resource_rating = clamp(this.genPlanetoidBeltResourceRating(belt), 2, 12);
		belt.n_bodies_large = Math.max(0, this.genPlanetoidBeltBodyCountLarge(belt));
		belt.n_bodies_small = Math.max(0, this.genPlanetoidBeltBodyCountSmall(belt));
		log('Planetoid Belt ' + belt.getDesignation(system.n_stellar) + ' profile: ' + belt.getProfileLong());
	}

	genPlanetoidBeltBodyCountLarge(belt)
	{
		let dm = belt.bulk;
		// DM+2 if belt orbit is beyond HZCO+3
		if (belt.getHzcoOrbit() > belt.getHzcoPlus(3)) dm += 2;
		// DM-4 if belt span is less than 0.1
		if (belt.span < 0.1) dm -= 4;
		return this.roll(2, 6, dm - 12, 'Planetoid Belt: Size 1 Significant Bodies');
	}

	genPlanetoidBeltBodyCountSmall(belt)
	{
		let dm = 0;
		const orbit = belt.getHzcoOrbit();
		// DM+1 if belt orbit is between HZCO+2 and HZCO+3
		if (orbit > belt.getHzcoPlus(2) && orbit < belt.getHzcoPlus(3)) dm++;
		// DM+3 if belt orbit is beyond HZCO+3
		if (orbit > belt.getHzcoPlus(3)) dm += 3;
		// DM+1 if belt span is greater than 1.0
		if (belt.span > 1) dm++;
		const n = ((dm + 1) * (belt.bulk + 1)) + this.roll(2, 6, -10, 'Planetoid Belt: Size 1 Significant Bodies');
		// Special Case: Span of < 0.1 divides number of Size S bodies by 2, rounded up
		return (belt.span < 0.1 ? Math.ceil(n / 2) : n);
	}

	genPlanetoidBeltBulk(system, belt)
	{
		// DM-1 per 2 Gyr of system age, rounded down
		let dm = -Math.round(system.age / 2, 0);
		// DM+1 per 10% of c-type composition, rounded down
		dm += Math.round(belt.composition_c / 10, 0);
		return this.roll(2, 2, dm, 'Planetoid Belt Bulk');
	}

	genPlanetoidBeltComposition(belt)
	{
		let dm = 0;
		// DM-4 if belt is inside the HZCO
		if (belt.isInHzco()) dm -= 4;
		// DM+4 if belt is beyond the HZCO+2
		if (belt.getHzcoOrbit() > belt.getHzcoPlus(2)) dm += 4;
		belt.composition_m = this.genPlanetoidBeltCompositionM(this.roll(2, 6, dm, 'Planetoid Belt Composition: m-type, 1st roll'));
		belt.composition_s = this.genPlanetoidBeltCompositionS(this.roll(2, 6, dm, 'Planetoid Belt Composition: s-type, 1st roll'));
		belt.composition_c = this.genPlanetoidBeltCompositionC(this.roll(2, 6, dm, 'Planetoid Belt Composition: c-type, 1st roll'));
		let diff = (belt.composition_m + belt.composition_s + belt.composition_c) - 100;
		if (diff > 0) {
			// Remove any excess first from m-type
			let tmp = belt.composition_m - diff;
			diff = (tmp > 0 ? 0 : diff - belt.composition_m);
			belt.composition_m = Math.max(0, tmp);
			// Remove any remaining excess next from s-type
			tmp = belt.composition_s - diff;
			diff = (tmp > 0 ? 0 : diff - belt.composition_s);
			belt.composition_s = Math.max(0, tmp);
			// Remove any remaining excess lastly from c-type
			belt.composition_c -= diff;
		} else if (diff < 0) {
			belt.composition_o = -diff;
		}
	}

	genPlanetoidBeltCompositionM(roll)
	{
		if (roll  <   1) return 60 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  1) return 50 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  2) return 40 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  3) return 25 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  4) return 15 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  5) return  5 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  6) return  0 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  7) return  5 + 2 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  8) return  5 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  9) return  0 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll === 10) return  0 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		return (roll > 11 ? 0 : this.roll(1, 3, 0, 'Planetoid Belt Composition: m-type'));
	}

	genPlanetoidBeltCompositionS(roll)
	{
		if (roll  <   1) return  0 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  1) return  5 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  2) return 15 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  3) return 30 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  4) return 35 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  5) return 40 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  6) return 40 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  7) return 35 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  8) return 30 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  9) return 15 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll === 10) return  5 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll === 11) return  5 + 2 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		return this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
	}

	genPlanetoidBeltCompositionC(roll)
	{
		if (roll ===  1) return  0 + 1 * this.roll(1, 3, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  2) return  0 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  3) return  0 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  4) return  5 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  5) return  5 + 2 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  6) return  0 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  7) return 10 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  8) return 20 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  9) return 40 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll === 10) return 50 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll === 11) return 60 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll === 12) return 70 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		return 0;
	}

	genPlanetoidBeltResourceRating(belt)
	{
		// DM+1 per point of bulk
		let dm = belt.bulk;
		// DM+1 per 10% of m-type composition, rounded down
		dm += Math.round(belt.composition_m / 10, 0);
		// DM-1 per 10% of c-type composition, rounded down
		dm -= Math.round(belt.composition_c / 10, 0);
		return this.roll(2, 6, dm - 7, 'Planetoid Belt Resource Rating');
	}

	genPlanetoidBeltSpan(system, belt)
	{
		let dm = 0;
		const group_spread = (this.per_star_baseline ? belt.host.getMinimumOrbitSpread() : 0);
		const spread = (group_spread > 0 ? group_spread : system.getMinimumOrbitSpread());
		// DM-1 if any adjacent orbital slot contains a Gas Giant
		const orbit = belt.getHzcoOrbit();
		const lower = orbit - spread;
		const upper = orbit + spread;
		const adj_gas = belt.host.bodies.find(body => {
			if (body.type === PLANET_GAS) {
				const orb = body.getHzcoOrbit();
				return orb > lower && orb < upper;
			}
			return false;
		});
		if (adj_gas) dm--;
		// DM+3 if the belt occupies the outermost orbital slot
		if (belt.index === belt.host.bodies.length) dm += 3;
		return spread * 0.1 * this.roll(2, 6, dm, 'Planetoid Belt Span');
	}

	genTraitsTerrestrial(system, world)
	{
		// Special Case: No additional characteristics for Planetoids or Planetary Rings (i.e. Size 0 Planets or Moons)
		if (world.size === 0) {
			return;
		}
		world.diameter = (world.size < 0 ? 600 : TERRESTRIAL_DIAMETERS[world.size]);
		world.diameter_deviation = this.genTerrestrialDiameterDeviation(world);
		world.composition = this.genTerrestrialComposition(system, world);
		world.density = this.genTerrestrialDensity(world);
		world.mass = this.genTerrestrialMass(world);
		world.gravity = this.genGravity(world);
		world.atmosphere = this.atmosphere_factory.generate(system, world);
		world.temperature = this.genTemperature(world);
		// All worlds suffering from runaway greenhouse effect are assumed to be Boiling for Hydrographics code generation purposes
		const greenhouse = this.atmosphere_factory.isRunawayGreenhouse(system, world);
		this.atmosphere_factory.flushHistory(this);
		world.hydrographics = this.genHydrographicsCode(world, greenhouse);
		// Special Case: Unusual atmospheres may have a minimum hydrographics score
		if (world.atmosphere.type === 15) {
			// Steam requires a minimum of 5
			if (world.atmosphere.subtype === 8 || world.atmosphere.subtype_b === 8) {
				world.hydrographics = Math.max(5, world.hydrographics);
			}
			// Panthalassic requires a score of 10
			if (world.atmosphere.subtype === 7 || world.atmosphere.subtype_b === 7) {
				world.hydrographics = 10;
			}
		}
		world.hydrographics_percentage = this.genHydrographicsPercentage(world);
		world.surface_distribution = this.roll(2, 6, -2, 'Surface Distribution');
		world.albedo = this.genAlbedo(world);
		world.temperature_mean = (this.enable_basic_temp
			? this.genTemperatureMeanEstimate(world)
			: this.genTemperatureMean(system, world));
		// Update the world's temperature profile value to match its actual mean temperature
		log('Recalculating base temperature value of ' + world.temperature + ' for World ' + world.getDesignation(system.n_stellar) + ' based on Mean Temperature of ' + world.temperature_mean.toFixed(1) + 'K (' + (world.temperature_mean - 273).toFixed(1) + ' C)');
		world.temperature = this.getTemperatureFromMean(world);
	}

	/**
	 * May depend on High and Low temperatures
	 */
	genTerrestrialLifeTraits(system, world)
	{
		// Only applicable to terrestrial planets and moons
		if (world.type !== PLANET_ROCK && world.type !== PLANET_MOON) return;
		world.biomass = clamp(this.genBiomass(system, world), 0, 16);
		// Special Case: Set Biomass of 0 to -1 to indicate no Life
		if (world.biomass < 1) world.biomass = -1;
		world.biocomplexity = this.genBiocomplexity(system, world);
		world.biodiversity = this.genBiodiversity(system, world);
		world.biocompatibility = this.genBiocompatibility(system, world);
		world.resource_rating = clamp(this.genTerrestrialResourceRating(world), 2, 12);
		world.sophont_presence = this.genSophontPresence(system, world);
		world.habitability = clamp(this.genHabitabilityRating(world), 0, 12);
		this.flushHistory(world);
	}

	genTerrestrialResourceRating(world)
	{
		// DM+1 per Size (treat Size S as 0)
		let dm = Math.max(0, world.size);
		// DM+2 for Density > 1.12
		if (world.density > 1.12) dm += 2;
		// DM-2 for Density < 0.5
		if (world.density < 0.5) dm -= 2;
		// DM+2 for Biomass 3+
		if (world.biomass > 2) dm += 2;
		// DM+1 for Biodiversity 8-10
		if (world.biodiversity > 7 && world.biodiversity < 11) dm += 1;
		// DM+2 for Biodiversity 11+
		if (world.biodiversity > 10) dm += 2;
		// DM-1 for Compatibility < 4, but only if Biomass as at least 1
		if (world.biocompatibility < 4 && world.biomass > 0) dm -= 1;
		// DM+2 for Compatibility 8+
		if (world.biocompatibility > 7) dm += 2;
		return this.roll(2, 6, dm - 7, 'Resource Rating');
	}

	genBiomass(system, world)
	{
		// By default, only worlds within the HZCO are checked for life, as well as any pre-determined Main World
		if (!this.bio_all && !world.isInHzco() && (world.world_profile === null || !world.world_profile.isApplicable(world))) {
			log('Biomass: Skipping non-main world ' + world.getDesignation(system.n_stellar) + ' because it is not within the HZCO');
			return -1;
		}
		const dm = clamp(this.getBiomassMod(system, world), -12, 4);
		const roll = this.roll(2, 6, dm, 'Biomass Rating');
		// Special Case: Atmospheres with a Biologic taint and biomass < 1 sets biomass and biocomplexity to 1
		if (world.biomass < 1 && world.atmosphere.taints.find(t => t.subtype === TAINT_B) !== undefined) {
			world.biocomplexity = 1;
			return 1;
		}
		// Special Case: Atmospheres 0, 1, A, B, C, or F+ with biomass of 1+ add one less than the absolute value of the atmosphere modifier to their biomass rating
		if (roll > 0 && ([0, 1, 10, 11, 12].includes(world.atmosphere.type) || world.atmosphere.type > 14)) {
			return roll + Math.abs(world.atmosphere.getBiomassMod()) - 1;
		}
		return roll;
	}

	getBiomassMod(system, world)
	{
		let dm = world.atmosphere.getBiomassMod();
		dm += this.getBiomassModHydrographics(world.hydrographics);
		dm += this.getBiomassModSystemAge(system.age);
		dm += this.getBiomassModTemperature(world);
		return dm;
	}

	getBiomassModHydrographics(hydrographics)
	{
		// DM-4 for Hydrographics 0
		if (hydrographics < 1) return -4;
		// DM-2 for Hydrographics 1-3
		if (hydrographics < 4) return -2;
		// DM+1 for Hydrographics 6-8
		if (hydrographics > 5 && hydrographics < 9) return 1;
		// DM+2 for Hydrographics 9+
		if (hydrographics > 8) return 2;
		// DM+0 for anything else
		return 0;
	}

	getBiomassModSystemAge(age)
	{
		// DM-6 for Age < 0.2 Gyrs
		if (age < 0.2) return -6;
		// DM-2 for Age < 1 Gyrs
		if (age < 1) return -2;
		// DM+1 for Age > 4 Gyrs
		if (age > 4) return 1;
		// DM+0 for anything else
		return 0;
	}

	getBiomassModTemperature(world)
	{
		return (this.enable_basic_temp
			? this.getBiomassModTempBasic(world)
			: this.getBiomassModTempAdvanced(world));
	}

	getBiomassModTempBasic(world)
	{
		// DM-6 for Boiling or Frozen
		if (world.temperature < 3 || world.temperature > 11) return -6;
		// DM-2 for Hot or Cold
		if (world.temperature < 5 || world.temperature > 9) return -2;
		// DM+2 for Temperate
		return 2;
	}

	getBiomassModTempAdvanced(world)
	{
		let dm = 0;
		// DM-2 for High > 353
		if (world.temperature_high > 353) dm -= 2;
		// DM-4 for High < 273
		if (world.temperature_high < 273) dm -= 4;
		// DM-4 for Mean > 353
		if (world.temperature_mean > 353) dm -= 4;
		// DM-2 for Mean < 273
		if (world.temperature_mean < 273) dm -= 2;
		// DM+2 for Mean between 273 and 303
		if (world.temperature_mean >= 273 && world.temperature_mean <= 303) dm += 2;
		return dm;
	}

	genBiocomplexity(system, world)
	{
		// Special Case: Biocomplexity already set by previous special case
		if (world.biocomplexity > -1) return world.biocomplexity;
		// Special Case: Biocomplexity is 0 if Biomass is 0-
		if (world.biomass < 1) return 0;
		const dm = this.getBiocomplexityMod(system, world);
		return clamp(this.roll(2, 6, dm - 7, 'Biocomplexity Rating'), 0, 15);
	}

	getBiocomplexityMod(system, world)
	{
		// DM+1 per Biomass up to 9
		let dm = Math.min(9, world.biomass);
		// DM-2 if Atmosphere not 4-9
		if (world.atmosphere.type < 4 || world.atmosphere.type > 9) dm -= 2;
		// DM-2 if Atmosphere has a Low Oxygen taint
		if (world.atmosphere.taints.find(t => t.subtype === TAINT_B) !== undefined) dm -= 2;
		// DM for System Age
		dm += this.getBiocomplexityModSystemAge(system.age);
		return dm;
	}

	getBiocomplexityModSystemAge(age)
	{
		// DM-10 for Age < 1 Gyrs
		if (age < 1.01) return -10;
		// DM-8 for Age < 2 Gyrs
		if (age < 2.01) return -8;
		// DM-4 for Age < 3 Gyrs
		if (age < 3.01) return -4;
		// DM-2 for Age < 4 Gyrs
		if (age < 4.01) return -2;
		// DM+0 for anything else
		return 0;
	}

	genBiodiversity(system, world)
	{
		// Special Case: Biodiversity is 0 if Biomass is 0-
		if (world.biomass < 1) return 0;
		const dm = Math.ceil((world.biomass + world.biocomplexity) / 2);
		const roll = this.roll(2, 6, dm - 7, 'Biodiversity Rating');
		return Math.max(1, roll);
	}

	genBiocompatibility(system, world)
	{
		// Special Case: Biocompatibility is 0 if Biomass is 0-
		if (world.biomass < 1) return 0;
		const dm = this.getBiocompatibilityMod(system, world);
		const roll = this.roll(2, 6, dm, 'Biocompatibility Rating');
		return Math.max(0, roll);
	}

	getBiocompatibilityMod(system, world)
	{
		let dm = world.atmosphere.getBiocompatibilityMod();
		// DM-1 per 2 points of Biocomplexity (round down)
		dm -= Math.floor(world.biocomplexity / 2);
		// DM-2 for System Age > 8 Gyrs
		if (system.age > 8) dm -= 2;
		return dm;
	}

	/**
	 * @return int A value of -1 indicates no present whatsoever, 0 evidence of extinct sophonts, and 1 present of live sophonts
	 */
	genSophontPresence(system, world)
	{
		if (world.biocomplexity < 8) {
			return -1;
		}
		// 13+ indicates presence of living sophonts
		let dm = Math.min(9, world.biocomplexity);
		if (this.roll(2, 6, dm - 7, 'Sophont Presence: Living') > 12) {
			return 1;
		}
		// DM+1 for System Age > 5 Gyrs
		if (system.age > 5) dm++;
		// 13+ indicates evidence of extinct sophonts
		if (this.roll(2, 6, dm - 7, 'Sophont Presence: Extinct') > 12) {
			return 0;
		}
		return -1;
	}

	genHydrographicsCode(world, greenhouse = false)
	{
		// Continuation Method: Use predetermined value as is, if applicable
		if (world.world_profile && world.world_profile.isApplicable(world)) {
			return world.world_profile.hydrographics;
		}
		// Special Case: Size 1 and smaller worlds have a Hydrographics code of 0
		if (world.size < 2) return 0;
		let dm = world.atmosphere.type;
		// DM-4 for atmosphere types 0, 1, or A+
		if (world.atmosphere.type < 2 || world.atmosphere.type > 9) dm -= 4;
		// Special Case: Very Dense (D) and the Panthalassic subtype (7) of Unusual (F) atmospheres do not apply any DMs for temperature
		if (world.atmosphere.type !== 13 && (world.atmosphere.type !== 15 || (world.atmosphere.subtype !== 7 && world.atmosphere.subtype_b !== 7))) {
			// DM-2 for Hot temperatures
			if (!greenhouse && world.temperature > 9 && world.temperature < 12) dm -= 2;
			// DM-6 for Boiling temperatures or any suffering from a Runaway Greenhouse Effect
			if (greenhouse || world.temperature > 11) dm -= 6;
		}
		return clamp(this.roll(2, 6, dm - 7, 'Hydrographics Code'), 0, 10);
	}

	genHydrographicsPercentage(world)
	{
		// Special Case: Size 9+ worlds with Hydrographics 10 are always treated as 100% liquid
		if (world.size > 8 && world.hydrographics === 10) return 100;
		return clamp((10 * world.hydrographics) + this.roll(1, 10, -4, 'Hydrographics Percentage'), 0, 100);
	}

	genHabitabilityRating(world)
	{
		const atmo = this.getHabitabilityAtmoMod(world.atmosphere);
		const hydro = this.getHabitabilityHydroMod(world);
		const size = this.getHabitabilitySizeMod(world);
		const grav = this.getHabitabilityGravMod(world, size !== 0);
		const temp = this.getHabitabilityTempMod(world);
		// DM-2 for solar tidally locked (1:1) worlds
		const lock = (world.orbit_lock === 1 && world.period_solar === null ? -2 : 0);
		// Optional +/-1 to simulate unaccounted-for variables that may mitigate or worsen conditions
		const wild = (this.enable_var_habitability ? this.roll(1, 3, -2, 'Habitability Rating Variance') : 0);
		log('World Habitability mods for ' + world.getDesignation() + ': Atmo = ' + signed(atmo) + ', Grav = ' + signed(grav) + ', Hydro = ' + signed(hydro) + ', Size = ' + signed(size) + ', Temp = ' + signed(temp) + ', 1:1 Lock = ' + signed(lock) + ', Variance: ' + signed(wild));
		return 10 + atmo + grav + hydro + lock + size + temp + wild;
	}

	getHabitabilityAtmoMod(atmosphere)
	{
		// DM-1 for Low Oxygen taint, in addition to any other DMs
		const dm = (atmosphere.taints.find(t => t.subtype === TAINT_L) === undefined ? 0 : -1);
		// DM+0 for Atmosphere 6
		if (atmosphere.type === 6) return dm;
		// DM-8 for Atmosphere 0, 1, or 10 (A)
		if ([0, 1, 10].includes(atmosphere.type)) return dm - 8;
		// DM-4 for Atmosphere 2 or 14 (E)
		if (atmosphere.type === 2 || atmosphere.type === 14) return dm - 4;
		// DM-3 for Atmosphere 3 or 13 (D)
		if (atmosphere.type === 3 || atmosphere.type === 13) return dm - 3;
		// DM-2 for Atmosphere 4 or 9
		if (atmosphere.type === 4 || atmosphere.type === 9) return dm - 2;
		// DM-1 for Atmosphere 5, 7, or 8
		if ([5, 7, 8].includes(atmosphere.type)) return dm - 1;
		// DM-10 for Atmosphere 11 (B)
		if (atmosphere.type === 11) return dm - 10;
		// DM-12 for Atmosphere 12 (C) or 15+ (F+)
		return dm - 12;
	}

	getHabitabilityGravMod(world, fudge_flag = false)
	{
		const fudge = (fudge_flag ? 0.05 : 0);
		// DM-4 for Gravity < 0.2
		if (world.gravity < 0.2 + fudge) return -4;
		// DM-2 for Gravity < 0.4
		if (world.gravity < 0.4 + fudge) return -2;
		// DM-1 for Gravity < 0.7
		if (world.gravity < 0.7 + fudge) return -1;
		// DM+1 for Gravity < 0.9 (opposite fudge from here on to push toward lower DM)
		if (world.gravity < 0.9 - fudge) return 1;
		// DM+0 for Gravity < 1.1
		if (world.gravity < 1.1 - fudge) return 0;
		// DM-1 for Gravity < 1.4
		if (world.gravity < 1.4 - fudge) return -1;
		// DM-3 for Gravity < 2.0
		if (world.gravity < 2.0 - fudge) return -3;
		// DM-6 for Gravity 2.0 or higher
		return -6;
	}

	getHabitabilityHydroMod(world)
	{
		// DM-4 for Hydrographics 0 or 9
		if (world.hydrographics < 1 || world.hydrographics === 9) return -4;
		// DM-2 for Hydrographics 1-3 or 10 (A)
		if (world.hydrographics < 4 || world.hydrographics === 10) return -2;
		return 0;
	}

	getHabitabilitySizeMod(world)
	{
		// DM-1 for Size 0-4
		if (world.size < 5) return -1;
		// DM+1 for Size 9+
		if (world.size > 8) return 1;
		return 0;
	}

	getHabitabilityTempMod(world)
	{
		return (this.enable_basic_temp
			? this.getHabitabilityTempModBasic(world)
			: this.getHabitabilityTempModAdvanced(world));
	}

	getHabitabilityTempModBasic(world)
	{
		// DM-6 for Boiling or Frozen
		if (world.temperature < 3 || world.temperature > 11) return -6;
		// DM-2 for Hot or Cold
		if (world.temperature < 5 || world.temperature > 9) return -2;
		return 0;
	}

	getHabitabilityTempModAdvanced(world)
	{
		let dm = 0;
		// DM-2 for High > 323
		if (world.temperature_high > 323) dm -= 2;
		// DM-2 for High < 279
		if (world.temperature_high < 279) dm -= 2;
		// DM-4 for Mean > 323
		if (world.temperature_mean > 323) dm -= 4;
		// DM-2 for Mean between 304 and 323
		if (world.temperature_mean >= 304 && world.temperature_mean <= 323) dm -= 2;
		// DM-2 for Mean < 273
		if (world.temperature_mean < 273) dm -= 2;
		// DM-2 for Low < 200
		if (world.temperature_low < 200) dm -= 2;
		return dm;
	}

	/**
	 * Depends on world.size
	 *
	 * @param World a terrestrial world or moon
	 */
	genTerrestrialComposition(system, world)
	{
		const dm = this.getTerrestrialCompositionMod(system, world);
		const result = this.roll(2, 6, dm, 'Terrestrial Planet: Composition');
		if (result < -3) return 0;
		if (result < -1) return 1;
		if (result <  7) return 2;
		if (result < 12) return 3;
		if (result < 15) return 4;
		return 5;
	}

	getTerrestrialCompositionMod(system, world)
	{
		let dm = 0;
		const orbit = world.getHzcoOrbit();
		const hzco = world.getHzco();
		// DM-1 if Size < 5
		if (world.size < 5) dm--;
		// DM+1 if Size > 4 and < 10
		if (world.size > 4 && world.size < 10) dm++;
		// DM+3 if Size > 9
		if (world.size > 9) dm += 3;
		// DM+1 if World is at HZCO or closer
		if (orbit <= hzco) dm++;
		// DM-1 if World is further than HZCO
		if (orbit > hzco) dm--;
		// DM-1 per full 1.0 Orbit# beyond HZCO, where 0.1 is a "full Orbit#" while HZCO < 1
		const outer_in = Math.min(1, orbit) - hzco;
		if (outer_in > 0) dm -= Math.floor(10 * outer_in);
		const outer_out = orbit - Math.max(1, hzco);
		if (outer_out > 0) dm -= Math.floor(outer_out);
		// DM-1 if system more than 10 Gyrs old
		if (system.age > 10) dm--;
		return dm;
	}

	/**
	 * Depends on world.composition
	 *
	 * @param World a terrestrial world or moon
	 */
	genTerrestrialDensity(world)
	{
		const result = this.roll(2, 6, 0, 'Terrestrial Planet: Density');
		return TERRESTRIAL_DENSITIES[world.composition][result - 2];
	}

	genTerrestrialDiameterDeviation(world)
	{
		// Skip if not enabled
		if (!this.enable_var_size) {
			return 0;
		}
		// Special Case: Size S worlds only roll on the 2nd table
		const roll_a = (world.size < 0 ? 3 : this.roll(1, 3, 0, 'Terrestrial Planet: Diameter Variance (1st table)'));
		const roll_b = this.roll(1, 6, 0, 'Terrestrial Planet: Diameter Variance (2nd table)');
		// Special Case: Reroll both dice if the first die is 3 and the second 5+
		if (roll_a === 3 && roll_b > 4) {
			return this.genTerrestrialDiameterDeviation(world);
		}
		// Diameters in the lookup table assume the exact midpoint, which is 800 (or 200 for Size S) higher than the minimum diameters upon which deviations are based
		let mod = (world.size < 0 ? -200 : -800);
		if (world.size < 0) {
			mod += (roll_b - 1) * this.roll(1, 100, 0, 'Terrestrial Planet: Diameter Variance (Size S world)');
		} else {
			mod += 100 * (roll_b - 1);
			if (roll_a === 1) mod += 600;
			if (roll_a === 2) mod += 1200;
		}
		// Variation down to the single-kilometer level
		mod += 10 * this.roll(1, 10, -1, 'Terrestrial Planet: Diameter Variance (tens place)');
		mod += this.roll(1, 10, -1, 'Terrestrial Planet: Diameter Variance (ones place)');
		return mod;
	}

	/**
	 * Depends on world.density and world.diameter
	 *
	 * @param World a terrestrial world or moon
	 */
	genTerrestrialMass(world)
	{
		return world.density * Math.pow(world.getTotalDiameter() / TERRA_DIAMETER, 3);
	}

	genMoon(system, world, size, type, is_main = false)
	{
		// Special Case: Planetary Rings are generally inside the Roche Limit (i.e. 1.5 PD) and so placed in band 0
		const band = (type === PLANET_RING ? 0 : this.genMoonOrbitBand(world));
		const orbit = this.genMoonOrbit(world, band);
		const moon = this.getMoonInstance(world, orbit, type);
		moon.orbit_band = band;
		moon.orbit_deviation = (this.enable_var_orbit && type !== PLANET_RING ? 0.1 * this.roll(2, 6, -7, 'Moon Orbit: Variance') : 0);
		// Continuation Method: Assign world profile if required; i.e. present, matches the moon type, and main world not yet assigned
		if (is_main) {
			moon.world_profile = world.world_profile;
			moon.size = moon.world_profile.size;
			log('Continuation Method: Generating Main World as satellite object (' + moon.getTypeName() + ') around ' + world.getDesignation(system.n_stellar));
		} else {
			moon.size = size;
		}
		this.genTraits(system, moon);
		// Determine Orbital Period, in hours; distance is in PD, and world size for gas giants is 8 per size category (i.e. S = 8, M = 16, L = 24)
		const world_size = (world.type === PLANET_GAS ? (world.size + 1) * 8 : world.size);
		const combined = moon.getTotalMass() + world.getTotalMass();
		const distance = moon.getTotalOrbit() * world_size;
		moon.orbit_period = 0.176927 * Math.sqrt(Math.pow(distance, 3) / combined);
		this.flushHistory(moon);
		return moon;
	}

	getMoonInstance(world, orbit, type)
	{
		switch (type) {
		case PLANET_MOON: return new Moon(world, orbit, world.bodies.length + 1);
		case PLANET_RING: return new PlanetaryRing(world, orbit, world.bodies.length + 1);
		}
		return new World(world, orbit, world.bodies.length + 1, type);
	}

	genSignificantMoons(system, world)
	{
		// Continuation Method: Main World may be in orbit around another body
		const is_main_moon = (world.world_profile && world.world_profile.host !== null);
		const min = (is_main_moon ? (world.world_profile.type === PLANET_RING ? 0 : 1) : -1);
		const hill_sphere_moon_limit = world.hill_sphere / 2;
		if (min > -1 && hill_sphere_moon_limit < (min > 0 ? 1.5 : 0.55)) {
			log('Continuation Method: Failed to choose good candidate for satellite Main World - insufficient Hill Sphere');
		}
		const n = Math.max(min, this.genSignificantMoonQty(system, world));
		if (n < 0) {
			// No significant moons
		} else if (hill_sphere_moon_limit < 0.55) {
			// No moons or planetary rings can exist due to the extremely low Hill Sphere
		} else if (n < 1) {
			// Planetary ring, i.e. a Size 0 moon
			world.bodies.push(this.genMoon(system, world, 0, PLANET_RING, is_main_moon));
		} else if (hill_sphere_moon_limit < 1.5) {
			// Hill Sphere Moon Limit is below the Roche Limit; convert first moon to a planetary ring and ignore the remainder
			log('Hill Sphere Moon Limit for ' + world.getDesignation(system.n_stellar) + ' is too low for moons; converting first to a Planetary Ring and ignoring the remaining ' + (n - 1));
			world.bodies.push(this.genMoon(system, world, 0, PLANET_RING, is_main_moon));
		} else {
			// Generate n moons
			let has_main = !is_main_moon;
			for (let i = 0; i < n; i++) {
				let type = PLANET_MOON;
				let size = this.genMoonSize(world);
				// Special Case: Any non-ring moon with Size of -1 or smaller is Size S (i.e. -1)
				if (size < 0) size = -1;
				// Special Case: Any non-ring moon exactly 2 sizes less than its host Terrestrial Planet rolls 2D (Size S counts as 0 for this purpose)
				if (world.type === PLANET_ROCK && size !== 0 && Math.max(0, size) === (world.size - 2)) {
					const roll = this.roll(2, 6, 0, 'Moon Size: Exactly 2 less than Terrestrial host');
					if (roll === 2) size = world.size - 1;
					if (roll === 12) {
						size = world.size;
						type = PLANET_ROCK;
					}
				}
				// Special Case: Size 0 moons become Planetary Rings
				if (size === 0 && type === PLANET_MOON) {
					type = PLANET_RING;
				}
				// Special Case: Maximum size moon around a Gas Giant
				if (world.type === PLANET_GAS && size === 16) {
					size = 0; // Size S
					type = PLANET_GAS;
					// Special Case: If the parent Gas Giant is Large, roll another 2D; on a 12, the moon is a Size M gas giant
					if (world.size > 1 && 12 === this.roll(2, 6, 0, 'Moon Size: Large Gas Giant')) size = 1;
				}
				// Continuation Method: Determine if the current satellite should be the Main World
				let is_main = false;
				if (!has_main) {
					is_main = (world.world_profile.type === type || (world.world_profile.type === PLANET_MOON && type === PLANET_ROCK));
					// Ensure at least one eligible satellite is generated
					if (!is_main && i + 1 === n) {
						log('Continuation Method: Failed to generate eligible body for satellite Main World; changing final Size ' + size + ' body to Size ' + world.world_profile.size + ' and suitable Type');
						size = world.world_profile.size;
						type = world.world_profile.type;
						is_main = true;
					}
					has_main = is_main;
				}
				world.bodies.push(this.genMoon(system, world, size, type, is_main));
			}
			// Reorder and re-index moons based on their actual orbit#s
			world.bodies.sort((a, b) => a.getTotalOrbit() - b.getTotalOrbit());
			let n_rings = 1;
			let n_moons = 1;
			for (let j = 0; j < world.bodies.length; j++) {
				world.bodies[j].index = (world.bodies[j].significant ? n_moons++ : n_rings++);
			}
		}
	}

	genSignificantMoonQty(system, world)
	{
		// Either DM-1 or 0, to be applied per die rolled
		const dm = this.getSignificantMoonMod(system, world);
		switch (world.type) {
		case PLANET_GAS:
			if (world.size < 0) return -1;
			if (world.size < 1) return this.roll(3, 6, (3 * dm) - 7, 'Significant Moons: Quantity');
			return this.roll(4, 6, (4 * dm) - 6, 'Significant Moons: Quantity');
		case PLANET_ROCK:
			if (world.size < 1) return -1;
			if (world.size < 3) return this.roll(1, 6, (1 * dm) - 5, 'Significant Moons: Quantity');
			if (world.size < 10) return this.roll(2, 6, (2 * dm) - 8, 'Significant Moons: Quantity');
			return this.roll(2, 6, (2 * dm) - 6, 'Significant Moons: Quantity');
		}
		return -1;
	}

	getSignificantMoonMod(system, world)
	{
		// Apply DM-1 per die only for the first condition that applies, ignoring any additional conditions
		if (this.hill_moon_qty) {
			return (world.hill_sphere < 60 ? -1 : 0);
		}
		const orbit = world.getTotalOrbit();
		const group_spread = (this.per_star_baseline ? world.host.getMinimumOrbitSpread() : 0);
		const spread = (group_spread > 0 ? group_spread : system.getMinimumOrbitSpread());
		// DM-1 if planet’s Orbit# is less than 1.0
		if (orbit < 1) return -1;
		// DM-1 if planet is an orbital slot adjacent to a companion, i.e. within 1 x spread of the companion-induced MAO (0.5 + eccentricity)
		if (world.host instanceof StarGroupCompanion && orbit < (world.host.getMinimumAllowableOrbit() + spread)) return -1;
		// if ((world.host instanceof Star && (world.host.companion || world.host.host))) {
		// DM-1 if planet’s orbital slot around a primary star (or pair) is adjacent to a Close or Near star unavailability range
		if (world.host.isPrimaryComponent()) {
			const adjacent = system.stars.find(star => {
				if (star.orbit_band < 1 || star.orbit_band > 2) return false;
				const min = star.getMinimumAllowableOrbit();
				if (orbit < min && min - spread < orbit) return true;
				const max = star.getMaximumAllowableOrbit();
				if (max < orbit && orbit < max + spread) return true;
			});
			if (adjacent) return -1;
		}
		// DM-1 if planet is in the adjacent orbital slot to the outermost Orbit# range of a Close, Near or Far star (e.g. around B, Ba, or Bb but not around AB)
		if (!world.host.isPrimaryComponent() && world.host.orbit_band > 0 && orbit > (world.host.getMaximumAllowableOrbit() - spread)) return -1;
		return 0;
	}

	getMoonEccentricityMod(moon)
	{
		let dm = 0;
		// DM-1 for Inner orbit moons
		if (moon.orbit_band === 1) dm--;
		// DM+1 for Middle orbit moons
		if (moon.orbit_band === 2) dm++;
		// DM+4 for Outer orbit moons
		if (moon.orbit_band === 3) dm += 4;
		// Additional DM+2 for any moons beyond the MOR (Moon Orbit Range)
		if (moon.getTotalOrbit() > moon.host.moon_orbit_range) dm += 2;
		return dm;
	}

	/**
	 * @return integer The value to use for the moon's orbit band: 0 = Adjacent (i.e. Planetary Ring), 1 = Inner, 2 = Middle, 3 = Outer
	 */
	genMoonOrbitBand(world)
	{
		const dm = (world.moon_orbit_range < 60 ? 1 : 0);
		const roll = this.roll(1, 6, dm, 'Moon Orbit: Range/Band Determination');
		return (roll < 4 ? 1 : (roll > 5 ? 3 : 2));
	}

	/**
	 * @param int orbit_band The orbit band the moon will be placed in
	 */
	genMoonOrbit(world, orbit_band)
	{
		// Special Case: Planetary Rings use a different calculation for their center of orbit
		if (orbit_band = 0) return 0.4 + (this.roll(2, 6, 0, 'Moon Orbit: Planetary Ring') / 8);
		// Moon Orbit Range capped at 200 for the purpose of determining Orbit#
		const mor = Math.min(200, world.moon_orbit_range);
		const roll = this.roll(2, 6, -2, 'Moon Orbit: Location in PD');
		if (orbit_band === 2) return roll * (mor / 30) + (mor / 6) + 3;
		if (orbit_band === 3) return roll * (mor / 20) + (mor / 2) + 4;
		return roll * (mor / 60) + 2;
	}

	genMoonSize(world)
	{
		const roll = this.roll(1, 6, 0, 'Moon Size: 1st roll');
		if (roll < 4) return -1; // Size S
		if (roll < 6) return this.roll(1, 3, -1, 'Moon Size: 2nd roll');
		if (world.type !== PLANET_GAS) return (world.size - 1) - this.roll(1, 6, 0, 'Moon Size: 2nd roll');
		// Special Case: Gas Giants
		const gas = this.roll(1, 6, 0, 'Moon Size: Gas Giant Special, 1st roll');
		if (roll < 4) return this.roll(1, 6, 0, 'Moon Size: Gas Giant Special, 2nd roll');
		if (roll < 6) return this.roll(2, 6, -2, 'Moon Size: Gas Giant Special, 2nd roll');
		return this.roll(2, 6, 4, 'Moon Size: Gas Giant Special, 2nd roll');
	}
}

class AtmosphereFactory extends AbstractFactory
{
	/**
	 * @param FormData options:
	 *   @option bool green_check True to enable checking for Runaway Greenhouse Effects
	 *   @option bool green_inner True to also check all planets orbiting below the HZCO for Runaway Greenhouse Effect
	 */
	constructor(options)
	{
		super();
		this.enable_green_check = options.has('green_check');
		this.enable_green_inner = options.has('green_inner');
	}

	generate(system, world)
	{
		// Only terrestrial planets and moons need to determine atmosphere type
		if (![PLANET_ROCK, PLANET_MOON].includes(world.type)) return null;
		const atmosphere = this.genType(world);
		atmosphere.type_orig = atmosphere.type;
		this.genSubtype(world, atmosphere, false);
		atmosphere.density = this.genDensity(atmosphere);
		atmosphere.bar = this.genPressureTotal(atmosphere);
		atmosphere.ppo = this.genPressureOxygen(system, atmosphere);
		// Special Case: PPO < 0.1 or > 0.5 for supposedly breathable atmosphere type of 5, 6, or 8; change to corresponding Tainted version
		if ([5, 6, 8].includes(atmosphere.type) && (atmosphere.ppo < 0.1 || atmosphere.ppo > 0.5)) {
			log('World ' + world.getDesignation(system.n_stellar) + ' atmospheric PPO out of bounds for breathable atmosphere ' + atmosphere.type + '; changing to corresponding Tainted type');
			atmosphere.type = (atmosphere.type < 6 ? 4 : atmosphere.type + 1);
		}
		// Tainted atmosphere types are 2, 4, 7, and 9
		if (atmosphere.irritant || [2, 4, 7, 9].includes(atmosphere.type)) {
			this.genTaint(atmosphere);
		}
		atmosphere.greenhouse_factor = this.genGreenhouseFactor(atmosphere);
		return atmosphere;
	}

	genType(world)
	{
		// Continuation Method: Use predetermined value as is, if applicable
		if (world.world_profile && world.world_profile.isApplicable(world)) {
			return new Atmosphere(world.world_profile.atmosphere);
		}
		// Special Case: Worlds of Size 1 or less have no significant atmosphere
		if (world.size < 2) return new Atmosphere(0);
		const dm = this.getTypeMod(world);
		const roll = this.roll(2, 6, world.size + dm - 7, 'Atmosphere Type');
		// Habitable zone atmospheres use the die result effectiely as is
		if (world.isInHzco()) {
			return new Atmosphere(clamp(roll, 0, 17));
		}
		// Non-habitable zone atmospheres have multiple charts
		const orbit = world.getHzcoOrbit();
		if (orbit < world.getHzcoPlus(-2)) return this.genTypeHotPlus(world, roll);
		if (orbit < world.getHzcoPlus(-1)) return this.genTypeHot(world, roll);
		if (orbit > world.getHzcoPlus(3)) return this.genTypeCold(world, roll);
		if (orbit > world.getHzcoPlus(1)) return this.genTypeColdPlus(world, roll);
		log('Failed to determine atmosphere for ' + world.getDesignation(2) + ' at Orbit# ' + orbit.toFixed(4) + ' around HZCO ' + world.getHzco());
		return new Atmosphere(0);
	}

	getTypeMod(world)
	{
		let dm = 0;
		// DM-1 if world's gravity is less than 0.5G
		if (world.gravity < 0.5) dm--;
		// DM-1 (in addition to the above) if world's gravity is less than 0.4G
		if (world.gravity < 0.4) dm--;
		return dm;
	}

	genTypeHotPlus(world, roll)
	{
		if (roll < 2) return new Atmosphere(0); // None
		if (roll < 4) return new Atmosphere(1); // Trace
		if (roll < 9) {
			const density = (roll - 2);
			const irritant = (this.roll(1, 6, 0, 'Atmospheric Irritant Presence') > 4);
			// Special Case: world's orbit is closer than HZCO-3
			if (world.getHzcoOrbit() < world.getHzcoPlus(-3)) {
				const dm = (density > 4 ? 1 : 0);
				const roll_b = this.roll(1, 6, dm, 'Atmosphere Type: Orbit < HZCO-3');
				if (roll_b === 1) return new Atmosphere(1, density, irritant);
				if (roll_b === 2) return new Atmosphere(10, density, irritant); // Exotic
				if (roll_b > 5) return new Atmosphere(12, density, irritant); // Insidious
				return new Atmosphere(11, density, irritant); // Corrosive
			}
			return new Atmosphere(10, density, irritant); // Exotic
		}
		if (roll < 12 || roll === 13) return new Atmosphere(11); // Corrosive
		if (roll < 15) return new Atmosphere(12); // Insidious
		// Rolls of 15+ can be used directly as the corresponding type, capped at 17 (Gas, Hydrogen)
		return new Atmosphere(Math.min(17, roll));
	}

	genTypeHot(world, roll)
	{
		if (roll < 1) return new Atmosphere(0); // None
		if (roll < 2) return new Atmosphere(1); // Trace
		if (roll < 11) {
			const density = 1 + Math.floor(roll / 2);
			const irritant = ([2, 4, 7, 9].includes(roll) || (roll === 10 && this.roll(1, 6, 0, 'Atmospheric Irritant Presence') > 4));
			return new Atmosphere(10, density, irritant); // Exotic
		}
		if (roll === 11 || roll === 13) return new Atmosphere(11); // Corrosive
		if (roll < 15) return new Atmosphere(12); // Insidious
		// Rolls of 15+ can be used directly as the corresponding type, capped at 17 (Gas, Hydrogen)
		return new Atmosphere(Math.min(17, roll));
	}

	genTypeCold(world, roll)
	{
		if (roll < 1) return new Atmosphere(0); // None
		if (roll < 3) return new Atmosphere(1); // Trace
		if (roll < 11) {
			const density = 1 + Math.floor(roll / 2);
			const irritant = ([4, 7, 9].includes(roll) || ([3, 10].includes(roll) && this.roll(1, 6, 0, 'Atmospheric Irritant Presence') > 4));
			return new Atmosphere(10, density, irritant); // Exotic
		}
		if (roll === 11 || roll === 14) return new Atmosphere(11); // Corrosive
		// Rolls of 12+ can be used directly as the corresponding type, capped at 17 (Gas, Hydrogen)
		return new Atmosphere(Math.min(17, roll));
	}

	genTypeColdPlus(world, roll)
	{
		// Rolls of 12- are identical to the normal Cold results
		if (roll < 13) return this.genTypeCold(world, roll);
		if (roll === 13) return new Atmosphere(16); // Gas, Helium
		if (roll === 15) return new Atmosphere(15); // Unusual
		return new Atmosphere(17); // Gas, Hydrogen
	}

	genSubtype(world, atmosphere, greenhouse = false)
	{
		// Special Case: Exotic atmospheres roll for subtype; this may also determine density and whether to roll for irritants
		if (atmosphere.type === 10) {
			atmosphere.subtype = this.genSubtypeExotic(world, atmosphere, greenhouse);
			atmosphere.irritant = atmosphere.irritant || ([2, 4, 7, 9, 11, 14].includes(atmosphere.subtype));
		}
		// Special Case: Corrosive and Insidious atmospheres roll for subtype; this may also determine density and whether to roll for irritants
		if (atmosphere.type === 11 || atmosphere.type === 12) {
			atmosphere.subtype = this.genSubtypeHazardous(world, atmosphere, greenhouse);
			atmosphere.irritant = atmosphere.irritant || ([2, 4, 7, 9, 11, 14].includes(atmosphere.subtype));
		}
		// Special Case: Unusual atmospheres roll for subtype, which may dictate density
		if (atmosphere.type === 15) {
			atmosphere.subtype = this.genSubtypeUnusual(world, atmosphere);
		}
	}

	genSubtypeExotic(world, atmosphere, greenhouse = false)
	{
		const dm = this.getSubtypeMod(world, atmosphere, greenhouse);
		const roll = this.roll(2, 6, dm, 'Atmosphere Subtype: ' + atmosphere.getTypeName());
		const subtype = clamp(roll, 2, 14);
		// Exotic densities range from Very Thin (2) to Very Dense (6), increasing on each even result starting at 4
		atmosphere.density = 1 + Math.floor(Math.min(10, subtype) / 2);
		// Special Case: Roll of 13 = A (10) and 14 = B (11)
		return subtype > 12 ? subtype - 3 : subtype;
	}

	genSubtypeHazardous(world, atmosphere, greenhouse = false)
	{
		const dm = this.getSubtypeMod(world, atmosphere, greenhouse);
		const roll = this.roll(2, 6, dm, 'Atmosphere Subtype: ' + atmosphere.getTypeName());
		const subtype = clamp(roll, 1, 14);
		// Corrosive and Insidious densities range from Very Thin (2) to Extremely Dense (7), increasing on each even result starting at 4
		atmosphere.density = Math.max(2, 1 + Math.floor(Math.min(12, subtype) / 2));
		return subtype;
	}

	genSubtypeUnusual(world, atmosphere, combo = false)
	{
		const roll = this.roll(1, 12, 0, 'Atmosphere Subtype: ' + atmosphere.getTypeName());
		// Special Case: Layered subtype requires gravity > 1.2
		if (roll === 6 && world.gravity <= 1.2) {
			return this.genSubtypeUnusual(world, atmosphere, combo);
		}
		// Special Case: Dense results are incompatible with each other
		if (roll < 4 && atmosphere.subtype_b > -1 && atmosphere.subtype_b < 4) {
			return this.genSubtypeUnusual(world, atmosphere, combo);
		}
		// Special Case: Combination (i.e. 2 subtypes)
		if (roll === 11) {
			if (combo || atmosphere.subtype_b > -1) return this.genSubtypeUnusual(world, atmosphere, combo);
			atmosphere.subtype_b = this.genSubtypeUnusual(world, atmosphere, true);
			return this.genSubtypeUnusual(world, atmosphere, true);
		}
		return (roll > 10 ? 15 : roll);
	}

	getSubtypeMod(world, atmosphere, greenhouse = false)
	{
		let dm = 0;
		const orbit = world.getHzcoOrbit();
		// DM-2 for Size 2-4 worlds
		if (world.size > 1 && world.size < 5) dm -= 2;
		// DM-2 if orbit below HZCO-1
		if (orbit < world.getHzcoPlus(-1)) dm -= 2;
		// DM+2 if orbit greater than HZCO+2
		if (orbit > world.getHzcoPlus(2)) dm += 2;
		// DM+4 if the atmosphere became exotic because of a runaway greenhouse check
		if (greenhouse) dm += 4;
		// DM+2 for Size 8+ worlds with Corrosive or Insidious atmospheres
		if (atmosphere.type !== 10 && world.size > 7) dm += 2;
		// DM+2 if atmosphere is Insidious
		if (atmosphere.type === 12) dm += 2;
		return dm;
	}

	genDensity(atmosphere)
	{
		// Special Case: density already determined by special atmosphere type
		if (atmosphere.density > -1) return atmosphere.density;
		if (atmosphere.type  <   1) return 0; // None
		if (atmosphere.type  <   2) return 1; // Extremely Thin
		if (atmosphere.type  <   4) return 2; // Very Thin
		if (atmosphere.type  <   6) return 3; // Thin
		if (atmosphere.type  <   8) return 4; // Standard
		if (atmosphere.type  <  10) return 5; // Dense
		// Atmosphere types 10-12 (Exotic, Corrosive, and Insidious) should have already determined density
		if (atmosphere.type === 13) return 6; // Very Dense
		if (atmosphere.type === 14) return 2; // Very Thin
		if (atmosphere.type === 16) return 8; // Crushing
		if (atmosphere.type === 17) return 9; // Extremely Crushing
		// Unusual atmosphere density depends on its subtype(s)
		if (atmosphere.type === 15) {
			if (atmosphere.subtype === 1 || atmosphere.subtype_b === 1) return 7;
			if (atmosphere.subtype === 2 || atmosphere.subtype_b === 2) return 8;
			if (atmosphere.subtype === 3 || atmosphere.subtype_b === 3) return 9;
			if (atmosphere.subtype === 8 || atmosphere.subtype_b === 8) return 6 + this.roll(1, 3, -1, 'Steam Atmosphere Density');;
			if (atmosphere.subtype === 7 || atmosphere.subtype_b === 7) return 4 + this.roll(1, 4, -1, 'Panthalassic Atmosphere Density');
		}
		return 4; // Default to Standard
	}

	genPressureTotal(atmosphere)
	{
		const max = this.getPressureMax(atmosphere.type, atmosphere.density);
		const low = this.getPressureMin(atmosphere.type, atmosphere.density);
		// Special Case: Unusual (Panthalassic) atmosphere subtype requires a minimum of 1.0 bar
		const pan = (atmosphere.type === 15 && (atmosphere.subtype === 7 || atmosphere.subtype_b === 7));
		const min = (pan ? Math.max(1.0, low) : low);
		const span = max - min;
		if (span > 0) {
			return min + (span * 0.01 * this.roll(1, 100, 0, 'Atmospheric Pressure: Total'));
		}
		return 0;
	}

	getPressureMax(type, density)
	{
		switch (density) {
		case 0: return 0.0009;
		case 1: return 0.09;
		case 2: return 0.42;
		case 3: return 0.70;
		case 4: return 1.49;
		case 5: return 2.49;
		case 6: return 10.0;
		case 7: return 100.0;
		case 8: return 1000.0;
		case 9: return 9999.9;
		}
		return 0;
	}

	getPressureMin(type, density)
	{
		// Special Case: H and He Gas atmospheres do not use the normal density ranges
		if (type === 16) return 100;
		if (type > 16) return 1000;
		switch (density) {
		case 0: return 0;
		case 1: return 0.001;
		case 2: return 0.1;
		case 3: return 0.43;
		case 4: return 0.70;
		case 5: return 1.5;
		case 6: return 2.5;
		case 7: return 10.0;
		case 8: return 100.0;
		case 9: return 1000.0;
		}
		return 0;
	}

	genPressureOxygen(system, atmosphere)
	{
		// PPO only for atmosphere types 2-9, D, and E
		if ((atmosphere.type < 2 || atmosphere.type > 9) && atmosphere.type !== 13 && atmosphere.type !== 14) {
			return 0;
		}
		const dm = this.getPressureOxygenMod(system);
		const a = 0.05 * this.roll(1, 6, dm, 'Atmosphere Pressure: Partial Oxygen (1st roll)');
		const b = 0.01 * this.roll(2, 6, -7, 'Atmosphere Pressure: Partial Oxygen (2nd roll)');
		const c = 0.05 * this.roll(1, 6, -1, 'Atmosphere Pressure: Partial Oxygen (3rd roll)');
		const v =  0.001 * this.roll(2, 6, -7, 'Atmosphere Pressure: Partial Oxygen Variance');
		let f = a + b + c + v;
		// Special Case: If result is 0 or less, determine it instead as 0.01 * 1D + variance
		if (f <= 0) {
			f = v + 0.01 * this.roll(1, 6, 0, 'Atmosphere Pressure: Partial Oxygen (reroll)');
		}
		return f * atmosphere.bar;
	}

	getPressureOxygenMod(system)
	{
		let dm = 0;
		// DM+1 if system more than 4 Gyrs old
		if (system.age > 4) dm++;
		// DM-1 if system between 3 and 3.5 Gyrs old
		if (system.age > 3 && system.age <= 3.5) dm--;
		// DM-2 if system between 2 and 3 Gyrs old
		if (system.age >= 2 && system.age < 3) dm -= 2;
		// DM-4 if system less than 2 Gyrs old
		if (system.age < 2) dm -= 4;
		return dm;
	}

	genGreenhouseFactor(atmosphere)
	{
		// Vacuum worlds have a greenhouse factor of 0 by definition
		if (atmosphere.type === 0) return 0;
		let gf = 0.5 * Math.sqrt(atmosphere.bar);
		// Atmosphere types 1-9, D, and E add 0.01 * 3D
		if (atmosphere.type < 10 || [13, 14].includes(atmosphere.type)) {
			gf += 0.01 * this.roll(3, 6, 0, 'Greenhouse Factor: Atmosphere (1-9, D, E)');
		}
		// Atmosphere types A and F add 1D-1 (min. 0.5)
		if (atmosphere.type === 10 || atmosphere.type === 15) {
			gf += Math.max(0.5, this.roll(1, 6, -1, 'Greenhouse Factor: Atmosphere (A, F)'));
		}
		// Atmosphere types B, C, G, and H roll 1D: on 1-5, multiply the greenhouse factor by the result, on a 6, multiply by 3D
		if ([11, 12, 16, 17].includes(atmosphere.type)) {
			const roll = this.roll(1, 6, 0, 'Greenhouse Factor: Atmosphere (B, C, G, H)');
			gf *= (roll < 6 ? roll : this.roll(3, 6, 0, 'Greenhouse Factor: Atmosphere (B, C, G, H)'));
		}
		return gf;
	}

	/**
	 * Checks for and applies the effects of the Runaway Greenhouse Effect
	 *
	 * @param StarSystem system
	 * @param World world Requires temperature to have been determined
	 *
	 * @return bool True if the world is determined to be suffering from a Runaway Greenhouse Effect
	 */
	isRunawayGreenhouse(system, world)
	{
		if (this.shouldCheckForRunawayGreenhouse(system, world)) {
			const dm = this.getRunawayGreenhouseMod(system, world);
			const roll = this.roll(2, 6, dm, 'Runaway Greenhouse Effect');
			if (roll > 11) {
				this.applyRunawayGreenhouse(system, world);
				return true;
			}
		}
		return false;
	}

	applyRunawayGreenhouse(system, world)
	{
		// Worlds with standard atmospheres (i.e. 2-9, D, or E) convert to A, B, or C
		if (world.atmosphere.type < 10 || world.atmosphere.type === 13 || world.atmosphere.type === 14) {
			let dm = 0;
			// DM-2 if world is Size 2-5
			if (world.size > 1 && world.size < 6) dm += 2;
			// DM+1 if original atmosphere was Tainted
			if ([2, 4, 7, 9].includes(world.atmosphere.type_orig)) dm++;
			const roll = this.roll(1, 6, dm, 'Runaway Greenhouse Effect: New Atmosphere Type');
			world.atmosphere.type = (roll < 2 ? 10 : (roll > 4 ? 12 : 11));
			this.genSubtype(world, world.atmosphere, true);
			// Recalculate atmospheric pressure and PPO using new density value
			world.atmosphere.bar = this.genPressureTotal(world.atmosphere);
			world.atmosphere.ppo = this.genPressureOxygen(system, world.atmosphere);
			// Clear previous Taints, if any, and check again if Irritant indicated as present
			world.atmosphere.taints = [];
			if (world.atmosphere.irritant) {
				this.genTaint(world.atmosphere);
			}
		}
	}

	shouldCheckForRunawayGreenhouse(system, world)
	{
		if (!this.enable_green_check) return false;
		// Worlds with atmospheres of < 2 or > F (15) never check for runaway greenhouse effect
		if (world.atmosphere.type < 2 || world.atmosphere.type > 15) return false;
		// Hot and Boiling worlds in the HZCO should check
		if (world.temperature > 9 && world.isInHzco()) return true;
		// Optionally, check for any world (i.e. regardless of temperature) closer than the HZCO
		if (this.enable_green_inner && world.getHzcoOrbit() < world.getHzcoPlus(-1)) return true;
		return false;
	}

	getRunawayGreenhouseMod(system, world)
	{
		let dm = 0;
		// DM+1 per Gyr of system age, rounded up
		dm += (system.age < 0.5 ? 0 : Math.ceil(system.age));
		// DM+4 if world is Boiling (i.e. temperature of 12+)
		if (world.temperature > 11) dm += 4;
		// DM-2 if world is Temperate (i.e. temperature of 5-9)
		if (world.temperature > 4 && world.temperature < 10) dm -= 2;
		return dm;
	}

	genTaint(atmosphere)
	{
		// Special Case: Flag for automatically-added Low or High Oxygen taint, which still need to roll to determine if there are additional taints
		let special = false;
		// Special Case: Atmospheres with PPO < 0.1 automatically acquire the Low Oxygen taint as their first
		if (atmosphere.ppo < 0.1 && atmosphere.taints.length < 1) {
			atmosphere.taints.push(new AtmosphereTaint(TAINT_L, this.genTaintSeverity(atmosphere, TAINT_L), 0));
			special = true;
		}
		// Special Case: Atmospheres with PPO > 0.5 automatically acquire the High Oxygen taint as their first
		if (atmosphere.ppo > 0.5 && atmosphere.taints.length < 1) {
			atmosphere.taints.push(new AtmosphereTaint(TAINT_H, this.genTaintSeverity(atmosphere, TAINT_H), 0));
			special = true;
		}
		const roll_a = this.genTaintSubtypeRoll(atmosphere);
		if (roll_a === 10) {
			if (!special) {
				atmosphere.taints.push(new AtmosphereTaint(TAINT_P, this.genTaintSeverity(atmosphere, TAINT_P), 0));
			}
			const roll_b = this.genTaintSubtypeRoll(atmosphere);
			if (!special) {
				const type_b = this.getTaintSubtypeFromRoll(roll_b);
				atmosphere.taints.push(new AtmosphereTaint(type_b, this.genTaintSeverity(atmosphere, type_b), 0));
			} else if (roll_b === 10) {
				atmosphere.taints.push(new AtmosphereTaint(TAINT_P, this.genTaintSeverity(atmosphere, TAINT_P), 0));
			}
			if (roll_b === 10) {
				const roll_c = this.genTaintSubtypeRoll(atmosphere);
				if (!special) {
					const type_c = this.getTaintSubtypeFromRoll(roll_c);
					atmosphere.taints.push(new AtmosphereTaint(type_c, this.genTaintSeverity(atmosphere, type_c), 0));
				} else if (roll_b === 10) {
					const roll_d = this.genTaintSubtypeRoll(atmosphere);
					const type_d = this.getTaintSubtypeFromRoll(roll_d);
					atmosphere.taints.push(new AtmosphereTaint(type_d, this.genTaintSeverity(atmosphere, type_d), 0));
				}
			}
		} else if (!special) {
			const type_a = this.getTaintSubtypeFromRoll(roll_a);
			atmosphere.taints.push(new AtmosphereTaint(type_a, this.genTaintSeverity(atmosphere, type_a), 0));
		}
		// Determine persistence for each Taint
		atmosphere.taints.forEach(taint => taint.persistence = this.genTaintPersistence(atmosphere, taint));
	}

	genTaintSubtypeRoll(atmosphere, n = 1)
	{
		const dm = this.getTaintMod(atmosphere);
		let roll = this.roll(2, 6, dm, 'Atmosphere Taint: Subtype');
		// Special Case: Change duplicate Oxygen taint result (of any kind) to Gas Mix
		if ((roll < 3 || roll > 11) && undefined !== atmosphere.taints.find(t => t.subtype === TAINT_H || t.subtype === TAINT_L)) {
			roll = 7;
		}
		// Special Case: Change Oxygen taint (of any kind) to Gas Mix for any atmosphere type outside the 4-9 range
		if ((roll < 3 || roll > 11) && (atmosphere.type < 3 || atmosphere.type > 9)) {
			roll = 7;
		}
		// Special Case: Low Oxygen taint as the result of a roll reduces PPO to less than 0.1
		if (roll < 3 && atmosphere.ppo >= 0.1) {
			atmosphere.ppo = 0.1 - (0.01 * this.roll(1, 6, 0, 'Atmosphere Taint: new PPO value for Low Oxygen'));
		}
		// Special Case: High Oxygen taint as the result of a roll increases PPO to greater than 0.5
		if (roll > 11 && atmosphere.ppo <= 0.5) {
			atmosphere.ppo = 0.5 + (0.1 * this.roll(1, 6, 0, 'Atmosphere Taint: new PPO value for High Oxygen'));
		}
		return roll;
	}

	getTaintSubtypeFromRoll(roll)
	{
		if (roll < 3) return TAINT_L;
		if (roll > 11) return TAINT_H;
		if (roll === 3 || roll === 11) return TAINT_R;
		if (roll === 4 || roll === 9) return TAINT_B;
		if (roll === 5 || roll === 7) return TAINT_G;
		if (roll === 8) return TAINT_S;
		return TAINT_P;
	}

	getTaintMod(atmosphere)
	{
		let dm = 0;
		// DM-2 for atmosphere type 4
		if (atmosphere.type === 4) dm -= 2;
		// DM+2 for atmosphere type 9
		if (atmosphere.type === 9) dm += 2;
		return dm;
	}

	genTaintSeverity(atmosphere, subtype)
	{
		// Special Case: Low Oxygen severity determined by atmospheric PPO level
		if (subtype === TAINT_L) {
			if (atmosphere.ppo >= 0.09) return 2;
			if (atmosphere.ppo >= 0.08) return 3;
			if (atmosphere.ppo >= 0.06) return 8;
			return 9;
		}
		// Special Case: High Oxygen severity determined by atmospheric PPO level
		if (subtype === TAINT_H) {
			if (atmosphere.ppo < 0.6) return 2;
			if (atmosphere.ppo < 0.7) return 7;
			if (atmosphere.ppo < 0.75) return 8;
			return 9;
		}
		// DM+6 for Insidious atmospheres
		const dm = (atmosphere.type === 12 ? 6 : 0);
		return clamp(this.roll(2, 6, dm, 'Atmospheric Taint: Severity'), 4, 12);
	}

	genTaintPersistence(atmosphere, taint)
	{
		let dm = 0;
		// DM+4 for High and Low Oxygen taints, or DM+6 if Severity 8+
		if (taint.subtype === TAINT_H || taint.subtype === TAINT_L) dm += (taint.severity > 7 ? 6 : 4);
		// DM+6 for Insidious atmospheres
		if (atmosphere.type === 12) dm += 6;
		return clamp(this.roll(2, 6, dm, 'Atmosphere Taint: Persistence'), 2, 9);
	}
}

function clamp(num, min, max)
{
	return Math.min(Math.max(num, min), max);
}

/**
 * @param Number n
 *
 * @param integer p Maximum desired level of precision
 */
function format(n, p)
{
	// Multiplying by 1 trims trailing zeroes after rounding to maximum desired precision
	return 1 * n.toPrecision(p);
}

var rand = () => Math.random();

function getRandomIntInclusive(min, max)
{
	min = Math.ceil(min);
	max = Math.floor(max);
	return Math.floor(rand() * (max - min + 1) + min);
}

/**
 * "Small Fast Counter" PRNG from https://github.com/bryc/code/blob/master/jshash/PRNGs.md
 */
function sfc32(a, b, c, d)
{
	return function() {
		a |= 0; b |= 0; c |= 0; d |= 0; 
		var t = (a + b | 0) + d | 0;
		d = d + 1 | 0;
		a = b ^ b >>> 9;
		b = c + (c << 3) | 0;
		c = c << 21 | c >>> 11;
		c = c + t | 0;
		return (t >>> 0) / 4294967296;
	}
}

function validateUserSeed(value)
{
	if (typeof value !== 'string') throw new SyntaxError('Seed must be a string');
	if (value.length < 3) throw new SyntaxError('Seed must be at least 3 characters in length');
	return value;
}

/**
 * Hash-based seed generator from https://github.com/bryc/code/blob/master/jshash/PRNGs.md
 */
function xmur3(str)
{
	for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)
		h = Math.imul(h ^ str.charCodeAt(i), 3432918353),
		h = h << 13 | h >>> 19;
	return function() {
		h = Math.imul(h ^ h >>> 16, 2246822507),
		h = Math.imul(h ^ h >>> 13, 3266489909);
		return (h ^= h >>> 16) >>> 0;
	}
}

function log(msg)
{
	if (debug) console.log(msg);
}

/**
 * Converts a measurement in AU to Orbit#
 *
 * @param float au Distance in AU (Astronomical Units)
 *
 * @return float Orbit# equivalent
 */
function auToOrbit(au)
{
	const i = ORBIT_AU.findLastIndex((entry) => entry <= au);
	if (i === undefined || i < 0) {
		return 0;
	} else if (i >= 20) {
		return 20;
	}
	const diff = ORBIT_AU[i + 1] - ORBIT_AU[i];
	return i + ((au - ORBIT_AU[i]) / diff);
}

/**
 * Converts an Orbit# into AU
 *
 * @param float orbit Distance as an Orbit#
 *
 * @return float Astronomical Unit (AU) equivalent
 */
function orbitToAU(orbit)
{
	const n = +Math.floor(orbit);
	const f = orbit - n;
	const base = ORBIT_AU[n];
	const next = ORBIT_AU[n + 1];
	const diff = next - base;
	return base + (f * diff);
}

/**
 * @param float orbit The original Orbit#
 * @param float mod The number of Orbit#s to add to or subtract from the original Orbit#
 *
 * @return float the correctly modified Orbit#, accounting for "whole" increments of 0.1 when Orbit# < 1
 */
function getOrbitPlus(orbit, mod)
{
	// Mod > 0, i.e. increasing effective Orbit#
	if (mod > 0) {
		if (orbit < 1) {
			// The number of Orbit#s needed for Orbit# to reach 1.0
			const one_up = 10 * (1 - orbit);
			return (mod < one_up
				? orbit + (0.1 * mod)
				: 1 + (mod - one_up));
		}
		return orbit + mod;
	}
	// Mod < 0, i.e. reducing effective Orbit#
	if (mod < 0) {
		if (orbit + mod >= 1) {
			return orbit + mod;
		}
		return (orbit > 1
			? 1 + (0.1 * (orbit + mod - 1))
			: orbit + (0.1 * mod));
	}
	return orbit;
}

/**
 * @return float The Habitable Zone Center Orbit# (HZCO) based on the given luminosity value
 */
function calculateHabitableCenterZone(luminosity)
{
	return auToOrbit(Math.sqrt(luminosity));
}

/**
 * The HZ extends +/- 1.0 Orbit# around the HZCO, so some portion of it may be accessible even at the edges of the star's allowed Orbit#s
 *
 * @return float The amount of leeway to allow when determining if #isHzcoValid is true
 */
var hzco_fudge = 0;
function getHzcoFudgeFactor()
{
	return hzco_fudge;
}

/**
 * @return string Converts a Roman Numeral to its positive integer equivalent
 * @throws SyntaxError if improperly formatted
 */
function convertFromRoman(roman)
{
	const lookup = {C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1};
	let number = 0;
	for (let i = 0; i < roman.length; i++) {
		let k = roman[i];
		if (k === 'I' && (i+1) < roman.length && ['V','X'].includes(roman[i+1])) {
			k = k + roman[i+1];
			i++;
		}
		if (k === 'X' && (i+1) < roman.length && ['C','L'].includes(roman[i+1])) {
			k = k + roman[i+1];
			i++;
		}
		if (!lookup.hasOwnProperty(k)) {
			throw new SyntaxError('Failed to parse invalid Roman Numeral: ' + roman);
		}
		number += lookup[k];
	}
	return number;
}

/**
 * @return string Converts a positive integer < 399 to its Roman Numeral equivalent
 */
function convertToRoman(number)
{
	const lookup = {C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1};
	let roman = '';
	for (const k in lookup) {
		while (number >= lookup[k]) {
			roman += k;
			number -= lookup[k];
		}
	}
	return roman;
}

/**
 * Converts an eHex code to its corresponding integer value
 */
function fromHexCode(hex)
{
	if (hex.length !== 1) throw new SyntaxError('eHex codes must be exactly 1 character long: ' + hex);
	const code = hex.toUpperCase().codePointAt(0);
	// Digits 0-9
	if (code > 47 && code < 58) return code - 48;
	// Invalid Characters: I, O, any non-uppercase, any non-alphabet
	if (code < 65 || code > 90 || code === 73 || code === 79) throw new SyntaxError('Invalid eHex code: ' + hex);
	// Letters from A-H are 10-17
	if (code < 73) return code - 55;
	// Letters from J-N are 18-22
	if (code < 79) return code - 56;
	// Letters from P-Z are 23-33
	return code - 57;
}

/**
 * Converts an integer of 33 or less to the corresponding hex code used by e.g. UWP
 */
function toHexCode(number)
{
	if (number < 10) return number;
	// Skip the letter 'O'
	if (number > 22) number++;
	// Skip the letter 'I'
	if (number > 17) number++;
	return String.fromCharCode(number + 65 - 10);
}

/**
 * @return float The number rounded to the specified precision
 */
function round(num, precision)
{
	const base = 10 ** precision;
	return (Math.round(num * base) / base);
}

/**
 * @return string The number with its sign
 */
function signed(num)
{
	return (num > 0 ? '+' + num : num);
}

function getStarSystem(data)
{
	const seed = (data.has('seed') && data.get('seed').length > 0
		? validateUserSeed(data.get('seed'))
		: window.crypto.randomUUID().substring(24));
	const seeder = xmur3(seed);
	rand = sfc32(seeder(), seeder(), seeder(), seeder());
	const star_factory = new StarFactory(data);
	const world_factory = new WorldFactory(data);
	const system_factory = new StarSystemFactory(star_factory, world_factory, data, seed);
	const star_profiles = (data.has('system_profile') ? data.get('system_profile').split(':').filter(s => s.length > 0) : []);
	const planetary_profile = (data.has('cont_spp') ? data.getAll('cont_spp').map((s) => s.trim()).map((s) => s.length > 0 ? Number(s) : null) : Array(5).fill(null));
	const main_uwp = data.get('cont_uwp');
	const main_temp = +data.get('cont_temp');
	const main_host = (data.has('cont_host') ? +data.get('cont_host') : null);
	const world_profile = (main_uwp.length > 0 ? new WorldProfile(main_uwp, main_temp, main_host) : null);
	hzco_fudge = (data.has('hzco_fudge') ? +data.get('hzco_fudge') : 0);
	return system_factory.generate(star_profiles, planetary_profile, world_profile);
}

function displayStarSystem(system, data)
{
	const s_body = document.getElementById('star_tbl_entries');
	const s_temp = document.getElementById('star_tbl_template');
	const p_body = document.getElementById('planet_tbl_entries');
	const p_temp = document.getElementById('planet_tbl_template');
	const sub_moons = data.has('sub_moons');
	s_body.replaceChildren();
	p_body.replaceChildren();
	system.star_groups.forEach(group => {
		addStarTableRow(group, s_body, s_temp, system.n_stellar);
		group.bodies.forEach(body => {
			addPlanetTableRow(body, p_body, p_temp, system.n_stellar);
			if (sub_moons) {
				body.bodies.forEach(moon => addPlanetTableRow(moon, p_body, p_temp, system.n_stellar, true, sub_moons));
			}
		});
	});
	if (!sub_moons) {
		system.star_groups.forEach(group => {
			group.bodies.forEach(body => {
				body.bodies.forEach(moon => addPlanetTableRow(moon, p_body, p_temp, system.n_stellar, true, sub_moons));
				
			});
		});
	}
	const basic_temp = data.has('basic_temp');
	document.querySelectorAll('.toggle-basic_temp').forEach((entry) => {
		if (basic_temp) {
			entry.classList.replace('show-table', 'hide');
		} else {
			entry.classList.replace('hide', 'show-table');
		}
	});
	document.getElementById('th_temp_mean').innerHTML = (basic_temp ? 'Temp (C)' : 'Mean (C)');
	const per_star = data.has('per_star_baseline');
	document.querySelectorAll('.toggle-per_star_baseline').forEach((entry) => {
		if (per_star) {
			entry.classList.replace('hide', 'show-table');
		} else {
			entry.classList.replace('show-table', 'hide');
		}
	});
}

function addStarTableRow(entry, body, template, n_stellar = 1)
{
	const clone = template.content.cloneNode(true);
	const row = clone.querySelector('tr');
	const diameter = entry.getTotalDiameter();
	const luminosity = entry.getTotalLuminosity();
	const temperature = entry.getTotalTemperature();
	const independent = (entry.n_bodies > 0 && !entry.isPrimaryComponent());
	let j = 0;
	row.children[j++].innerHTML = entry.getDesignation(n_stellar);
	row.children[j++].innerHTML = entry.getProfileShort();
	row.children[j++].innerHTML = format(entry.getTotalMass(), 3);
	row.children[j++].innerHTML = (diameter < 0 ? '-' : format(diameter, 3));
	row.children[j++].innerHTML = (temperature < 0 ? '-' : temperature.toFixed(1));
	row.children[j++].innerHTML = (luminosity < 0 ? '-' : format(luminosity, 3));
	row.children[j++].innerHTML = entry.getTotalOrbit().toFixed(2) + (entry.orbit_retrograde ? 'R' : '');
	row.children[j++].innerHTML = entry.primary ? '-' : format(entry.orbit_au, 3);
	row.children[j++].innerHTML = entry.primary ? '-' : format(entry.orbit_eccentricity, 3);
	row.children[j++].innerHTML = entry.primary ? '-' : format(entry.orbit_major_min, 3);
	row.children[j++].innerHTML = entry.primary ? '-' : format(entry.orbit_major_max, 3);
	row.children[j++].innerHTML = entry.primary ? '-' : entry.getOrbitalPeriod();
	row.children[j++].innerHTML = entry.isHzcoValid() ? entry.hzco.toFixed(2) : '(' + entry.hzco.toFixed(2) + ')';
	row.children[j++].innerHTML = entry.getAllowedOrbits();
	row.children[j++].innerHTML = entry.orbit_slots;
	row.children[j++].innerHTML = entry.n_bodies + (entry.n_empty > 0 ? ' (' + entry.n_empty + ')' : '');
	row.children[j++].innerHTML = (independent ? entry.baseline_number : '-');
	row.children[j++].innerHTML = (independent ? entry.baseline_orbit : '-');
	row.children[j++].innerHTML = (independent ? entry.getMinimumOrbitSpread() : '-');
	body.appendChild(row);
}

function addPlanetTableRow(entry, body, template, n_stellar = 1, is_moon = false, sub_moons = false)
{
	const clone = template.content.cloneNode(true);
	const row = clone.querySelector('tr');
	const diameter = entry.getTotalDiameter();
	const escape = entry.getEscapeVelocity();
	const mass = entry.getTotalMass();
	let j = 0;
	row.children[j++].innerHTML = (is_moon && sub_moons ? '' : entry.getHostStar().getDesignation(n_stellar));
	if (is_moon && sub_moons) row.children[j].classList.add('right');
	row.children[j++].innerHTML = entry.getDesignation(is_moon && sub_moons ? 0 : 1);
	row.children[j++].innerHTML = (mass > 0 ? format(entry.getTotalMass(), 3) : '-');
	row.children[j++].innerHTML = (diameter > 0 ? round(diameter, 3) + (entry.type === PLANET_GAS ? '&CirclePlus;' : 'km') : '-');
	row.children[j++].innerHTML = (entry.density > 0 ? round(entry.density, 3) : '-');
	row.children[j++].innerHTML = (entry.gravity > 0 ? round(entry.gravity, 3) : '-');
	row.children[j++].innerHTML = (escape > 0 ? round(escape, 3) : '-');
	row.children[j++].innerHTML = (entry.temperature_high === null ? '-' : (entry.temperature_high - 273).toFixed(1));
	row.children[j++].innerHTML = (entry.temperature_mean === null ? '-' : (entry.temperature_mean - 273).toFixed(1));
	row.children[j++].innerHTML = (entry.temperature_low === null ? '-' : (entry.temperature_low - 273).toFixed(1));
	row.children[j++].innerHTML = (entry.albedo < 0 ? '-' : entry.albedo.toFixed(2));
	row.children[j++].innerHTML = entry.getTotalOrbit().toFixed(2) + (entry.orbit_retrograde ? 'R' : '');
	row.children[j++].innerHTML = (is_moon ? 'PD' : format(entry.orbit_au, 3));
	row.children[j++].innerHTML = format(entry.orbit_eccentricity, 3);
	row.children[j++].innerHTML = (is_moon ? '-' : format(entry.orbit_major_min, 3));
	row.children[j++].innerHTML = (is_moon ? '-' : format(entry.orbit_major_max, 3));
	row.children[j++].innerHTML = entry.getOrbitalPeriod();
	row.children[j++].innerHTML = entry.getPeriodSidereal() + (entry.period_sidereal > 0 ? '<br> (' + entry.period_sidereal.toFixed(2) + 'h)' : '');
	row.children[j++].innerHTML = entry.getPeriodSolar() + (entry.period_solar !== null ? '<br> (' + entry.period_solar.toFixed(2) + 'h)' : '');
	row.children[j++].innerHTML = (entry.period_solar !== null ? round(Math.abs(entry.period_solar_year), 2).toLocaleString() : '-');
	row.children[j++].innerHTML = (entry.obliquity > -1 ? entry.obliquity.toFixed(2) + '&deg;' : '-');
	row.children[j++].innerHTML = entry.getProfileShort();
	row.children[j++].innerHTML = (is_moon ? '-' : entry.getSignificantBodyCount());
	row.children[j++].innerHTML = entry.getProfileNotes();
	if (entry.main_candidate) {
		row.classList.add('candidate');
	}
	row.title = 'Main World Candidacy Rating: ' + entry.main_world_rating;
	body.appendChild(row);
}

function buildRollHistoryTable(entry)
{
	const tbl_template = document.getElementById('roll_tbl_template');
	const table = tbl_template.content.cloneNode(true);
	const row_template = document.getElementById('roll_row_template');
	const body = table.querySelector('tbody');
	entry.history.forEach(roll => {
		const clone = row_template.content.cloneNode(true);
		const row = clone.querySelector('tr');
		let j = 0;
		row.children[j++].innerHTML = roll.total;
		row.children[j++].innerHTML = roll.dice();
		row.children[j++].innerHTML = roll.modifier();
		row.children[j++].innerHTML = roll.rolls.join(', ');
		row.children[j++].innerHTML = roll.description;
		body.appendChild(row);
	});
	return table;
}

function displayMainWorldResults(flagger, n_stellar = 1)
{
	const div = document.getElementById('main_world_candidates');
	if (flagger.candidates.length < 1) {
		div.classList.add('hide');
	} else {
		div.classList.remove('hide');
		document.getElementById('main_world_min').innerHTML = (flagger.cutoff + 1);
		const table = document.getElementById('main_world_tbl');
		const body = table.querySelector('tbody');
		const row_template = document.getElementById('main_world_row_template');
		body.replaceChildren();
		flagger.candidates.forEach(entry => {
			const clone = row_template.content.cloneNode(true);
			const row = clone.querySelector('tr');
			let j = 0;
			row.children[j++].innerHTML = entry.main_world_rating;
			row.children[j++].innerHTML = entry.getHostStar().getDesignation(n_stellar);
			row.children[j++].innerHTML = entry.getDesignation(1);
			row.children[j++].innerHTML = entry.getProfileShort();
			row.children[j++].innerHTML = (entry.isInHzco() ? 'Y' : 'N');
			row.children[j++].innerHTML = toHexCode(entry.habitability);
			row.children[j++].innerHTML = toHexCode(entry.resource_rating);
			row.children[j++].innerHTML = toHexCode(Math.max(0, entry.biomass));
			row.children[j++].innerHTML = toHexCode(entry.biocomplexity);
			row.children[j++].innerHTML = toHexCode(entry.biodiversity);
			row.children[j++].innerHTML = toHexCode(entry.biocompatibility);
			row.children[j++].innerHTML = (entry.sophont_presence < 0 ? 'None' : (entry.sophont_presence > 0 ? 'Living' : 'Extinct'));
			row.children[j++].innerHTML = entry.atmosphere.greenhouse_factor.toFixed(3);
			row.children[j++].innerHTML = toHexCode(entry.surface_distribution);
			body.appendChild(row);
		});
	}
}

function toggleShowOptions(event, element, target_id)
{
	event.preventDefault();
	const div = document.getElementById(target_id);
	if (element.innerHTML === 'Show More') {
		element.innerHTML = 'Show Less';
		div.classList.replace('hide', 'show');
	} else {
		element.innerHTML = 'Show More';
		div.classList.replace('show', 'hide');
	}
	return false;
}

window.addEventListener("load", function(event)
{
	document.getElementById('form')?.addEventListener('submit', function(e)
	{
		e.preventDefault();
		const data = new FormData(e.target);
		const err_div = document.getElementById('error');
		err_div.classList.replace('show', 'hide');
		let output = null;
		try {
			output = getStarSystem(data);
		} catch (err) {
			err_div.classList.replace('hide', 'show');
			err_div.innerHTML = err.message;
		}
		if (output instanceof StarSystem) {
			const main_fn = (world) => {
				const refuel = (world.hydrographics < 1 ? -1 : (world.hydrographics > 9 ? 0 : 1));
				const factor = 1 + 0.2 * (refuel + world.sophont_presence);
				return round(factor * (world.habitability + world.resource_rating), 0);
			};
			const main_min = (data.has('main_tier') ? +data.get('main_tier') : 0.85);
			const flagger = new MainWorldFlagger(main_fn, main_min);
			flagger.apply(output.star_groups);
			document.getElementById('system_age').innerHTML = format(output.age, 3) + ' Gyr';
			document.getElementById('system_profile_short').innerHTML = output.getProfileShort();
			document.getElementById('system_profile_long').innerHTML = output.getProfileLong().split(':').join('<br>:');
			document.getElementById('system_seed').innerHTML = output.seed;
			document.getElementById('system_planet_profile_short').innerHTML = output.getPlanetaryProfileShort();
			document.getElementById('baseline_number').innerHTML = output.baseline_number;
			document.getElementById('baseline_orbit').innerHTML = output.baseline_orbit;
			document.getElementById('system_spread').innerHTML = output.getMinimumOrbitSpread();
			document.getElementById('system_spread_calc').innerHTML = output.orbit_spread;
			document.getElementById('system_spread_max').innerHTML = output.orbit_spread_max;
			document.getElementById('n_stellar').innerHTML = output.n_stellar;
			document.getElementById('n_planet_gas').innerHTML = output.n_planet_gas;
			document.getElementById('n_planet_belt').innerHTML = output.n_planet_belt;
			document.getElementById('n_planet_rock').innerHTML = output.n_planet_rock;
			document.getElementById('n_empty').innerHTML = output.n_empty;
			displayStarSystem(output, data);
			displayMainWorldResults(flagger, output.n_stellar);
			// System generation history
			const history = document.getElementById('roll_history');
			history.innerHTML = '';
			history.appendChild(document.createTextNode('ROLL LOG'));
			history.appendChild(document.createElement('hr'));
			history.appendChild(document.createTextNode('Star System Rolls'));
			history.appendChild(buildRollHistoryTable(output));
			// Star generation history
			output.star_groups.forEach(star => {
				if (star.history.length > 0) {
					history.appendChild(document.createElement('hr'));
					history.appendChild(document.createTextNode('Rolls for ' + (star.primary ? 'Primary ' : 'Secondary ') + star.getDesignation(output.n_stellar)));
					history.appendChild(buildRollHistoryTable(star));
				}
				if (star.companion && star.companion.history.length > 0) {
					history.appendChild(document.createElement('hr'));
					history.appendChild(document.createTextNode('Rolls for Companion ' + star.companion.getDesignation(output.n_stellar)));
					history.appendChild(buildRollHistoryTable(star.companion));
				}
			});
			// World generation history
			output.star_groups.forEach(group => {
				group.bodies.forEach(body => {
					if (body.history.length > 0) {
						history.appendChild(document.createElement('hr'));
						history.appendChild(document.createTextNode('Rolls for Planet ' + body.getDesignation(output.n_stellar)));
						history.appendChild(buildRollHistoryTable(body));
					}
				});
			});
			// Moon generation history
			output.star_groups.forEach(group => {
				group.bodies.forEach(body => {
					body.bodies.forEach(moon => {
						if (moon.history.length > 0) {
							history.appendChild(document.createElement('hr'));
							history.appendChild(document.createTextNode('Rolls for Moon ' + moon.getDesignation(output.n_stellar)));
							history.appendChild(buildRollHistoryTable(moon));
						}
					});
				});
			});
		}
	});
});

</script>
