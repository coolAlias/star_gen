<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>Star System Generator</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="robots" content="index, follow">
		<style>
			h1, h2, h3, h4 {
				margin: 0px;
			}
			table {
				border-collapse: collapse;
				margin: 8px 0px 8px 0px;
			}
			table, th, td {
				border: 1px solid;
				padding: 4px;
			}
			thead tr {
				background-color: #E7E9EB;
			}
			tbody tr:nth-child(2n) {
				background-color: #E8E8E8;
			}
			label {
				display: block;
				font-weight: bold;
				padding-bottom: 2px;
			}
			input[type=number], input[type=text] {
				min-width: 4rem;
				padding: 2px;
			}
			input[type=checkbox] {
				display: inline-block;
				transform: scale(1.25);
			}
			button[type=submit] {
				font-size: 1.1rem;
				margin-top: 8px;
				padding: 4px 8px 4px 8px;
			}
			.inline {
				display: inline-block;
			}
			.block {
				display: block;
			}
			.input_container {
				max-width: max-content;
				margin-bottom: 8px;
			}
			.container {
				margin: 8px 0px 8px 0px;
				width: fit-content;
			}
			.flex-row {
				align-items: center;
				display: flex;
				flex-direction: row;
			}
			.flex-row * {
				margin-right: 8px;
			}
			.footnote {
				font-size: 0.8rem;
				font-style: italic;
				margin: 0;
			}
			.show-options {
				margin: 8px;
			}
			.w-60 {
				width: 60%;
			}
			.w-40 {
				width: 40%;
			}
			.w-20 {
				width: 20%;
			}
			.center {
				text-align: center;
			}
			.right {
				text-align: right;
			}
			.small-caps {
				font-variant: small-caps;
			}
			.hide {
				display: none;
				visibility: hidden;
			}
			.show {
				display: block;
				visibility: visible;
			}
			.show-table {
				display: table-cell;
				visibility: visible;
			}
			.text-bold {
				font-weight: bold;
			}
			.text-red {
				color: red;
			}
			.text-sm {
				font-size: 0.9rem;
			}
		</style>
	</head>
	<body style="padding: 5px;">
		<h1 class="small-caps">Star System Generator</h1>
		<form id="form" style="padding-bottom: 5px;" method="get" action="#" accept-charset="utf-8">
			<div class="container w-40">
				<h2>Continuation Method</h2>
				<hr>
				<div id="options_continuation" class="hide">
					<div class="flex-row">
						<div class="input_container">
							<label for="system_profile" class="small-caps">Star Profile(s) <input id="system_profile" class="inline" type="text" name="system_profile" /></label>
						</div>
						<div class="input_container">
							<label for="cont_sec"><input id="cont_sec" name="cont_sec" type="checkbox" /> Check for Secondaries</label>
						</div>
					</div>
					<div class="container">
						<h4 class="small-caps">System Planetary Profile</h4>
						<div class="flex-row">
							<div class="input_container">
								<label>Gas Giants</label>
								<input class="center w-60" name="cont_spp" type="number" min="0" step="1" />
							</div>
							<div class="input_container">
								<label>Belts</label>
								<input class="center w-60" name="cont_spp" type="number" min="0" step="1" />
							</div>
							<div class="input_container">
								<label>Terrestrial</label>
								<input class="center w-60" name="cont_spp" type="number" min="0" step="1" />
							</div>
							<div class="input_container">
								<label>Baseline</label>
								<input class="center w-60" name="cont_spp" type="number" step="1" />
							</div>
							<div class="input_container">
								<label>Spread</label>
								<input class="center w-60" name="cont_spp" type="number" min="0" step="0.001" />
							</div>
						</div>
					</div>
					<p id="error" class="text-bold text-red hide"></p>
				</div>
				<p class="show-options"><a href="#" onclick="return toggleShowOptions(event, this, 'options_continuation')">Show More</a></p>
			</div>
			<div class="container w-40">
				<h2>Standard Options</h2>
				<hr>
				<div class="input_container">
					<label for="star_trad_gen"><input id="star_trad_gen" name="star_trad_gen" type="checkbox" checked /> Traditional Traveller Star Distributions</label>
				</div>
				<div id="options_stellar" class="hide">
					<div class="input_container">
						<label for="prime_main"><input id="prime_main" name="prime_main" type="checkbox" checked /> Primary Star: Main-Sequence Only</label>
					</div>
					<div class="input_container">
						<label for="prime_peculiar">
							<select id="prime_peculiar" class="inline" name="prime_peculiar">
								<option value="0">Fine, the Universe is Weird!</option>
								<option value="1">Roll 1D: 1-5 = NS, 6 = BH</option>
								<option value="2">Reroll Unusual Result</option>
							</select>
							Primary Star: Peculiar Type*
						</label>
						<span class="text-sm">* Only if Primary Star: Main-Sequence Only is NOT checked.</span>
					</div>
					<div class="input_container">
						<label for="star_flat_sub"><input id="star_flat_sub" name="star_flat_sub" type="checkbox" /> Star Subtype: Flat Roll Method</label>
					</div>
					<div class="input_container">
						<label for="var_mass"><input id="var_mass" name="var_mass" type="checkbox" checked /> Enable Variance: Mass</label>
					</div>
					<div class="input_container">
						<label for="var_temp"><input id="var_temp" name="var_temp" type="checkbox" checked /> Enable Variance: Temperature</label>
					</div>
					<div class="input_container">
						<label for="var_size"><input id="var_size" name="var_size" type="checkbox" checked /> Enable Variance: Diameter</label>
					</div>
					<div class="input_container">
						<label for="var_nits"><input id="var_nits" name="var_nits" type="checkbox" /> Enable Variance: Luminosity</label>
					</div>
					<div class="input_container">
						<label for="var_orbit"><input id="var_orbit" name="var_orbit" type="checkbox" checked /> Enable Variance: Orbit#s</label>
					</div>
					<div class="input_container">
						<label for="enable_ecc"><input id="enable_ecc" name="enable_ecc" type="checkbox" checked /> Enable Orbital Eccentricity</label>
					</div>
					<div class="input_container">
						<label for="star_age_small"><input id="star_age_small" name="star_age_small" type="checkbox" checked /> Age, Small Stars: Increase Precision</label>
					</div>
					<div class="input_container">
						<label for="star_age_large"><input id="star_age_large" name="star_age_large" type="checkbox" checked /> Age, Large Stars: Use 1D100/100 instead of ((1D-1)+(1D/6))/6</label>
					</div>
					<div class="input_container">
						<label for="sec_giant_twin">
							<select id="sec_giant_twin" class="inline" name="sec_giant_twin">
								<option value="0">Use Twin method</option>
								<option value="1">Change to Class V</option>
							</select>
							Secondary Giant: if &gt; Primary Giant
						</label>
					</div>
					<div class="input_container">
						<label for="cumulative_orbit"><input id="cumulative_orbit" name="cumulative_orbit" type="checkbox" checked /> Planets: Cumulative Orbital Variance</label>
					</div>
					<div class="input_container">
						<label for="per_star_baseline"><input id="per_star_baseline" name="per_star_baseline" type="checkbox" checked /> Planets: Per-Star Baseline Numbers</label>
					</div>
					<div class="input_container">
						<label for="per_star_empty_orbits"><input id="per_star_empty_orbits" name="per_star_empty_orbits" type="checkbox" checked /> Planets: Per-Star Empty Orbits</label>
					</div>
					<div class="input_container">
						<label for="flat_temp"><input id="flat_temp" name="flat_temp" type="checkbox" checked /> Planets: Use 7+DMs for Temperatures outside the HZ</label>
					</div>
					<div class="input_container">
						<label for="green_check"><input id="green_check" name="green_check" type="checkbox" checked /> Planets: Enable Runaway Greenhouse Effect</label>
					</div>
					<div class="input_container">
						<label for="green_inner"><input id="green_inner" name="green_inner" type="checkbox" checked /> Planets: Enable Runaway Greenhouse for all &lt; HZCO</label>
					</div>
					<div class="input_container">
						<label for="hill_moon_qty"><input id="hill_moon_qty" name="hill_moon_qty" type="checkbox" checked /> Planets: Use Hill Sphere for DM-1 per die to Moon Qty</label>
					</div>
				</div>
				<p class="show-options"><a href="#" onclick="return toggleShowOptions(event, this, 'options_stellar')">Show More</a></p>
			</div>
			<button type="submit" class="small-caps">Generate</button>
		</form>
		<div id="output" class="container">
			<h3 class="small-caps">Star System Data</h3>
			<p><strong>System Age</strong>: <span id="system_age"></span></p>
			<p>
				<strong>System Profile</strong>: <span id="system_profile_short"></span>
				<br>
				<span id="system_profile_long"></span>
			</p>
			<table>
				<thead>
					<tr>
						<th colspan="5">Objects</th>
						<th colspan="5">System Planetary Profile: <span id="system_planet_profile_short"></span></th>
					</tr><tr>
						<th>Stellar</th>
						<th>Gas Giants</th>
						<th>Planetoid Belts</th>
						<th>Terrestrials</th>
						<th>Empty</th>
						<th>Baseline #</th>
						<th>Baseline Orbit#</th>
						<th>System Spread</th>
						<th>Calculated</th>
						<th>Max Spread</th>
					</tr>
				</thead>
				<tbody>
					<td class="center" id="n_stellar">0</td>
					<td class="center" id="n_planet_gas">0</td>
					<td class="center" id="n_planet_belt">0</td>
					<td class="center" id="n_planet_rock">0</td>
					<td class="center" id="n_empty">0</td>
					<td class="center" id="baseline_number"></td>
					<td class="center" id="baseline_orbit"></td>
					<td class="center" id="system_spread"></td>
					<td class="center" id="system_spread_calc"></td>
					<td class="center" id="system_spread_max"></td>
				</tbody>
			</table>
			<table>
				<thead>
					<tr id="star_tbl_header">
						<th>Component</th>
						<th>Class</th>
						<th>Mass &odot;</th>
						<th>Diameter &odot;</th>
						<th>Temp (K)</th>
						<th>Luminosity</th>
						<th>Orbit#*</th>
						<th>AU</th>
						<th>Ecc</th>
						<th>Min</th>
						<th>Max</th>
						<th>Period</th>
						<th>HZCO</th>
						<th>Allowed Orbit#s*</th>
						<th># Slots</th>
						<th># Planets</th>
						<th class="hide toggle-per_star_baseline">Baseline #</th>
						<th class="hide toggle-per_star_baseline">Base Orbit#</th>
						<th class="hide toggle-per_star_baseline">Spread</th>
					</tr>
				</thead>
				<tbody id="star_tbl_entries">
				</tbody>
			</table>
			<p class="footnote right">* Orbit#s are measured from the object being orbited, not necessarily the primary star</p>
			<template id="star_tbl_template">
				<tr>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td class="center"></td>
					<td class="center"></td>
					<td class="center"></td>
					<td class="center"></td>
					<td class="hide center toggle-per_star_baseline"></td>
					<td class="hide center toggle-per_star_baseline"></td>
					<td class="hide center toggle-per_star_baseline"></td>
				<tr>
			</template>
			<table>
				<thead>
					<tr id="planet_tbl_header">
						<th>Primary</th>
						<th>Object</th>
						<th>Mass &CirclePlus;</th>
						<th>Diameter</th>
						<th>Density</th>
						<th>Gravity</th>
						<th>Temp (C)</th>
						<th>Orbit#*</th>
						<th>AU</th>
						<th>Ecc</th>
						<th>Min</th>
						<th>Max</th>
						<th>Period</th>
						<th>SAH/UWP</th>
						<th>Sub</th>
						<th>Notes</th>
					</tr>
				</thead>
				<tbody id="planet_tbl_entries">
				</tbody>
			</table>
			<template id="planet_tbl_template">
				<tr>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
					<td></td>
				<tr>
			</template>
		</div>
		<div id="roll_history" class="container">
		</div>
		<template id="roll_tbl_template">
			<table>
				<thead>
					<tr>
						<th>Result</th>
						<th>Dice</th>
						<th>DM</th>
						<th>Roll(s)</th>
						<th>Description</th>
					</tr>
				</thead>
				<tbody>
				</tbody>
			</table>
		</template>
		<template id="roll_row_template">
			<tr>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
				<td></td>
			<tr>
		</template>
	</body>
</html>
<script>
const debug = true;

// Astronomical Unit, in km
const AU = 149597870.9;

// Radius of Sol in AU
const SOL_RADIUS_AU = 0.00465;

// Diameter of Sol in km, i.e. 1 "standard" stellar unit of Diameter
const SOL_DIAMETER = 1391400;

// Diameter of Terra in km, i.e. 1 "standard" planetary unit of Diameter
const TERRA_DIAMETER = 12742;

// Conversion rate between Terran and Solar units of Diameter
const TERRA_DIAMETER_TO_SOL = 0.009;

// Mass of Terra in kg, i.e. 1 "standard" planetary unit of Mass
const TERRA_MASS = 5.972E24;

// Conversion rate between Terran and Solar units of Mass
const TERRA_MASS_TO_SOL = 0.00000303;

// Density of Terra in g/cm³
const TERRA_DENSITY = 5.514;

// Gravity of Terra in m/s²
const TERRA_GRAVITY = 9.8066;

/** Array Index = whole Orbit# */
const ORBIT_AU = [
	0,
	0.4,
	0.7,
	1.0,
	1.6,
	2.8,
	5.2,
	10,
	20,
	40,
	77,
	154,
	308,
	615,
	1230,
	2500,
	4900,
	9800,
	19500,
	39500,
	78700,
];

// Main Sequence Stars
const MAIN_TYPE_O  =  0;
const MAIN_TYPE_B  =  1;
const MAIN_TYPE_A  =  2;
const MAIN_TYPE_F  =  3;
const MAIN_TYPE_G  =  4;
const MAIN_TYPE_K  =  5;
const MAIN_TYPE_M  =  6;
// Failed Star; includes types L, T, and Y
const BROWN_DWARF  =  8; // See note below on why White Dwarf = 7
// Post-Stellar objects, i.e. dead stars
const WHITE_DWARF  =  7; // Because this is sort of maybe sometimes considered Type VII and in some cases is the next progression
const PULSAR       =  9; // Technically a type of Neutron Star, but listed separately for some reason
const NEUTRON_STAR = 10;
const BLACK_HOLE   = 11;
// Particularly Peculiar Types
const PROTOSTAR    = 12;
const NEBULA       = 13;
const STAR_CLUSTER = 14;
const ANOMALY      = 15;

const STAR_NAME = {
	[MAIN_TYPE_O]: 'Type O',
	[MAIN_TYPE_B]: 'Type B',
	[MAIN_TYPE_A]: 'Type A',
	[MAIN_TYPE_F]: 'Type F',
	[MAIN_TYPE_G]: 'Type G',
	[MAIN_TYPE_K]: 'Type K',
	[MAIN_TYPE_M]: 'Type M',
	[WHITE_DWARF]: 'White Dwarf',
	[BROWN_DWARF]: 'Brown Dwarf',
	[PULSAR]:      'Pulsar',
	[NEUTRON_STAR]:'Neutron Star',
	[BLACK_HOLE]:  'Black Hole',
	[PROTOSTAR]:   'Protostar',
	[NEBULA]:      'Nebula',
	[STAR_CLUSTER]:'Star Cluster',
	[ANOMALY]:     'Anomaly',
};

const STAR_TYPE = {
	[MAIN_TYPE_O]: 'O',
	[MAIN_TYPE_B]: 'B',
	[MAIN_TYPE_A]: 'A',
	[MAIN_TYPE_F]: 'F',
	[MAIN_TYPE_G]: 'G',
	[MAIN_TYPE_K]: 'K',
	[MAIN_TYPE_M]: 'M',
	[WHITE_DWARF]: 'D', 
	[BROWN_DWARF]: 'BD', 
	[PULSAR]:      'PSR',
	[NEUTRON_STAR]:'NS',
	[BLACK_HOLE]:  'BH',
	[PROTOSTAR]:   'P',
	[NEBULA]:      'N',
	[STAR_CLUSTER]:'SC',
	[ANOMALY]:     'X',
};

const TYPE_HOT = {
	 2: MAIN_TYPE_A,
	 3: MAIN_TYPE_A,
	 4: MAIN_TYPE_A,
	 5: MAIN_TYPE_A,
	 6: MAIN_TYPE_A,
	 7: MAIN_TYPE_A,
	 8: MAIN_TYPE_A,
	 9: MAIN_TYPE_A,
	10: MAIN_TYPE_B,
	11: MAIN_TYPE_B,
	12: MAIN_TYPE_O,
};

const TYPE_PECULIAR = {
	 2: BLACK_HOLE,
	 3: PULSAR,
	 4: NEUTRON_STAR,
	 5: NEBULA,
	 6: NEBULA,
	 7: PROTOSTAR,
	 8: PROTOSTAR,
	 9: PROTOSTAR,
	10: STAR_CLUSTER,
	11: ANOMALY,
	12: ANOMALY,
};

const TYPE_REAL = {
	 2: -1, // roll on Special or, if allowed, Unusual
	 3: MAIN_TYPE_M,
	 4: MAIN_TYPE_M,
	 5: MAIN_TYPE_M,
	 6: MAIN_TYPE_M,
	 7: MAIN_TYPE_M,
	 8: MAIN_TYPE_M,
	 9: MAIN_TYPE_K,
	10: MAIN_TYPE_G,
	11: MAIN_TYPE_F,
	12: 16, // Roll on Hot
	13: 16, // Roll on Hot
};

const TYPE_TRAD = {
	 2: -1, // roll on Special or, if allowed, Unusual
	 3: MAIN_TYPE_M,
	 4: MAIN_TYPE_M,
	 5: MAIN_TYPE_M,
	 6: MAIN_TYPE_M,
	 7: MAIN_TYPE_K,
	 8: MAIN_TYPE_K,
	 9: MAIN_TYPE_G,
	10: MAIN_TYPE_G,
	11: MAIN_TYPE_F,
	12: 16, // Roll on Hot
	13: 16, // Roll on Hot
};

const STAR_CLASS = {
	// 0, Ia+, and Iab are not included at this time
	0: 'Ia',
	1: 'Ib',
	2: 'II',
	3: 'III',
	4: 'IV',
	5: 'V',
	6: 'VI',
	// Special cases used temporarily during generation; they ultimately use -1 as their Classification
	[WHITE_DWARF]: 'D',
	[BROWN_DWARF]: 'BD',
};

const CLASS_GIANT = {
	 2: 3,
	 3: 3,
	 4: 3,
	 5: 3,
	 6: 3,
	 7: 3,
	 8: 3,
	 9: 2,
	10: 2,
	11: 1,
	12: 0,
};

const CLASS_SPECIAL = {
	 2:  6,
	 3:  6,
	 4:  6,
	 5:  6,
	 6:  4,
	 7:  4,
	 8:  4,
	 9:  3,
	10:  3,
	11: 16, // roll on Giant
	12: 16, // roll on Giant
};

const CLASS_UNUSUAL = {
	 2: -1, // roll on Peculiar (returns a Type instead of Class)
	 3:  6, // Class VI
	 4:  4, // Class IV
	 5:  BROWN_DWARF,
	 6:  BROWN_DWARF,
	 7:  BROWN_DWARF,
	 8:  WHITE_DWARF,
	 9:  WHITE_DWARF,
	10:  WHITE_DWARF,
	11:  3, // Class III
	12: 16, // roll on Giant
};

const SUBTYPE_M_PRIMARY = {
	 2: 8,
	 3: 6,
	 4: 5,
	 5: 4,
	 6: 0,
	 7: 2,
	 8: 1,
	 9: 3,
	10: 5,
	11: 7,
	12: 9,
};

const SUBTYPE_NUMERIC = {
	 2: 0,
	 3: 1,
	 4: 3,
	 5: 5,
	 6: 7,
	 7: 9,
	 8: 8,
	 9: 6,
	10: 4,
	11: 2,
	12: 0,
};

// [Type][Class][Subtype]['M': Mass, 'T': Temperature, 'L': Luminosity', 'D': Diameter]
const STAR_DATA = {
	0: {
		0: {
			0: {'M': 200, 'T': 50000, 'L': 3400000, 'D': 25.0,},
			1: {'M': 176, 'T': 48000, 'L': 2940000, 'D': 24.4,},
			2: {'M': 152, 'T': 46000, 'L': 2480000, 'D': 23.8,},
			3: {'M': 128, 'T': 44000, 'L': 2020000, 'D': 23.2,},
			4: {'M': 104, 'T': 42000, 'L': 1560000, 'D': 22.6,},
			5: {'M':  80, 'T': 40000, 'L': 1100000, 'D': 22.0,},
			6: {'M':  76, 'T': 38000, 'L':  938000, 'D': 21.6,},
			7: {'M':  72, 'T': 36000, 'L':  776000, 'D': 21.2,},
			8: {'M':  68, 'T': 34000, 'L':  614000, 'D': 20.8,},
			9: {'M':  64, 'T': 32000, 'L':  452000, 'D': 20.4,},
		},
		1: {
			0: {'M': 150, 'T': 50000, 'L': 3200000, 'D': 24.0,},
			1: {'M': 132, 'T': 48000, 'L': 2740000, 'D': 23.2,},
			2: {'M': 114, 'T': 46000, 'L': 2280000, 'D': 22.4,},
			3: {'M':  96, 'T': 44000, 'L': 1820000, 'D': 21.6,},
			4: {'M':  78, 'T': 42000, 'L': 1360000, 'D': 20.8,},
			5: {'M':  60, 'T': 40000, 'L':  900000, 'D': 20.0,},
			6: {'M':  56, 'T': 38000, 'L':  748000, 'D': 18.8,},
			7: {'M':  52, 'T': 36000, 'L':  596000, 'D': 17.6,},
			8: {'M':  48, 'T': 34000, 'L':  444000, 'D': 16.4,},
			9: {'M':  44, 'T': 32000, 'L':  292000, 'D': 15.2,},
		},
		2: {
			0: {'M': 130, 'T': 50000, 'L': 2700000, 'D': 22.0,},
			1: {'M': 112, 'T': 48000, 'L': 2306000, 'D': 21.2,},
			2: {'M':  94, 'T': 46000, 'L': 1912000, 'D': 20.4,},
			3: {'M':  76, 'T': 44000, 'L': 1518000, 'D': 19.6,},
			4: {'M':  58, 'T': 42000, 'L': 1124000, 'D': 18.8,},
			5: {'M':  40, 'T': 40000, 'L':  730000, 'D': 18.0,},
			6: {'M':  38, 'T': 38000, 'L':  604000, 'D': 16.8,},
			7: {'M':  36, 'T': 36000, 'L':  478000, 'D': 15.6,},
			8: {'M':  34, 'T': 34000, 'L':  352000, 'D': 14.4,},
			9: {'M':  32, 'T': 32000, 'L':  226000, 'D': 13.2,},
		},
		3: {
			0: {'M': 110, 'T': 50000, 'L': 2400000, 'D': 21.0,},
			1: {'M':  94, 'T': 48000, 'L': 2022000, 'D': 19.8,},
			2: {'M':  78, 'T': 46000, 'L': 1644000, 'D': 18.6,},
			3: {'M':  62, 'T': 44000, 'L': 1266000, 'D': 17.4,},
			4: {'M':  46, 'T': 42000, 'L':  888000, 'D': 16.2,},
			5: {'M':  30, 'T': 40000, 'L':  510000, 'D': 15.0,},
			6: {'M':  28, 'T': 38000, 'L':  422400, 'D': 14.0,},
			7: {'M':  26, 'T': 36000, 'L':  334800, 'D': 13.0,},
			8: {'M':  24, 'T': 34000, 'L':  247200, 'D': 12.0,},
			9: {'M':  22, 'T': 32000, 'L':  159600, 'D': 11.0,},
		},
		4: {
			// N/A
		},
		5: {
			0: {'M': 90.0, 'T': 50000, 'L': 2200000, 'D': 20.0,},
			1: {'M': 84.0, 'T': 48000, 'L': 1826000, 'D': 18.4,},
			2: {'M': 78.0, 'T': 46000, 'L': 1452000, 'D': 16.8,},
			3: {'M': 72.0, 'T': 44000, 'L': 1078000, 'D': 15.2,},
			4: {'M': 66.0, 'T': 42000, 'L':  704000, 'D': 13.6,},
			5: {'M': 60.0, 'T': 40000, 'L':  330000, 'D': 12.0,},
			6: {'M': 51.6, 'T': 38000, 'L':  271000, 'D': 11.0,},
			7: {'M': 43.2, 'T': 36000, 'L':  212000, 'D': 10.0,},
			8: {'M': 34.8, 'T': 34000, 'L':  153000, 'D':  9.0,},
			9: {'M': 26.4, 'T': 32000, 'L':   94000, 'D':  8.0,},
		},
		6: {
			0: {'M': 2.0, 'T': 50000, 'L': 180.0, 'D': 0.180,},
			1: {'M': 1.9, 'T': 48000, 'L': 158.6, 'D': 0.180,},
			2: {'M': 1.8, 'T': 46000, 'L': 137.2, 'D': 0.180,},
			3: {'M': 1.7, 'T': 44000, 'L': 115.8, 'D': 0.180,},
			4: {'M': 1.6, 'T': 42000, 'L':  94.4, 'D': 0.180,},
			5: {'M': 1.5, 'T': 40000, 'L':  73.0, 'D': 0.180,},
			6: {'M': 1.3, 'T': 38000, 'L':  64.2, 'D': 0.184,},
			7: {'M': 1.1, 'T': 36000, 'L':  55.4, 'D': 0.188,},
			8: {'M': 0.9, 'T': 34000, 'L':  46.6, 'D': 0.192,},
			9: {'M': 0.7, 'T': 32000, 'L':  37.8, 'D': 0.196,},
		},
	},
	1: {
		0: {
			0: {'M': 60, 'T': 30000, 'L': 290000, 'D':  20,},
			1: {'M': 54, 'T': 27000, 'L': 264000, 'D':  28,},
			2: {'M': 48, 'T': 24000, 'L': 238000, 'D':  36,},
			3: {'M': 42, 'T': 21000, 'L': 212000, 'D':  44,},
			4: {'M': 36, 'T': 18000, 'L': 186000, 'D':  52,},
			5: {'M': 30, 'T': 15000, 'L': 160000, 'D':  60,},
			6: {'M': 28, 'T': 14000, 'L': 154000, 'D':  72,},
			7: {'M': 26, 'T': 13000, 'L': 148000, 'D':  84,},
			8: {'M': 24, 'T': 12000, 'L': 142000, 'D':  96,},
			9: {'M': 22, 'T': 11000, 'L': 136000, 'D': 108,},
		},
		1: {
			0: {'M': 40, 'T': 30000, 'L': 140000, 'D': 14.0,},
			1: {'M': 37, 'T': 27000, 'L': 117600, 'D': 16.2,},
			2: {'M': 34, 'T': 24000, 'L':  95200, 'D': 18.4,},
			3: {'M': 31, 'T': 21000, 'L':  72800, 'D': 20.6,},
			4: {'M': 28, 'T': 18000, 'L':  50400, 'D': 22.8,},
			5: {'M': 25, 'T': 15000, 'L':  28000, 'D': 25.0,},
			6: {'M': 23, 'T': 14000, 'L':  26800, 'D': 30.0,},
			7: {'M': 21, 'T': 13000, 'L':  25600, 'D': 35.0,},
			8: {'M': 19, 'T': 12000, 'L':  24400, 'D': 40.0,},
			9: {'M': 17, 'T': 11000, 'L':  23200, 'D': 45.0,},
		},
		2: {
			0: {'M': 30.0, 'T': 30000, 'L': 100000, 'D': 12.0,},
			1: {'M': 28.0, 'T': 27000, 'L':  81760, 'D': 12.4,},
			2: {'M': 26.0, 'T': 24000, 'L':  63520, 'D': 12.8,},
			3: {'M': 24.0, 'T': 21000, 'L':  45280, 'D': 13.2,},
			4: {'M': 22.0, 'T': 18000, 'L':  27040, 'D': 13.6,},
			5: {'M': 20.0, 'T': 15000, 'L':   8800, 'D': 14.0,},
			6: {'M': 18.8, 'T': 14000, 'L':   8640, 'D': 17.2,},
			7: {'M': 17.6, 'T': 13000, 'L':   8480, 'D': 20.4,},
			8: {'M': 16.4, 'T': 12000, 'L':   8320, 'D': 23.6,},
			9: {'M': 15.2, 'T': 11000, 'L':   8160, 'D': 26.8,},
		},
		3: {
			0: {'M': 20.0, 'T': 30000, 'L': 72000, 'D': 10.0,},
			1: {'M': 18.0, 'T': 27000, 'L': 57920, 'D':  9.2,},
			2: {'M': 16.0, 'T': 24000, 'L': 43840, 'D':  8.4,},
			3: {'M': 14.0, 'T': 21000, 'L': 29760, 'D':  7.6,},
			4: {'M': 12.0, 'T': 18000, 'L': 15680, 'D':  6.8,},
			5: {'M': 10.0, 'T': 15000, 'L':  1600, 'D':  6.0,},
			6: {'M':  9.6, 'T': 14000, 'L':  1324, 'D':  5.8,},
			7: {'M':  9.2, 'T': 13000, 'L':  1048, 'D':  5.6,},
			8: {'M':  8.8, 'T': 12000, 'L':   772, 'D':  5.4,},
			9: {'M':  8.4, 'T': 11000, 'L':   496, 'D':  5.2,},
		},
		4: {
			0: {'M': 20.0, 'T': 30000, 'L': 46000, 'D': 8.0,},
			1: {'M': 18.0, 'T': 27000, 'L': 37020, 'D': 7.4,},
			2: {'M': 16.0, 'T': 24000, 'L': 28040, 'D': 6.8,},
			3: {'M': 14.0, 'T': 21000, 'L': 19060, 'D': 6.2,},
			4: {'M': 12.0, 'T': 18000, 'L': 10080, 'D': 5.6,},
			5: {'M': 10.0, 'T': 15000, 'L':  1100, 'D': 5.0,},
			6: {'M':  8.8, 'T': 14000, 'L':   908, 'D': 4.8,},
			7: {'M':  7.6, 'T': 13000, 'L':   716, 'D': 4.6,},
			8: {'M':  6.4, 'T': 12000, 'L':   524, 'D': 4.4,},
			9: {'M':  5.2, 'T': 11000, 'L':   332, 'D': 4.2,},
		},
		5: {
			0: {'M': 18.00, 'T': 30000, 'L': 35000.0, 'D': 7.00,},
			1: {'M': 15.40, 'T': 27000, 'L': 28110.0, 'D': 6.30,},
			2: {'M': 12.80, 'T': 24000, 'L': 21220.0, 'D': 5.60,},
			3: {'M': 10.20, 'T': 21000, 'L': 14330.0, 'D': 4.90,},
			4: {'M':  7.60, 'T': 18000, 'L':  7440.0, 'D': 4.20,},
			5: {'M':  5.00, 'T': 15000, 'L':   550.0, 'D': 3.50,},
			6: {'M':  4.44, 'T': 14000, 'L':   448.6, 'D': 3.24,},
			7: {'M':  3.88, 'T': 13000, 'L':   347.2, 'D': 2.98,},
			8: {'M':  3.32, 'T': 12000, 'L':   245.8, 'D': 2.72,},
			9: {'M':  2.76, 'T': 11000, 'L':   144.4, 'D': 2.46,},
		},
		6: {
			0: {'M': 0.50, 'T': 30000, 'L': 29.0, 'D': 0.20,},
			1: {'M': 0.48, 'T': 27000, 'L': 25.4, 'D': 0.26,},
			2: {'M': 0.46, 'T': 24000, 'L': 21.8, 'D': 0.32,},
			3: {'M': 0.44, 'T': 21000, 'L': 18.2, 'D': 0.38,},
			4: {'M': 0.42, 'T': 18000, 'L': 14.6, 'D': 0.44,},
			// Since there is no A0 VI, M and D were interpolated assuming a similar delta from B5 to B9 as from B0 to B5
			5: {'M': 0.40, 'T': 15000, 'L': 11.0, 'D': 0.50,},
			6: {'M': 0.38, 'T': 14000, 'L':  9.0, 'D': 0.56,},
			7: {'M': 0.36, 'T': 13000, 'L':  7.0, 'D': 0.62,},
			8: {'M': 0.34, 'T': 12000, 'L':  5.0, 'D': 0.68,},
			9: {'M': 0.32, 'T': 11000, 'L':  3.0, 'D': 0.74,},
		},
	},
	2: {
		0: {
			0: {'M': 20.0, 'T': 10000, 'L': 130000, 'D': 120,},
			1: {'M': 19.0, 'T':  9600, 'L': 128000, 'D': 132,},
			2: {'M': 18.0, 'T':  9200, 'L': 126000, 'D': 144,},
			3: {'M': 17.0, 'T':  8800, 'L': 124000, 'D': 156,},
			4: {'M': 16.0, 'T':  8400, 'L': 122000, 'D': 168,},
			5: {'M': 15.0, 'T':  8000, 'L': 120000, 'D': 180,},
			6: {'M': 14.6, 'T':  7900, 'L': 120000, 'D': 186,},
			7: {'M': 14.2, 'T':  7800, 'L': 120000, 'D': 192,},
			8: {'M': 13.8, 'T':  7700, 'L': 120000, 'D': 198,},
			9: {'M': 13.4, 'T':  7600, 'L': 120000, 'D': 204,},
		},
		1: {
			0: {'M': 15.0, 'T': 10000, 'L': 22000, 'D': 50,},
			1: {'M': 14.6, 'T':  9600, 'L': 21600, 'D': 55,},
			2: {'M': 14.2, 'T':  9200, 'L': 21200, 'D': 60,},
			3: {'M': 13.8, 'T':  8800, 'L': 20800, 'D': 65,},
			4: {'M': 13.4, 'T':  8400, 'L': 20400, 'D': 70,},
			5: {'M': 13.0, 'T':  8000, 'L': 20000, 'D': 75,},
			6: {'M': 12.8, 'T':  7900, 'L': 20000, 'D': 77,},
			7: {'M': 12.6, 'T':  7800, 'L': 20000, 'D': 79,},
			8: {'M': 12.4, 'T':  7700, 'L': 20000, 'D': 81,},
			9: {'M': 12.2, 'T':  7600, 'L': 20000, 'D': 83,},
		},
		2: {
			0: {'M': 14.0, 'T': 10000, 'L': 8000, 'D': 30,},
			1: {'M': 13.4, 'T':  9600, 'L': 7860, 'D': 33,},
			2: {'M': 12.8, 'T':  9200, 'L': 7720, 'D': 36,},
			3: {'M': 12.2, 'T':  8800, 'L': 7580, 'D': 39,},
			4: {'M': 11.6, 'T':  8400, 'L': 7440, 'D': 42,},
			5: {'M': 11.0, 'T':  8000, 'L': 7300, 'D': 45,},
			6: {'M': 10.8, 'T':  7900, 'L': 7240, 'D': 46,},
			7: {'M': 10.6, 'T':  7800, 'L': 7180, 'D': 47,},
			8: {'M': 10.4, 'T':  7700, 'L': 7120, 'D': 48,},
			9: {'M': 10.2, 'T':  7600, 'L': 7060, 'D': 49,},
		},
		3: {
			0: {'M': 8.0, 'T': 10000, 'L': 220, 'D': 5,},
			1: {'M': 7.6, 'T':  9600, 'L': 194, 'D': 5,},
			2: {'M': 7.2, 'T':  9200, 'L': 168, 'D': 5,},
			3: {'M': 6.8, 'T':  8800, 'L': 142, 'D': 5,},
			4: {'M': 6.4, 'T':  8400, 'L': 116, 'D': 5,},
			5: {'M': 6.0, 'T':  8000, 'L':  90, 'D': 5,},
			6: {'M': 5.6, 'T':  7900, 'L':  86, 'D': 5,},
			7: {'M': 5.2, 'T':  7800, 'L':  82, 'D': 5,},
			8: {'M': 4.8, 'T':  7700, 'L':  78, 'D': 5,},
			9: {'M': 4.4, 'T':  7600, 'L':  74, 'D': 5,},
		},
		4: {
			0: {'M': 4.00, 'T': 10000, 'L': 140.0, 'D': 4.0,},
			1: {'M': 3.66, 'T':  9600, 'L': 118.6, 'D': 3.8,},
			2: {'M': 3.32, 'T':  9200, 'L':  97.2, 'D': 3.6,},
			3: {'M': 2.98, 'T':  8800, 'L':  75.8, 'D': 3.4,},
			4: {'M': 2.64, 'T':  8400, 'L':  54.4, 'D': 3.2,},
			5: {'M': 2.30, 'T':  8000, 'L':  33.0, 'D': 3.0,},
			6: {'M': 2.24, 'T':  7900, 'L':  31.4, 'D': 3.0,},
			7: {'M': 2.18, 'T':  7800, 'L':  29.8, 'D': 3.0,},
			8: {'M': 2.12, 'T':  7700, 'L':  28.2, 'D': 3.0,},
			9: {'M': 2.06, 'T':  7600, 'L':  26.6, 'D': 3.0,},
		},
		5: {
			0: {'M': 2.20, 'T': 10000, 'L': 43.00, 'D': 2.20,},
			1: {'M': 2.12, 'T':  9600, 'L': 37.40, 'D': 2.16,},
			2: {'M': 2.04, 'T':  9200, 'L': 31.80, 'D': 2.12,},
			3: {'M': 1.96, 'T':  8800, 'L': 26.20, 'D': 2.08,},
			4: {'M': 1.88, 'T':  8400, 'L': 20.60, 'D': 2.04,},
			5: {'M': 1.80, 'T':  8000, 'L': 15.00, 'D': 2.00,},
			6: {'M': 1.74, 'T':  7900, 'L': 13.62, 'D': 1.94,},
			7: {'M': 1.68, 'T':  7800, 'L': 12.24, 'D': 1.88,},
			8: {'M': 1.62, 'T':  7700, 'L': 10.86, 'D': 1.82,},
			9: {'M': 1.56, 'T':  7600, 'L':  9.48, 'D': 1.76,},
		},
		6: {
			// N/A
		},
	},
	3: {
		0: {
			0: {'M': 13.0, 'T': 7500, 'L': 120000, 'D': 210,},
			1: {'M': 12.8, 'T': 7300, 'L': 120000, 'D': 224,},
			2: {'M': 12.6, 'T': 7100, 'L': 120000, 'D': 238,},
			3: {'M': 12.4, 'T': 6900, 'L': 120000, 'D': 252,},
			4: {'M': 12.2, 'T': 6700, 'L': 120000, 'D': 266,},
			5: {'M': 12.0, 'T': 6500, 'L': 120000, 'D': 280,},
			6: {'M': 12.0, 'T': 6400, 'L': 120000, 'D': 290,},
			7: {'M': 12.0, 'T': 6300, 'L': 120000, 'D': 300,},
			8: {'M': 12.0, 'T': 6200, 'L': 120000, 'D': 310,},
			9: {'M': 12.0, 'T': 6100, 'L': 120000, 'D': 320,},
		},
		1: {
			0: {'M': 12.0, 'T': 7500, 'L': 20000, 'D':  85,},
			1: {'M': 11.6, 'T': 7300, 'L': 20000, 'D':  91,},
			2: {'M': 11.2, 'T': 7100, 'L': 20000, 'D':  97,},
			3: {'M': 10.8, 'T': 6900, 'L': 20000, 'D': 103,},
			4: {'M': 10.4, 'T': 6700, 'L': 20000, 'D': 109,},
			5: {'M': 10.0, 'T': 6500, 'L': 20000, 'D': 115,},
			6: {'M': 10.0, 'T': 6400, 'L': 20000, 'D': 119,},
			7: {'M': 10.0, 'T': 6300, 'L': 20000, 'D': 123,},
			8: {'M': 10.0, 'T': 6200, 'L': 20000, 'D': 127,},
			9: {'M': 10.0, 'T': 6100, 'L': 20000, 'D': 131,},
		},
		2: {
			0: {'M': 10.0, 'T': 7500, 'L': 7000, 'D': 50.0,},
			1: {'M':  9.6, 'T': 7300, 'L': 6980, 'D': 53.2,},
			2: {'M':  9.2, 'T': 7100, 'L': 6960, 'D': 56.4,},
			3: {'M':  8.8, 'T': 6900, 'L': 6940, 'D': 59.6,},
			4: {'M':  8.4, 'T': 6700, 'L': 6920, 'D': 62.8,},
			5: {'M':  8.0, 'T': 6500, 'L': 6900, 'D': 66.0,},
			6: {'M':  8.0, 'T': 6400, 'L': 6880, 'D': 68.2,},
			7: {'M':  8.0, 'T': 6300, 'L': 6860, 'D': 70.4,},
			8: {'M':  8.0, 'T': 6200, 'L': 6840, 'D': 72.6,},
			9: {'M':  8.0, 'T': 6100, 'L': 6820, 'D': 74.8,},
		},
		3: {
			0: {'M': 4.0, 'T': 7500, 'L':  70.0, 'D': 5,},
			1: {'M': 3.8, 'T': 7300, 'L':  63.8, 'D': 5,},
			2: {'M': 3.6, 'T': 7100, 'L':  57.6, 'D': 5,},
			3: {'M': 3.4, 'T': 6900, 'L':  51.4, 'D': 5,},
			4: {'M': 3.2, 'T': 6700, 'L':  45.2, 'D': 5,},
			5: {'M': 3.0, 'T': 6500, 'L':  39.0, 'D': 5,},
			6: {'M': 2.9, 'T': 6400, 'L':  55.2, 'D': 6,},
			7: {'M': 2.8, 'T': 6300, 'L':  71.4, 'D': 7,},
			8: {'M': 2.7, 'T': 6200, 'L':  87.6, 'D': 8,},
			9: {'M': 2.6, 'T': 6100, 'L': 103.8, 'D': 9,},
		},
		4: {
			0: {'M': 2.00, 'T': 7500, 'L': 25.0, 'D': 3.0,},
			1: {'M': 1.90, 'T': 7300, 'L': 21.2, 'D': 2.8,},
			2: {'M': 1.80, 'T': 7100, 'L': 17.4, 'D': 2.6,},
			3: {'M': 1.70, 'T': 6900, 'L': 13.6, 'D': 2.4,},
			4: {'M': 1.60, 'T': 6700, 'L':  9.8, 'D': 2.2,},
			5: {'M': 1.50, 'T': 6500, 'L':  6.0, 'D': 2.0,},
			6: {'M': 1.54, 'T': 6400, 'L':  6.8, 'D': 2.2,},
			7: {'M': 1.58, 'T': 6300, 'L':  7.6, 'D': 2.4,},
			8: {'M': 1.62, 'T': 6200, 'L':  8.4, 'D': 2.6,},
			9: {'M': 1.66, 'T': 6100, 'L':  9.2, 'D': 2.8,},
		},
		5: {
			0: {'M': 1.50, 'T': 7500, 'L': 8.10, 'D': 1.70,},
			1: {'M': 1.46, 'T': 7300, 'L': 7.18, 'D': 1.66,},
			2: {'M': 1.42, 'T': 7100, 'L': 6.26, 'D': 1.62,},
			3: {'M': 1.38, 'T': 6900, 'L': 5.34, 'D': 1.58,},
			4: {'M': 1.34, 'T': 6700, 'L': 4.42, 'D': 1.54,},
			5: {'M': 1.30, 'T': 6500, 'L': 3.50, 'D': 1.50,},
			6: {'M': 1.26, 'T': 6400, 'L': 3.08, 'D': 1.42,},
			7: {'M': 1.22, 'T': 6300, 'L': 2.66, 'D': 1.34,},
			8: {'M': 1.18, 'T': 6200, 'L': 2.24, 'D': 1.26,},
			9: {'M': 1.14, 'T': 6100, 'L': 1.82, 'D': 1.18,},
		},
		6: {
			// N/A
		},
	},
	4: {
		0: {
			0: {'M': 12.0, 'T': 6000, 'L': 120000, 'D': 330,},
			1: {'M': 12.2, 'T': 5920, 'L': 118000, 'D': 336,},
			2: {'M': 12.4, 'T': 5840, 'L': 116000, 'D': 342,},
			3: {'M': 12.6, 'T': 5760, 'L': 114000, 'D': 348,},
			4: {'M': 12.8, 'T': 5680, 'L': 112000, 'D': 354,},
			5: {'M': 13.0, 'T': 5600, 'L': 110000, 'D': 360,},
			6: {'M': 13.2, 'T': 5520, 'L': 110000, 'D': 372,},
			7: {'M': 13.4, 'T': 5440, 'L': 110000, 'D': 384,},
			8: {'M': 13.6, 'T': 5360, 'L': 110000, 'D': 396,},
			9: {'M': 13.8, 'T': 5280, 'L': 110000, 'D': 408,},
		},
		1: {
			0: {'M': 10.0, 'T': 6000, 'L': 20000, 'D': 135,},
			1: {'M': 10.2, 'T': 5920, 'L': 20000, 'D': 138,},
			2: {'M': 10.4, 'T': 5840, 'L': 20000, 'D': 141,},
			3: {'M': 10.6, 'T': 5760, 'L': 20000, 'D': 144,},
			4: {'M': 10.8, 'T': 5680, 'L': 20000, 'D': 147,},
			5: {'M': 11.0, 'T': 5600, 'L': 20000, 'D': 150,},
			6: {'M': 11.2, 'T': 5520, 'L': 20200, 'D': 156,},
			7: {'M': 11.4, 'T': 5440, 'L': 20400, 'D': 162,},
			8: {'M': 11.6, 'T': 5360, 'L': 20600, 'D': 168,},
			9: {'M': 11.8, 'T': 5280, 'L': 20800, 'D': 174,},
		},
		2: {
			0: {'M':  8.0, 'T': 6000, 'L': 6800, 'D':  77.0,},
			1: {'M':  8.4, 'T': 5920, 'L': 6840, 'D':  79.6,},
			2: {'M':  8.8, 'T': 5840, 'L': 6880, 'D':  82.2,},
			3: {'M':  9.2, 'T': 5760, 'L': 6920, 'D':  84.8,},
			4: {'M':  9.6, 'T': 5680, 'L': 6960, 'D':  87.4,},
			5: {'M': 10.0, 'T': 5600, 'L': 7000, 'D':  90.0,},
			6: {'M': 10.0, 'T': 5520, 'L': 7160, 'D':  94.0,},
			7: {'M': 10.0, 'T': 5440, 'L': 7320, 'D':  98.0,},
			8: {'M': 10.0, 'T': 5360, 'L': 7480, 'D': 102.0,},
			9: {'M': 10.0, 'T': 5280, 'L': 7640, 'D': 106.0,},
		},
		3: {
			0: {'M': 2.50, 'T': 6000, 'L': 120, 'D': 10,},
			1: {'M': 2.48, 'T': 5920, 'L': 136, 'D': 11,},
			2: {'M': 2.46, 'T': 5840, 'L': 152, 'D': 12,},
			3: {'M': 2.44, 'T': 5760, 'L': 168, 'D': 13,},
			4: {'M': 2.42, 'T': 5680, 'L': 184, 'D': 14,},
			5: {'M': 2.40, 'T': 5600, 'L': 200, 'D': 15,},
			6: {'M': 2.14, 'T': 5520, 'L': 212, 'D': 16,},
			7: {'M': 1.88, 'T': 5440, 'L': 224, 'D': 17,},
			8: {'M': 1.62, 'T': 5360, 'L': 236, 'D': 18,},
			9: {'M': 1.36, 'T': 5280, 'L': 248, 'D': 19,},
		},
		4: {
			0: {'M': 1.70, 'T': 6000, 'L': 10.0, 'D': 3.0,},
			1: {'M': 1.60, 'T': 5920, 'L': 10.8, 'D': 3.2,},
			2: {'M': 1.50, 'T': 5840, 'L': 11.6, 'D': 3.4,},
			3: {'M': 1.40, 'T': 5760, 'L': 12.4, 'D': 3.6,},
			4: {'M': 1.30, 'T': 5680, 'L': 13.2, 'D': 3.8,},
			5: {'M': 1.20, 'T': 5600, 'L': 14.0, 'D': 4.0,},
			6: {'M': 1.26, 'T': 5520, 'L': 15.8, 'D': 4.4,},
			7: {'M': 1.32, 'T': 5440, 'L': 17.6, 'D': 4.8,},
			8: {'M': 1.38, 'T': 5360, 'L': 19.4, 'D': 5.2,},
			9: {'M': 1.44, 'T': 5280, 'L': 21.2, 'D': 5.6,},
		},
		5: {
			0: {'M': 1.10, 'T': 6000, 'L': 1.400, 'D': 1.10,},
			1: {'M': 1.06, 'T': 5920, 'L': 1.276, 'D': 1.07,},
			2: {'M': 1.02, 'T': 5840, 'L': 1.152, 'D': 1.04,},
			3: {'M': 0.98, 'T': 5760, 'L': 1.028, 'D': 1.01,},
			4: {'M': 0.94, 'T': 5680, 'L': 0.904, 'D': 0.98,},
			5: {'M': 0.90, 'T': 5600, 'L': 0.780, 'D': 0.95,},
			6: {'M': 0.88, 'T': 5520, 'L': 0.728, 'D': 0.94,},
			7: {'M': 0.86, 'T': 5440, 'L': 0.676, 'D': 0.93,},
			8: {'M': 0.84, 'T': 5360, 'L': 0.624, 'D': 0.92,},
			9: {'M': 0.82, 'T': 5280, 'L': 0.572, 'D': 0.91,},
		},
		6: {
			0: {'M': 0.80, 'T': 6000, 'L': 0.73, 'D': 0.80,},
			1: {'M': 0.78, 'T': 5920, 'L': 0.67, 'D': 0.78,},
			2: {'M': 0.76, 'T': 5840, 'L': 0.61, 'D': 0.76,},
			3: {'M': 0.74, 'T': 5760, 'L': 0.55, 'D': 0.74,},
			4: {'M': 0.72, 'T': 5680, 'L': 0.49, 'D': 0.72,},
			5: {'M': 0.70, 'T': 5600, 'L': 0.43, 'D': 0.70,},
			6: {'M': 0.68, 'T': 5520, 'L': 0.39, 'D': 0.68,},
			7: {'M': 0.66, 'T': 5440, 'L': 0.35, 'D': 0.66,},
			8: {'M': 0.64, 'T': 5360, 'L': 0.31, 'D': 0.64,},
			9: {'M': 0.62, 'T': 5280, 'L': 0.27, 'D': 0.62,},
		},
	},
	5: {
		0: {
			0: {'M': 14.0, 'T': 5200, 'L': 110000, 'D': 420,},
			1: {'M': 14.8, 'T': 5040, 'L': 112000, 'D': 456,},
			2: {'M': 15.6, 'T': 4880, 'L': 114000, 'D': 492,},
			3: {'M': 16.4, 'T': 4720, 'L': 116000, 'D': 528,},
			4: {'M': 17.2, 'T': 4560, 'L': 118000, 'D': 564,},
			5: {'M': 18.0, 'T': 4400, 'L': 120000, 'D': 600,},
			6: {'M': 18.4, 'T': 4260, 'L': 122000, 'D': 660,},
			7: {'M': 18.8, 'T': 4120, 'L': 124000, 'D': 720,},
			8: {'M': 19.2, 'T': 3980, 'L': 126000, 'D': 780,},
			9: {'M': 19.6, 'T': 3840, 'L': 128000, 'D': 840,},
		},
		1: {
			0: {'M': 12.0, 'T': 5200, 'L': 21000, 'D': 180,},
			1: {'M': 12.2, 'T': 5040, 'L': 21200, 'D': 196,},
			2: {'M': 12.4, 'T': 4880, 'L': 21400, 'D': 212,},
			3: {'M': 12.6, 'T': 4720, 'L': 21600, 'D': 228,},
			4: {'M': 12.8, 'T': 4560, 'L': 21800, 'D': 244,},
			5: {'M': 13.0, 'T': 4400, 'L': 22000, 'D': 260,},
			6: {'M': 13.4, 'T': 4260, 'L': 22400, 'D': 284,},
			7: {'M': 13.8, 'T': 4120, 'L': 22800, 'D': 308,},
			8: {'M': 14.2, 'T': 3980, 'L': 23200, 'D': 332,},
			9: {'M': 14.6, 'T': 3840, 'L': 23600, 'D': 356,},
		},
		2: {
			0: {'M': 10.0, 'T': 5200, 'L': 7800, 'D': 110,},
			1: {'M': 10.4, 'T': 5040, 'L': 7920, 'D': 120,},
			2: {'M': 10.8, 'T': 4880, 'L': 8040, 'D': 130,},
			3: {'M': 11.2, 'T': 4720, 'L': 8160, 'D': 140,},
			4: {'M': 11.6, 'T': 4560, 'L': 8280, 'D': 150,},
			5: {'M': 12.0, 'T': 4400, 'L': 8400, 'D': 160,},
			6: {'M': 12.4, 'T': 4260, 'L': 8480, 'D': 174,},
			7: {'M': 12.8, 'T': 4120, 'L': 8560, 'D': 188,},
			8: {'M': 13.2, 'T': 3980, 'L': 8640, 'D': 202,},
			9: {'M': 13.6, 'T': 3840, 'L': 8720, 'D': 216,},
		},
		3: {
			0: {'M': 1.10, 'T': 5200, 'L': 260, 'D': 20,},
			1: {'M': 1.18, 'T': 5040, 'L': 314, 'D': 24,},
			2: {'M': 1.26, 'T': 4880, 'L': 368, 'D': 28,},
			3: {'M': 1.34, 'T': 4720, 'L': 422, 'D': 32,},
			4: {'M': 1.42, 'T': 4560, 'L': 476, 'D': 36,},
			5: {'M': 1.50, 'T': 4400, 'L': 530, 'D': 40,},
			6: {'M': 1.56, 'T': 4260, 'L': 544, 'D': 44,},
			7: {'M': 1.62, 'T': 4120, 'L': 558, 'D': 48,},
			8: {'M': 1.68, 'T': 3980, 'L': 572, 'D': 52,},
			9: {'M': 1.74, 'T': 3840, 'L': 586, 'D': 56,},
		},
		4: {
			0: {'M': 1.50, 'T': 5200, 'L': 23.0, 'D': 6.0,},
			1: {'M': 1.56, 'T': 5040, 'L': 24.4, 'D': 6.4,},
			2: {'M': 1.62, 'T': 4880, 'L': 25.8, 'D': 6.8,},
			3: {'M': 1.68, 'T': 4720, 'L': 27.2, 'D': 7.2,},
			4: {'M': 1.74, 'T': 4560, 'L': 28.6, 'D': 7.6,},
			// 5+ N/A; M, and D were interpolated assuming a similar delta from K0 to K5 as from G5 to K0
		},
		5: {
			0: {'M': 0.80, 'T': 5200, 'L': 0.5200, 'D': 0.90,},
			1: {'M': 0.78, 'T': 5040, 'L': 0.4580, 'D': 0.88,},
			2: {'M': 0.76, 'T': 4880, 'L': 0.3960, 'D': 0.86,},
			3: {'M': 0.74, 'T': 4720, 'L': 0.3340, 'D': 0.84,},
			4: {'M': 0.72, 'T': 4560, 'L': 0.2720, 'D': 0.82,},
			5: {'M': 0.70, 'T': 4400, 'L': 0.2100, 'D': 0.80,},
			6: {'M': 0.66, 'T': 4260, 'L': 0.1844, 'D': 0.78,},
			7: {'M': 0.62, 'T': 4120, 'L': 0.1588, 'D': 0.76,},
			8: {'M': 0.58, 'T': 3980, 'L': 0.1332, 'D': 0.74,},
			9: {'M': 0.54, 'T': 3840, 'L': 0.1076, 'D': 0.72,},
		},
		6: {
			0: {'M': 0.60, 'T': 5200, 'L': 0.2300, 'D': 0.60,},
			1: {'M': 0.58, 'T': 5040, 'L': 0.2006, 'D': 0.58,},
			2: {'M': 0.56, 'T': 4880, 'L': 0.1712, 'D': 0.56,},
			3: {'M': 0.54, 'T': 4720, 'L': 0.1418, 'D': 0.54,},
			4: {'M': 0.52, 'T': 4560, 'L': 0.1124, 'D': 0.52,},
			5: {'M': 0.50, 'T': 4400, 'L': 0.0830, 'D': 0.50,},
			6: {'M': 0.48, 'T': 4260, 'L': 0.0718, 'D': 0.48,},
			7: {'M': 0.46, 'T': 4120, 'L': 0.0606, 'D': 0.46,},
			8: {'M': 0.44, 'T': 3980, 'L': 0.0494, 'D': 0.44,},
			9: {'M': 0.42, 'T': 3840, 'L': 0.0382, 'D': 0.42,},
		},
	},
	6: {
		0: {
			0: {'M': 20, 'T': 3700, 'L': 130000, 'D':  900,},
			1: {'M': 21, 'T': 3560, 'L': 124000, 'D':  960,},
			2: {'M': 22, 'T': 3420, 'L': 118000, 'D': 1020,},
			3: {'M': 23, 'T': 3280, 'L': 112000, 'D': 1080,},
			4: {'M': 24, 'T': 3140, 'L': 106000, 'D': 1140,},
			5: {'M': 25, 'T': 3000, 'L': 100000, 'D': 1200,},
			6: {'M': 26, 'T': 2880, 'L':  98000, 'D': 1320,},
			7: {'M': 27, 'T': 2760, 'L':  96000, 'D': 1440,},
			8: {'M': 28, 'T': 2640, 'L':  94000, 'D': 1560,},
			9: {'M': 30, 'T': 2400, 'L':  90000, 'D': 1800,},
		},
		1: {
			0: {'M': 15, 'T': 3700, 'L': 24000, 'D': 380,},
			1: {'M': 16, 'T': 3560, 'L': 24400, 'D': 424,},
			2: {'M': 17, 'T': 3420, 'L': 24800, 'D': 468,},
			3: {'M': 18, 'T': 3280, 'L': 25200, 'D': 512,},
			4: {'M': 19, 'T': 3140, 'L': 25600, 'D': 556,},
			5: {'M': 20, 'T': 3000, 'L': 26000, 'D': 600,},
			6: {'M': 21, 'T': 2880, 'L': 24600, 'D': 640,},
			7: {'M': 22, 'T': 2760, 'L': 23200, 'D': 680,},
			8: {'M': 23, 'T': 2640, 'L': 21800, 'D': 720,},
			9: {'M': 25, 'T': 2400, 'L': 19000, 'D': 800,},
		},
		2: {
			0: {'M': 14.0, 'T': 3700, 'L': 8800, 'D': 230,},
			1: {'M': 14.4, 'T': 3560, 'L': 8800, 'D': 254,},
			2: {'M': 14.8, 'T': 3420, 'L': 8800, 'D': 278,},
			3: {'M': 15.2, 'T': 3280, 'L': 8800, 'D': 302,},
			4: {'M': 15.6, 'T': 3140, 'L': 8800, 'D': 326,},
			5: {'M': 16.0, 'T': 3000, 'L': 8800, 'D': 350,},
			6: {'M': 16.4, 'T': 2880, 'L': 8500, 'D': 380,},
			7: {'M': 16.8, 'T': 2760, 'L': 8200, 'D': 410,},
			8: {'M': 17.2, 'T': 2640, 'L': 7900, 'D': 440,},
			9: {'M': 18.0, 'T': 2400, 'L': 7300, 'D': 500,},
		},
		3: {
			0: {'M': 1.80, 'T': 3700, 'L':  600, 'D':  60,},
			1: {'M': 1.92, 'T': 3560, 'L':  624, 'D':  68,},
			2: {'M': 2.04, 'T': 3420, 'L':  648, 'D':  76,},
			3: {'M': 2.16, 'T': 3280, 'L':  672, 'D':  84,},
			4: {'M': 2.28, 'T': 3140, 'L':  696, 'D':  92,},
			5: {'M': 2.40, 'T': 3000, 'L':  720, 'D': 100,},
			6: {'M': 3.52, 'T': 2880, 'L':  816, 'D': 120,},
			7: {'M': 4.64, 'T': 2760, 'L':  912, 'D': 140,},
			8: {'M': 5.76, 'T': 2640, 'L': 1008, 'D': 160,},
			9: {'M': 8.00, 'T': 2400, 'L': 1200, 'D': 200,},
		},
		4: {
			// N/A
		},
		5: {
			0: {'M': 0.500, 'T': 3700, 'L': 0.082000, 'D': 0.70,},
			1: {'M': 0.432, 'T': 3560, 'L': 0.066180, 'D': 0.60,},
			2: {'M': 0.364, 'T': 3420, 'L': 0.050360, 'D': 0.50,},
			3: {'M': 0.296, 'T': 3280, 'L': 0.034540, 'D': 0.40,},
			4: {'M': 0.228, 'T': 3140, 'L': 0.018720, 'D': 0.30,},
			5: {'M': 0.160, 'T': 3000, 'L': 0.002900, 'D': 0.20,},
			6: {'M': 0.144, 'T': 2880, 'L': 0.002378, 'D': 0.18,},
			7: {'M': 0.128, 'T': 2760, 'L': 0.001856, 'D': 0.16,},
			8: {'M': 0.112, 'T': 2640, 'L': 0.001334, 'D': 0.14,},
			9: {'M': 0.080, 'T': 2400, 'L': 0.000290, 'D': 0.10,},
		},
		6: {
			0: {'M': 0.400, 'T': 3700, 'L': 0.027000, 'D': 0.400,},
			1: {'M': 0.344, 'T': 3560, 'L': 0.021744, 'D': 0.340,},
			2: {'M': 0.288, 'T': 3420, 'L': 0.016488, 'D': 0.280,},
			3: {'M': 0.232, 'T': 3280, 'L': 0.011232, 'D': 0.220,},
			4: {'M': 0.176, 'T': 3140, 'L': 0.005976, 'D': 0.160,},
			5: {'M': 0.120, 'T': 3000, 'L': 0.000720, 'D': 0.100,},
			6: {'M': 0.111, 'T': 2880, 'L': 0.000614, 'D': 0.096,},
			7: {'M': 0.102, 'T': 2760, 'L': 0.000508, 'D': 0.092,},
			8: {'M': 0.093, 'T': 2640, 'L': 0.000402, 'D': 0.088,},
			9: {'M': 0.075, 'T': 2400, 'L': 0.000190, 'D': 0.080,},
		},
	},
};

// Brown Dwarf data lookup by Mass ('M'); interpolated and condensed results across the entire L/T/Y range into range 0-9
const BROWN_DWARF_DATA = [
	{'M': 0.0800, 'T': 2400.0, 'L': 0.000290000, 'D': 0.1,},
	{'M': 0.0726, 'T': 2166.7, 'L': 0.000257790, 'D': 0.1,},
	{'M': 0.0651, 'T': 1933.3, 'L': 0.000225570, 'D': 0.1,},
	{'M': 0.0577, 'T': 1700.0, 'L': 0.000193360, 'D': 0.1,},
	{'M': 0.0502, 'T': 1466.7, 'L': 0.000161140, 'D': 0.1,},
	{'M': 0.0428, 'T': 1233.3, 'L': 0.000128930, 'D': 0.1,},
	{'M': 0.0353, 'T': 1000.0, 'L': 0.000096715, 'D': 0.1,},
	{'M': 0.0279, 'T':  766.7, 'L': 0.000064500, 'D': 0.1,},
	{'M': 0.0204, 'T':  533.3, 'L': 0.000032286, 'D': 0.1,},
	{'M': 0.0130, 'T':  300.0, 'L': 0.000000072, 'D': 0.1,},
];

// White Dwarf data lookup by Age ('A')
const WHITE_DWARF_DATA = [
	{'A':  0.0, 'T': 100000, 'L': 2500.000, 'D': 0.017,},
	{'A':  0.1, 'T':  25000, 'L': 0.200000, 'D': 0.017,},
	{'A':  0.5, 'T':  10000, 'L': 0.002500, 'D': 0.017,},
	{'A':  1.0, 'T':   8000, 'L': 0.001000, 'D': 0.017,},
	{'A':  1.5, 'T':   7000, 'L': 0.000590, 'D': 0.017,},
	{'A':  2.5, 'T':   5500, 'L': 0.000230, 'D': 0.017,},
	{'A':  5.0, 'T':   5000, 'L': 0.000150, 'D': 0.017,},
	{'A': 10.0, 'T':   4000, 'L': 0.000063, 'D': 0.017,},
	{'A': 13.0, 'T':   3800, 'L': 0.000051, 'D': 0.017,},
];

const NON_PRIMARY_COMPANION = {
	 2: 'Other',
	 3: 'Other',
	 4: 'Random',
	 5: 'Random',
	 6: 'Lesser',
	 7: 'Lesser',
	 8: 'Sibling',
	 9: 'Sibling',
	10: 'Twin',
	11: 'Twin',
	12: 'Twin',
};

const NON_PRIMARY_DEAD = {
	 2: 'Other',
	 3: 'Other',
	 4: 'Random',
	 5: 'Random',
	 6: 'Random',
	 7: 'Random',
	 8: 'Random',
	 9: 'Lesser',
	10: 'Lesser',
	11: 'Twin',
	12: 'Twin',
};

const NON_PRIMARY_SECONDARY = {
	 2: 'Other',
	 3: 'Other',
	 4: 'Random',
	 5: 'Random',
	 6: 'Random',
	 7: 'Lesser',
	 8: 'Lesser',
	 9: 'Sibling',
	10: 'Sibling',
	11: 'Twin',
	12: 'Twin',
};

const PLANET_EMPTY = 0;

const PLANET_BELT = 2;

const PLANET_GAS = 1;

const PLANET_ROCK = 3;

const PLANET_MOON = 4;

const PLANET_RING = 5;

const PLANET_QTY_GAS = {
	 4: 1,
	 5: 2,
	 6: 2,
	 7: 3,
	 8: 3,
	 9: 4,
	10: 4,
	11: 4,
	12: 5,
	13: 6,
};

const TERRESTRIAL_DIAMETERS = [
	0,
	// There is also a Size 'S' = 600 km, but it doesn't fit in this lookup table
	1600,
	3200,
	4800,
	6400,
	8000,
	9600,
	11200,
	12800,
	14400,
	16000,
	17600,
	19200,
	20800,
	22400,
	24000,
];

const TERRESTRIAL_DENSITIES = [
	[0.03,0.06,0.09,0.12,0.15,0.18,0.21,0.24,0.27,0.30,0.33],
	[0.18,0.21,0.24,0.27,0.30,0.33,0.36,0.39,0.41,0.44,0.47],
	[0.50,0.53,0.56,0.59,0.62,0.65,0.68,0.71,0.74,0.77,0.80],
	[0.82,0.85,0.88,0.91,0.94,0.97,1.00,1.03,1.06,1.09,1.12],
	[1.15,1.18,1.21,1.24,1.27,1.30,1.33,1.36,1.39,1.42,1.45],
	[1.50,1.55,1.60,1.65,1.70,1.75,1.80,1.85,1.90,1.95,2.00],
];

const TAINT_B = 11;
const TAINT_G = 16;
const TAINT_H = 17;
const TAINT_L = 20;
const TAINT_P = 23;
const TAINT_R = 25;
const TAINT_S = 26;

class Roll
{
	constructor(die_qty, die_size = 6, modifier = 0, description = '')
	{
		this.n = die_qty;
		this.d = die_size;
		this.dm = modifier;
		this.description = description;
		this.rolls = [];
		this.total = 0;
		for (let i = 0; i < this.n; i++) {
			const v = getRandomIntInclusive(1, this.d);
			this.rolls.push(v);
			this.total += v;
		}
		this.total += this.dm;
	}

	toString()
	{
		return this.dice() + ': ' + this.total + ' ' + this.results();
	}

	dice()
	{
		return this.n + 'd' + this.d;
	}

	results()
	{
		return '[' + this.rolls.join(' + ') + ']';
	}

	modifier()
	{
		return this.dm > 0
			? signed(this.dm)
			: (this.dm < 0 ? this.dm : '');
	}
}

class OrbitingBody
{
	constructor(host = null)
	{
		this.host = host;
		this.mass = 0;
		this.mass_deviation = 0;
		this.orbit = 0;
		this.orbit_au = 0;
		this.orbit_deviation = 0;
		this.orbit_eccentricity = 0;
		// Exclusion zone is the absolute Minimum Allowable Orbit#, typically based on the object's diameter
		this.orbit_exclusion_zone = 0;
		this.orbit_major_min = 0;
		this.orbit_major_max = 0;
		this.orbit_period = 0;
		this.orbit_retrograde = false;
		// Min and Max allowed Orbit#s, centered on this object, for any other bodies that may orbit it
		this.allowed_orbits_min = 0;
		this.allowed_orbits_max = 0;
		this.bodies = [];
		this.n_bodies = 0;
		this.n_empty = 0;
		this.orbit_slots = 0;
		// Fields used when baseline, spread, etc. are determined separately for each Secondary and Companion star with independent orbits
		this.baseline_number = 0;
		this.baseline_orbit = 0;
		this.orbit_spread = 0;
		this.orbit_spread_max = 0;
		// Optional roll history from factory generation
		this.history = [];
	}

	getDesignation(n_stars = 1)
	{
		return '';
	}

	getDesignationPrimary()
	{
		return '';
	}

	/**
	 * @return string Human-readable version of the body's orbital period
	 */
	getOrbitalPeriod()
	{
		if (this.orbit_period > 0.5) {
			let n = this.orbit_period > 9999 ? this.orbit_period.toFixed(0).length : (this.orbit_period < 1 ? 3 : 4);
			return format(this.orbit_period, n) + 'y';
		} else if (this.orbit_period > 0.005) {
			return format(this.orbit_period * 365.25, 4) + 'd';
		}
		return format(this.orbit_period * 8766, 4) + 'h';
	}

	getOrbitalMass()
	{
		return this.getTotalMass();
	}

	getTotalMass()
	{
		return this.mass + this.mass_deviation;
	}

	getTotalOrbit()
	{
		return this.orbit + this.orbit_deviation;
	}

	getMinimumAllowableOrbit(n = 3)
	{
		return round(Math.max(this.allowed_orbits_min, this.orbit_exclusion_zone), n);
	}

	getMaximumAllowableOrbit(n = 3)
	{
		return round(this.allowed_orbits_max, n);
	}

	/**
	 * @return string The range of Orbit#s, if any, in which other objects may orbit around this body
	 */
	getAllowedOrbits()
	{
		const min = this.getMinimumAllowableOrbit();
		const max = this.getMaximumAllowableOrbit();
		if (min >= max) {
			return '-';
		}
		return min.toFixed(2) + ' - ' + max.toFixed(2);
	}

	/**
	 * @return float The total number of available Orbit#s around this object, if any
	 */
	getTotalAllowedOrbits()
	{
		return Math.max(0, this.getMaximumAllowableOrbit() - this.getMinimumAllowableOrbit());
	}

	/**
	 * @return int Value to add to allowed orbital slots when #getTotalAllowedOrbits is greater than 0
	 */
	getAllowedOrbitMod()
	{
		return 0;
	}

	/**
	 * @return float The smaller of #orbit_spread and #orbit_spread_max
	 */
	getMinimumOrbitSpread()
	{
		if (this.orbit_spread < 0.001) return this.orbit_spread_max;
		if (this.orbit_spread_max < 0.001) return this.orbit_spread;
		return Math.min(this.orbit_spread, this.orbit_spread_max);
	}

	getSignificantBodyCount()
	{
		return this.bodies.length;
	}
}

class AbstractStar extends OrbitingBody
{
	constructor()
	{
		super(null);
		this.hzco = 0;
	}

	getHzco(n = 3)
	{
		return round(this.hzco, n);
	}

	/**
	 * @param float mod The number of Orbit#s by which to modify the HZCO
	 *
	 * @return float the correctly modified HZCO, accounting for "whole" increments of 0.1 when HZCO < 1
	 */
	getHzcoPlus(mod, n = 3)
	{
		const hzco = this.getHzco(n);
		return getOrbitPlus(hzco, mod);
	}

	isHzcoValid()
	{
		const hzco = this.getHzco();
		return hzco > this.getMinimumAllowableOrbit() && hzco < this.getMaximumAllowableOrbit();
	}

	/**
	 * @return bool True if this star or star group is or contains the system's primary star (or, if it has a companion, the primary pair)
	 */
	isPrimaryComponent()
	{
		return false;
	}
}

class Star extends AbstractStar
{
	constructor(type = MAIN_TYPE_M, subtype = 0, classification = 5, primary = true)
	{
		super();
		this.primary = primary;
		this.type = clamp(type, -1, 15);
		this.subtype = clamp(subtype, -1, 9);
		this.classification = clamp(classification, -1, 9);
		this.companion = null;
		this.designation = 0;
		this.diameter = 0;
		this.diameter_deviation = 0;
		this.luminosity = 0;
		this.luminosity_deviation = 0;
		this.temperature = 0;
		this.temperature_deviation = 0;
		// Lifespans
		this.life_main = -1;     // All classes
		this.life_subgiant = -1; // Class III and IV, White Dwarfs and other dead stars
		this.life_giant = -1;    // Class III, White Dwarfs and other dead stars
		this.age = 0;
		// Orbital bands used during system generation: 0 = Primary, 1 = Close, 2 = Near, 3 = Far
		this.orbit_band = 0;
		this.orbit_exclusion_zone = 0.01;
	}

	/**
	 * @return string Standard star code format D-O-E-T# C-M-D-L; D-O-E included for secondary objects only
	 */
	getProfileLong()
	{
		let parts = [];
		// D-O-E for non-primary stars only
		if (!this.primary) {
			parts.push(this.getDesignation());
			parts.push(this.getTotalOrbit().toFixed(2));
			parts.push(format(this.orbit_eccentricity, 3));
		}
		// T# C is the same as the short profile
		parts.push(this.getProfileShort());
		parts.push(format(this.getTotalMass(), 3));
		parts.push(format(this.getTotalDiameter(), 3));
		parts.push(format(this.getTotalLuminosity(), 3));
		return parts.join('-');
	}

	getProfileShort()
	{
		let suffix = '';
		// Special Case: Protostars should display the type of star they will become
		if (this.type === PROTOSTAR) {
			const future = new Star(this.proto_type, this.proto_subtype, this.proto_classification);
			suffix = ' (' + future.getProfileShort() + ')';
		}
		return STAR_TYPE[this.type]
			+ (this.subtype > -1 ? this.subtype : '')
			+ (this.classification > -1 ? ' ' + STAR_CLASS[this.classification] : '')
			+ suffix;
	}

	getColor()
	{
		const colors = [
			'Blue',
			'Blue White',
			'White',
			'Yellow White',
			'Yellow',
			'Light Orange',
			'Orange Red',
			'White', // White Dwarf, should probably be based on temperature as their colors can range from O-M type
			'Brown', // Brown Dwarf
			'Other', // Everything else
		];
		const index = clamp(this.type, 0, 9);
		return colors[index];
	}

	getDesignation(n_stars = 1)
	{
		const suffix = (this.designation > 7 ? 'b' : (this.designation > 3 ? 'a' : ''));
		return this.getDesignationPrimary() + suffix;
	}

	getDesignationPrimary()
	{
		const prefixes = ['A', 'B', 'C', 'D'];
		const preIndex = clamp(this.designation % 4, 0, 3);
		return prefixes[preIndex];
	}

	getName()
	{
		return STAR_NAME[this.type];
	}

	/**
	 * @return float The star's total mass plus that of any companion star
	 */
	getOrbitalMass()
	{
		return this.getTotalMass() + (this.companion ? this.companion.getTotalMass() : 0);
	}

	getTotalDiameter()
	{
		return this.diameter + this.diameter_deviation;
	}

	getTotalLuminosity()
	{
		return this.luminosity + this.luminosity_deviation;
	}

	getAllowedOrbitMod()
	{
		// Add 1 for stars with at least some available orbit#s and no companion
		return (this.companion || this.host ? 0 : 1);
	}

	getTotalTemperature()
	{
		return this.temperature + this.temperature_deviation;
	}

	/**
	 * @param Star|null other may be null for convenience
	 *
	 * @return bool True if this star is in an adjacent orbital band to another stellar object
	 */
	isAdjacent(other = null)
	{
		return other !== null && Math.abs(this.orbit_band - other.orbit_band) === 1;
	}

	isGiant()
	{
		return this.type <= MAIN_TYPE_M && this.classification > -1 && this.classification < 4;
	}

	/**
	 * Post-Stellar objects for the purpose of star system generation are D, PSR, NS, BH
	 */
	isPostStellar()
	{
		const types = [WHITE_DWARF, PULSAR, NEUTRON_STAR, BLACK_HOLE];
		return types.includes(this.type);
	}

	/**
	 * @return bool True if this star is the primary star and does not have a companion
	 */
	isPrimaryComponent()
	{
		return this.primary && this.companion === null;
	}
}

class StarGroup extends AbstractStar
{
	/**
	 * @param array<OrbitingBody>
	 */
	constructor(...bodies)
	{
		super();
		// Orbital characteristics are based on only the furthest body, so sort them based on total orbit
		bodies.sort((a, b) => {
			const x = a.getTotalOrbit();
			const y = b.getTotalOrbit();
			return (x < y ? -1 : (x > y ? 1 : 0));
		});
		this.primary = bodies[0].primary;
		this.designation = '';
		this.luminosity = 0;
		bodies.forEach(body => {
			this.designation += body.getDesignationPrimary();
			this.mass += body.getOrbitalMass();
			this.luminosity += body.getTotalLuminosity();
		});
		const last = bodies[bodies.length - 1];
		this.orbit = last.getTotalOrbit();
		this.orbit_au = last.orbit_au;
		this.orbit_band = last.orbit_band;
		this.orbit_eccentricity = last.orbit_eccentricity;
		this.orbit_major_min = last.orbit_major_min;
		this.orbit_major_max = last.orbit_major_max;
		this.orbit_period = last.orbit_period;
		this.hzco = calculateHabitableCenterZone(this.getTotalLuminosity());
	}

	getProfileShort()
	{
		return '-';
	}

	getDesignation(n_stars = 1)
	{
		return this.getDesignationPrimary();
	}

	getDesignationPrimary()
	{
		return this.designation;
	}

	getTotalDiameter()
	{
		return -1;
	}

	getTotalLuminosity()
	{
		return this.luminosity;
	}

	getAllowedOrbitMod()
	{
		// Star groups either add to the primary or are themselves a companion pair
		return 0;
	}

	getTotalTemperature()
	{
		return -1;
	}

	isHzcoValid()
	{
		// StarGroup's min and max allowed orbits already account for the star's exclusion zone etc.
		return this.hzco > this.allowed_orbits_min && this.hzco < this.allowed_orbits_max;
	}

	/**
	 * @return bool True if this star group contains the system's primary star
	 */
	isPrimaryComponent()
	{
		return this.primary;
	}
}

class StarGroupCompanion extends StarGroup
{
	/**
	 * @param Star star Any host to a companion star
	 */
	constructor(star)
	{
		super(star, star.companion);
		this.designation = star.getDesignationPrimary();
		this.designation_suffix = '(' + this.designation + ')';
		this.mass = star.getOrbitalMass();
		// Companion groups have special rules for calculating MAO
		this.allowed_orbits_min = round(this.getAllowedOrbitsMin(star), 3);
	}

	getAllowedOrbitsMin(star)
	{
		// Orbit#s < (0.5 + companion's ecc) are not available
		let min = star.orbit_exclusion_zone + (0.5 + star.companion.orbit_eccentricity);
		log('Determining MAO for companion; ' + star.orbit_exclusion_zone + '(exclusion zone) + 0.5 + ' + star.companion.orbit_eccentricity + ' (companion eccentricity) = ' + min);
		// If either star has an individual MAO > 0.2, add the larger star's MAO to the range of unavailable Orbit#s
		const max_mao = Math.max(star.orbit_exclusion_zone, star.companion.orbit_exclusion_zone);
		log('Determining MAO for companion; highest MAO of the two stars = ' + max_mao);
		return min + (max_mao > 0.2 ? max_mao : 0);
	}

	getDesignation(n_stars = 1)
	{
		return this.designation + 'ab' + (n_stars > 1 ? ' ' + this.designation_suffix : '');
	}
}

class StarSystem
{
	constructor(stars = [])
	{
		this.stars = stars;
		this.age = this.determineAge();
		// Determine the various body counts: Stellar, Planetoid Belt, Gas Giants, and Terrestrial Planets
		this.n_stellar = stars.reduce((n, star) => n + (star.companion ? 2 : 1), 0);
		this.n_planets = 0;
		this.n_planet_belt = 0;
		this.n_planet_gas = 0;
		this.n_planet_rock = 0;
		this.n_empty = 0;
		this.baseline_number = 0;
		this.baseline_orbit = 0;
		this.orbit_spread = 0;
		this.orbit_spread_max = 0;
		this.star_groups = this.buildStarGroups();
		// Optional roll history from factory generation
		this.history = [];
	}

	buildStarGroups()
	{
		let groups = []
		for (let i = 0; i < this.stars.length; i++) {
			const star = this.stars[i];
			const prev = (groups.length > 0 ? groups[groups.length - 1] : null);
			// Determine max allowable Orbit#s centered around any secondary stars (already determined for stars with companions)
			if (!star.primary && star.companion === null) {
				const secondary_orbits_max = Math.max(0, star.getTotalOrbit() - this.getSecondaryMaxOrbitMod(star, i));
				log('Changing MAX allowed orbit of Secondary from ' + star.allowed_orbits_max + ' to ' + secondary_orbits_max);
				star.allowed_orbits_max = secondary_orbits_max;
			}
			// Add the current star
			groups.push(star);
			// Add any companion (and corresponding star group)
			if (star.companion !== null) {
				groups.push(star.companion);
				groups.push(new StarGroupCompanion(star));
			}
			// Add combined star group if this is not the first entry
			if (prev) {
				const last = groups[groups.length - 1];
				const mod = this.getSecondaryGroupExclusionOrbitMod(star);
				log('Secondary exclusion zone for ' + star.getDesignation(this.stars.length) + ': Orbit# ' + star.getTotalOrbit() + ' +/- ' + mod);
				// Previous group's maximum allowable orbit is the inner edge of the current Secondary star's exclusion zone
				prev.allowed_orbits_max = star.getTotalOrbit() - mod;
				const group = new StarGroup(prev, star);
				// The combined group's minimum allowable orbit is the outer edge of the current Secondary star's exclusion zone
				group.allowed_orbits_min = star.getTotalOrbit() + mod;
				group.allowed_orbits_max = Math.max(0, group.getTotalOrbit() - this.getSecondaryMaxOrbitMod(star, i));
				groups.push(group);
			}
		};
		// The final (or perhaps only) group's maximum allowable orbit is always Orbit# 20.0
		if (groups.length > 0) {
			groups[groups.length - 1].allowed_orbits_max = 20;
		}
		return groups;
	}

	getPrimaryStar()
	{
		return this.stars[0];
	}

	/**
	 * @return Star|StarGroupCompanion Either the primary star itself or, if it has a companion, the pair of them as one
	 */
	getPrimaryStarComponent()
	{
		return this.star_groups.find(group => group.isPrimaryComponent());
	}

	getSecondaryMaxOrbitMod(star, i)
	{
		const prev = (i > 0 ? this.stars[i - 1] : null);
		const next = (i + 1 < this.stars.length ? this.stars[i + 1] : null);
		// Only adjacent Secondary stars are counted; Primary stars are ignored here
		const isPrevAdj = star.isAdjacent(prev) && !prev.primary;
		const isNextAdj = star.isAdjacent(next) && !next.primary;
		let mod = 3;
		// Reduce by 1.0 more if there is another Secondary star in any adjacent zone, but only once
		if (isPrevAdj || isNextAdj) {
			mod++;
		}
		// Reduce by 1.0 more if it or any adjacent Secondary star has an eccentricity > 0.2, but only once
		if (this.orbit_eccentricity > 0.2 || (isPrevAdj && prev.orbit_eccentricity > 0.2) || (isNextAdj && next.orbit_eccentricity > 0.2)) {
			mod++;
		}
		// Reduce by 1.0 more if it or any adjacent Secondary star has an eccentricity > 0.5, but only once
		if (this.orbit_eccentricity > 0.5 || (isPrevAdj && prev.orbit_eccentricity > 0.5) || (isNextAdj && next.orbit_eccentricity > 0.5)) {
			mod++;
		}
		return mod;
	}

	/**
	 * The modifier to apply to the Orbit# exclusionary zone around a secondary star when calculating Orbit#s available to the Primary star
	 */
	getSecondaryGroupExclusionOrbitMod(star)
	{
		const ecc_mod = (star.orbit_eccentricity && star.orbit_band < 3 > 0.5 ? 2 : (star.orbit_eccentricity > 0.2 ? 1 : 0));
		const mao_mod = (star.orbit_exclusion_zone > 0.2 ? star.orbit_exclusion_zone : 0);
		return 1 + ecc_mod + mao_mod;
	}

	determineAge()
	{
		if (this.stars.length < 1) {
			return 0;
		}
		// System age is the greater of the primary star and any post-stellar objects
		const primary = this.getPrimaryStar();
		const p_comp = primary.companion;
		const p_age = Math.max(primary.age, (p_comp && p_comp.isPostStellar() ? p_comp.age : 0));
		return this.stars.reduce((a, b) => {
			const x = (b.isPostStellar() ? b.age : 0);
			const y = (b.companion !== null && b.companion.isPostStellar() ? b.companion.age : 0);
			log('Determining age [prior max vs. current Post-Stellar secondary or its companion]: ' + a + ' vs. ' + x + ' vs. ' + y);
			return Math.max(a, Math.max(x, y));
		}, p_age);
	}

	/**
	 * @return float The smaller of #orbit_spread and #orbit_spread_max
	 */
	getMinimumOrbitSpread()
	{
		if (this.orbit_spread < 0.001) return this.orbit_spread_max;
		if (this.orbit_spread_max < 0.001) return this.orbit_spread;
		return Math.min(this.orbit_spread, this.orbit_spread_max);
	}

	getProfileLong()
	{
		return (this.n_stellar > 1 ? this.n_stellar + '-' : '')
			+ this.stars.map(star => 
				star.getProfileLong() +
				(star.primary ? '-' + format(this.age, 3) : '') +
				(star.companion ? ':' + star.companion.getProfileLong() : '')
			).join(':');
	}

	getProfileShort()
	{
		return this.stars.map(star => star.getProfileShort()).join(':');
	}

	/**
	 * G-P-T-N-S: # Gas Giants, # Planetoid Belts, # Terrestrial Planets, Baseline Number, System Spread
	 *
	 * @return string Short version of the Planetary System Profile
	 */
	getPlanetaryProfileShort()
	{
		return this.n_planet_gas
			+ '-' + this.n_planet_belt
			+ '-' + this.n_planet_rock
			+ '-' + Math.max(0, this.baseline_number)
			+ '-' + this.getMinimumOrbitSpread();
	}
}

class World extends OrbitingBody
{
	/**
	 * @param OrbitingBody host Typically a Star or StarGroup
	 * @param float orbit The world's Orbit# around its host
	 * @param int index The numeric position of this body around its host used when determining its designation
	 * @param int type The world type, e.g. PLANET_GAS
	 */
	constructor(host, orbit, index = 1, type = PLANET_GAS)
	{
		super(host);
		this.atmosphere = null;
		this.orbit = orbit;
		this.orbit_au = orbitToAU(this.getTotalOrbit());
		this.index = index;
		this.size = 0;
		this.temperature = 0;
		this.temperature_mean = -1;
		this.type = type;
		this.albedo = 0;
		this.composition = 0;
		this.density = 0;
		this.diameter = 0;
		this.diameter_deviation = 0;
		this.escape_velocity = 0;
		this.gravity = 0;
		this.habitability = 0;
		this.hydrographics = 0;
		this.designation_suffix = convertToRoman(this.index);
		this.hill_sphere = 0;
		this.moon_orbit_range = 0;
	}

	/**
	 * @return string Human-readable name for this body's composition
	 */
	getCompositionName()
	{
		if (this.composition === 0) return 'Exotic Ice';
		if (this.composition === 1) return 'Mostly Ice';
		if (this.composition === 2) return 'Mostly Rock';
		if (this.composition === 3) return 'Rock and Metal';
		if (this.composition === 4) return 'Mostly Metal';
		return 'Compressed Metal';
	}

	/**
	 * @param int n_stars The total number of stars in the system
	 */
	getDesignation(n_stars = 1)
	{
		const prefix = (n_stars > 1 ? this.host.getDesignation(n_stars) + ' ' : '');
		return prefix + this.designation_suffix;
	}

	/**
	 * @return string Any additional notes that should be displayed for this world's entry on the survey form
	 */
	getProfileNotes()
	{
		let desc = [];
		if (this.isInHzco()) desc.push('HZ');
		if (this.habitability > 0) desc.push('HR:' + this.habitability);
		desc.push(this.getTypeName());
		if (this.type === PLANET_ROCK || this.type === PLANET_MOON) {
			desc.push(this.getCompositionName());
			desc.push(this.getTemperatureName() + ' (' + this.temperature + ')');
			if (this.atmosphere?.type > 0) desc.push(this.atmosphere.getProfileLong());
		}
		return desc.join(', ');
	}

	/**
	 * @return string The 3-character (usually) code corresponding to this world's Size, Atmosphere, and Hydrographics
	 */
	getProfileShort()
	{
		if (this.type === PLANET_GAS) return this.getSizeCode();
		return '' + this.getSizeCode()
			+ (this.atmosphere ? this.atmosphere.code : '0')
			+ toHexCode(this.hydrographics);
	}

	getSizeCode()
	{
		switch (this.type) {
		case PLANET_GAS: return (this.size > 1 ? 'GL' : (this.size < 1 ? 'GS' : 'GM')) + toHexCode(round(this.getTotalDiameter(), 0));
		// Special Case: Terrestrial planets and Moons can be Size -1, indicating Size Small
		case PLANET_ROCK: return (this.size < 0 ? 'S' : toHexCode(this.size));
		}
		return '-';
	}

	/**
	 * Standard size profile for a Terrestrial World or Moon, in the format S-Dkm-D-G-M
	 */
	getSizeProfile()
	{
		if (this.type !== PLANET_ROCK && this.type !== PLANET_MOON) return '';
		return this.getSizeCode()
			+ '-' + round(this.getTotalDiameter(), 3)
			+ '-' + round(this.density, 3)
			+ '-' + round(this.gravity, 3)
			+ '-' + round(this.getTotalMass(), 3);
	}

	getTemperatureName()
	{
		if (this.temperature <  3) return 'Frozen';
		if (this.temperature <  5) return 'Cold';
		if (this.temperature < 10) return 'Temperate';
		if (this.temperature < 12) return 'Hot';
		return 'Boiling';
	}

	getTotalDiameter()
	{
		return this.diameter + this.diameter_deviation;
	}

	getTypeName()
	{
		switch (this.type) {
		case PLANET_EMPTY: return 'Empty';
		case PLANET_BELT: return 'Planetoid Belt';
		case PLANET_GAS: return 'Gas Giant';
		case PLANET_ROCK: return 'Terrestrial';
		case PLANET_MOON: return 'Moon';
		case PLANET_RING: return 'Planetary Ring';
		}
		return 'Unknown';
	}

	/**
	 * @return AbstractStar This world's (or moon's) host star
	 */
	getHostStar()
	{
		return (this.host instanceof AbstractStar ? this.host : this.host.getHostStar());
	}

	/**
	 * Shortcut to the host star's #getHzco function
	 */
	getHzco()
	{
		return this.getHostStar().getHzco();
	}

	/**
	 * Retrieves the value of #getTotalOrbit appropriate for comparing to HZCO, i.e. that of the world or, if orbiting another world, its host
	 */
	getHzcoOrbit()
	{
		return (this.host instanceof AbstractStar ? this.getTotalOrbit() : this.host.getHzcoOrbit());
	}

	/**
	 * Shortcut to the host star's #getHzcoPlus function
	 */
	getHzcoPlus(mod, n = 3)
	{
		return this.getHostStar().getHzcoPlus(mod, n);
	}

	isInHzco()
	{
		const lower = this.getHzcoPlus(-1);
		const upper = this.getHzcoPlus(1);
		const orbit = this.getHzcoOrbit();
		return orbit > lower && orbit < upper;
	}
}

class PlanetoidBelt extends World
{
	/**
	 * @param OrbitingBody host Typically a World
	 * @param float orbit The planets's Orbit# around its host
	 * @param int index The numeric position of this body around its host used when determining its designation
	 */
	constructor(host, orbit, index = 1)
	{
		super(host, orbit, index, PLANET_BELT);
		this.bulk = 0;
		this.composition_m = 0;
		this.composition_s = 0;
		this.composition_c = 0;
		this.composition_o = 0;
		this.designation_suffix = 'P' + this.designation_suffix;
		this.resource_rating = 0;
		this.resource_rating_deviation = 0;
		this.span = 0;
		// Size 1 ("large" in this context) and Size S significant body counts
		this.n_bodies_large = 0;
		this.n_bodies_small = 0;
	}

	getCompositionProfile()
	{
		return (''+format(this.composition_m, 2)).padStart(2, '0')
			+ '.' + (''+format(this.composition_s, 2)).padStart(2, '0')
			+ '.' + (''+format(this.composition_c, 2)).padStart(2, '0')
			+ '.' + (''+format(this.composition_o, 2)).padStart(2, '0');
	}

	getProfileNotes()
	{
		return super.getProfileNotes() + ', ' + this.getProfileLong();
	}

	getProfileLong()
	{
		return format(this.span, 2)
			+ '-' + this.getCompositionProfile()
			+ '-' + this.bulk
			+ '-' + this.getTotalResourceRating()
			+ '-' + this.n_bodies_large
			+ '-' + this.n_bodies_small;
	}

	getSignificantBodyCount()
	{
		return this.n_bodies_large + this.n_bodies_small;
	}

	getSizeCode()
	{
		return '0';
	}

	/**
	 * Planetary belt resource ratings always range between 2 and 12
	 */
	getTotalResourceRating()
	{
		return clamp(this.resource_rating + this.resource_rating_deviation, 2, 12);
	}
}

class Moon extends World
{
	/**
	 * @param OrbitingBody host Typically a World
	 * @param float orbit The moon's Orbit# around its host
	 * @param int index The numeric position of this body around its host used when determining its designation
	 * @param bool significant True if this is a significant moon
	 */
	constructor(host, orbit, index = 1, significant = true)
	{
		super(host, orbit, index, PLANET_MOON);
		this.orbit_au = 0;
		this.significant = significant;
	}

	/**
	 * @param int n_stars The total number of stars in the system
	 */
	getDesignation(n_stars = 1)
	{
		const suffix = (this.significant ? String.fromCharCode(this.index + 96) : this.index);
		return this.host.getDesignation(n_stars) + ' ' + suffix;
	}

	/**
	 * @Override Moon orbital periods are in hours rather than years
	 */
	getOrbitalPeriod()
	{
		return format(this.orbit_period, 4) + 'h';
	}

	getSizeCode()
	{
		return (this.size < 0 ? 'S' : toHexCode(this.size));
	}
}

class PlanetaryRing extends Moon
{
	/**
	 * @param OrbitingBody host Typically a World
	 * @param float orbit The ring's Orbit# around its host
	 * @param int index The numeric position of this body around its host used when determining its designation
	 */
	constructor(host, orbit, index = 1)
	{
		super(host, orbit, index, false);
		this.type = PLANET_RING;
		this.orbit_au = 0;
		this.span = 0;
	}

	/**
	 * @return string Any additional notes that should be displayed for this world's entry on the survey form
	 */
	getProfileNotes()
	{
		return this.getTypeName() + ', ' + this.getProfileLong();
	}

	getProfileLong()
	{
		return this.getTotalOrbit().toFixed(2) + '-' + format(this.span, 2);
	}

	getSizeCode()
	{
		return 'R';
	}
}

class Atmosphere
{
	/**
	 * @param int type Atmosphere type should be between 0 and 17 (H)
	 * @param int density A numeric rating of atmospheric density from 0-7, with 0 = None, 4 = Standard, and 7 = Extremely Dense
	 * @param bool irritant True if an irritant was indicated during initial generation, allowing it to be rolled later
	 */
	constructor(type = -1, density = -1, irritant = false)
	{
		this.type = type;
		this.type_orig = type;
		this.code = toHexCode(this.type);
		this.density = density;
		this.greenhouse_factor = 0;
		this.irritant = irritant;
		this.bar = 0;
		this.ppo = 0;
		this.subtype = -1;
		this.subtype_b = -1;
		this.taints = [];
	}

	getProfileShort()
	{
		// Corrosive, Exotic, Insidious, and Unusual profiles
		const st = this.getSubtypeProfile();
		if (st.length > 0) {
			return this.code + '-' + st + ':' + this.bar.toFixed(3);
		}
		return this.code
			+ '-' + this.bar.toFixed(3)
			+ '-' + this.ppo.toFixed(3);
	}

	getProfileLong()
	{
		const taints = this.getTaintProfile();
		return this.getProfileShort() + (taints.length > 0 ? ' ' + taints : '');
	}

	getDensityName()
	{
		switch (this.density) {
		case 0: return 'None';
		case 1: return 'Extremely Thin';
		case 2: return 'Very Thin';
		case 3: return 'Thin';
		case 4: return 'Standard';
		case 5: return 'Dense';
		case 6: return 'Very Dense';
		case 7: return 'Extremely Dense';
		case 8: return 'Crushing';
		case 9: return 'Extremely Crushing';
		}
		return '';
	}

	getSubtypeProfile()
	{
		if (this.subtype < 0) return '';
		return 'St' + toHexCode(this.subtype) + (this.subtype_b > -1 ? '.' + toHexCode(this.subtype_b) : '');
	}

	getTaintProfile()
	{
		return this.taints.map(taint => taint.getProfileLong()).join(', ');
	}

	getTypeName()
	{
		switch (this.type) {
		case 1: return 'Trace';
		case 10: return 'Exotic, ' + this.getDensityName();
		case 11: return 'Corrosive, ' + this.getDensityName();
		case 12: return 'Insidious, ' + this.getDensityName();
		case 14: return 'Low';
		case 15: return 'Unusual';
		case 16: return 'Gas, Helium';
		case 17: return 'Gas, Hydrogen';
		}
		return this.getDensityName();
	}
}

class AtmosphereTaint
{
	constructor(subtype, severity, persistence)
	{
		this.subtype = subtype;
		this.severity = severity;
		this.persistence = persistence;
	}

	getName()
	{
		switch (this.subtype) {
		case TAINT_B: return 'Biologic';
		case TAINT_G: return 'Gas Mix';
		case TAINT_H: return 'High Oxygen';
		case TAINT_L: return 'Low Oxygen';
		case TAINT_P: return 'Particulates';
		case TAINT_R: return 'Radioactivity';
		case TAINT_S: return 'Sulphur Compounds';
		}
		return 'Unknown';
	}

	getProfileShort()
	{
		return toHexCode(this.subtype);
	}

	getProfileLong()
	{
		return this.getProfileShort()
			+ '.' + this.severity
			+ '.' + this.persistence;
	}
}

class AbstractFactory
{
	constructor()
	{
		this.history = [];
	}

	generate() {}

	/**
	 * Adds the factory history onto the object, if any, then clears it
	 */
	flushHistory(object = null)
	{
		if (object) {
			object.history.push(...this.history);
		}
		this.history = [];
	}

	roll(n, d, dm, desc)
	{
		let result = new Roll(n, d, dm, desc);
		this.history.push(result);
		return result.total;
	}
}

class StarFactory extends AbstractFactory
{
	/**
	 * @param FormData options:
	 *   @option bool prime_main True to restrict the primary star to main-sequence types only
	 *   @option int  prime_peculiar For Peculiar resluts when rolling a Primary: 0 = Carry on, 1 = NS unless 1D = 6 (= BH), 2 = Reroll Unusual result
	 *   @option int  sec_giant_twin For Giant Secondary stars more massive than a Giant Primary: 0 = Twin method, 1 = Class V method
	 *   @option bool star_age_small True to increase precision when determing the age of small stars
	 *   @option bool star_age_large True to use 1D100/100 instead of ((1D-1)+(1D/6))/6 when determing the age of larger stars
	 *   @option bool star_flat_sub True to roll a straight d10-1 for the star's subtype instead of the appropriate 2D table
	 *   @option bool star_trad_gen True to use the traditional Traveller bell curve when generating star types
	 *   @option bool var_mass True to enable variations in star mass
	 *   @option bool var_nits True to enable variations in star luminosity
	 *   @option bool var_size True to enable variations in star diameter
	 *   @option bool var_temp True to enable variations in star temperature
	 */
	constructor(options)
	{
		super();
		this.prime_main = options.has('prime_main');
		this.prime_peculiar = +options.get('prime_peculiar');
		this.sec_giant_twin = +options.get('sec_giant_twin');
		this.star_age_small = options.has('star_age_small');
		this.star_age_large = options.has('star_age_large');
		this.flat_subtypes = options.has('star_flat_sub');
		this.trad_gen = options.has('star_trad_gen');
		this.enable_var_mass = options.has('var_mass');
		this.enable_var_nits = options.has('var_nits');
		this.enable_var_size = options.has('var_size');
		this.enable_var_temp = options.has('var_temp');
	}

	/**
	 * Complete the generation of a star with known type, subtype, and classification
	 *
	 * @param string entry Must be in the standard format TS C (i.e. Type Subtype Classification), e.g. M0 V
	 * @param bool primary True if this is for the primary star
	 *
	 * @throws SyntaxError if unable to parse the entry
	 */
	fromProfile(entry, primary = false)
	{
		const upper = entry.toUpperCase();
		const number = (entry.length > 1 ? Number.parseInt(upper.substring(1, 2)) : NaN);
		const subtype = (Number.isNaN(number) ? -1 : number);
		const type = this.parseType(subtype < 0 ? upper : upper.substring(0, 1));
		if (Number.isNaN(type)) {
			throw new SyntaxError('Failed to parse Type for star entry ' + entry + '; subtype = ' + subtype);
		} else if ((subtype < 0 && type <= MAIN_TYPE_M) || (subtype > -1 && type > MAIN_TYPE_M)) {
			throw new SyntaxError('Invalid Subtype for Type ' + type + ' star entry ' + entry);
		}
		const classification = this.parseClass(type, upper);
		const star = new Star(type, subtype, classification, primary);
		log('Successfully generated star from profile: ' + star.getProfileShort());
		this.genStarTraits(star);
		return star;
	}

	parseType(entry)
	{
		for (const k in STAR_TYPE) {
			if (STAR_TYPE[k] === entry) return k;
		}
		return NaN;
	}

	parseClass(type, entry)
	{
		if (type > MAIN_TYPE_M) return -1;
		// Special Case: Classes Ia and Ib
		if (entry.endsWith('IA')) return 0;
		if (entry.endsWith('IB')) return 1;
		return convertFromRoman(entry.substring(3));
	}

	/**
	 * @param Star|null primary Required when generating Secondary and/or Companion stars
	 * @param string method Required with @primary; valid values are: Random, Lesser, Sibling, Twin, D, and BD
	 */
	generate(primary = null, method = '')
	{
		// Step 1: Type, Class, and Subtype
		const star = this.genStar(primary, method);
		this.genStarTraits(star, primary, method);
		return star;
	}

	genStarTraits(star, primary = null, method = '')
	{
		// Step 2: Mass
		star.mass = this.genMass(star);
		star.mass_deviation = this.genMassDeviation(star);
		// Handle special cases for secondary stars
		const f = (star.classification > 3 ? 0.1 : 0.04);
		let floor = 0;
		let result = null;
		if (primary) {
			switch (method) {
			case 'Lesser':
				// fall-through
			case 'Random':
				// If more massive than primary star; subtract 1 deviation at a time until less massive or floor is reached
				const p_mass = primary.getTotalMass();
				const p_mass_lsd = 0.0001; // least significant digit
				if (star.getTotalMass() > (p_mass - p_mass_lsd)) {
					const one_deviation = (f * star.mass);
					const min_deviations = -5; // mininum result of 2D6-7; see #genMassDeviation
					let num_deviations = Math.round(star.mass_deviation / one_deviation);
					while (star.getTotalMass() > (p_mass - p_mass_lsd) && num_deviations > min_deviations) {
						log('Secondary star ' + star.getProfileShort() + ' more massive than primary; reducing mass by one deviation: -' + one_deviation);
						star.mass_deviation -= one_deviation;
						num_deviations--;
					}
				}
				if (star.getTotalMass() > p_mass) {
					log('Failed to reduce secondary star mass ' + star.getProfileShort() + ' below that of primary ' + primary.getProfileShort());
				}
				break;
			case 'Sibling':
				// Sibling's mass should not initially exceed that of its primary (which could be a companion host), but may be less
				star.mass = Math.min(star.mass, primary.mass);
				star.mass_deviation = Math.min(star.mass_deviation, primary.mass_deviation);
				// Reduce mass by 1D x 10%, but not past minimum
				floor = -f * 5 * star.mass;
				result = 0.1 * this.roll(1, 6, 0, 'Sibling Star Variance: Mass');
				star.mass_deviation = Math.max(floor, star.mass_deviation - (result * star.mass));
				break;
			case 'Twin':
				// Set the twin's mass to that of its primary (which could be a companion host), then reduce it slightly
				star.mass = primary.mass;
				star.mass_deviation = primary.mass_deviation;
				// Optionally reduce mass by 1D x 1%, but not past minimum
				floor = -f * 5 * star.mass;
				result = 0.01 * this.roll(1, 6, 0, 'Twin Star Variance: Mass');
				star.mass_deviation = Math.max(floor, star.mass_deviation - (result * star.mass));
				break;
			default:
				// no-op
			}
		}
		
		// Step 3: Age, since it depends only on Mass and some subsequent steps may require it (e.g. for White Dwarfs)
		star.age = this.genAge(star);
		
		// Step 4: Temperature
		star.temperature = this.genTemperature(star, primary);
		star.temperature_deviation = this.genTemperatureDeviation(star, primary);
		
		// Step 5: Diameter
		star.diameter = this.genDiameter(star, primary);
		star.diameter_deviation = this.genDiameterDeviation(star, primary);
		// Handle special cases for secondary stars
		if (primary && method === 'Twin') {
			// Optionally reduce diameter by 1D x 1%, but not past minimum
			floor = -f * 5 * star.diameter;
			result = 0.01 * this.roll(1, 6, 0, 'Twin Star Variance: Diameter');
			star.diameter_deviation = Math.max(floor, star.diameter_deviation - (result * star.diameter));
		}
		
		// Step 6: Luminosity and HZCO
		star.luminosity = this.genLuminosity(star, primary);
		star.luminosity_deviation = this.genLuminosityDeviation(star, primary);
		star.hzco = calculateHabitableCenterZone(star.getTotalLuminosity());
	}

	genStar(primary, method)
	{
		let star = null;
		// Attempt to generate a valid Secondary using the requested method; for Random, this will always return null
		if (primary) {
			// Special Case: Protostar primaries pass in their future state when generating secondary stars
			const dummy = (primary.type === PROTOSTAR ? new Star(primary.proto_type, primary.proto_subtype, primary.proto_classification) : primary);
			log('Generating secondary star using the [' + method + '] method for primary ' + dummy.getProfileShort());
			star = this.genSecondaryStar(dummy, method);
			// Special Case: Protostars reroll the secondary until the result is a supported star type
			const p_max_type = Math.max(BROWN_DWARF, WHITE_DWARF);
			while (star && star.type > p_max_type && primary.type === PROTOSTAR) {
				log('Protostar Primary: rerolling unsupported secondary star type of ' + star.getProfileShort());
				star = this.genSecondaryStar(dummy, method);
			}
			if (star) {
				// Special Case: Protostar primary requires all secondaries to be Protostars as well
				if (primary.type === PROTOSTAR) {
					this.setProtostarDataFrom(star, star);
				}
				log('Valid secondary stellar object generated: ' + star.getProfileShort());
				return star;
			}
		}
		// Standard star generation (i.e. Primary or Random Secondary)
		star = this.genTypeAndClass(primary);
		// Special Case: Protostars must be rerolled if the primary is NOT a protostar
		if (primary && primary.type !== PROTOSTAR) {
			while (star.type === PROTOSTAR) {
				log('Non-Protostar Primary: rerolling protostar secondary star result...');
				star = this.genTypeAndClass(primary);
			}
		}
		if (primary) {
			star.primary = false;
		}
		// Special Case: Protostars require rolling for the kind of star they will become, with DM+1 on first roll of the star type table
		let proto = null;
		let proto_tmp = null;
		if (star.type === PROTOSTAR) {
			// DM+1 ensures a main-sequence star
			proto = this.genTypeAndClass(primary, 1);
			// Special Case: Type O Protostars would develop too quickly; change to Type B
			if (proto.type === MAIN_TYPE_O) {
				proto.type = MAIN_TYPE_B;
			}
			// Swap the star and proto temporarily to allow the remaining rules to be applied
			proto_tmp = star;
			star = proto;
			proto = proto_tmp;
		}
		star.subtype = this.genSubtype(star);
		// Special Case: Type K Class IV stars subtract 5 from any subtype result of 4+
		if (star.type === MAIN_TYPE_K && star.subtype > 4 && star.classification === 4) {
			log('Invalid subtype ' + star.subtype + ' for K IV star; reducing by 5');
			star.subtype -= 5;
		}
		// Randomly-generated non-primary main-sequence stars treat any results of hotter type/subtype as lesser instead
		if (!star.primary && star.subtype > -1 && star.type <= MAIN_TYPE_M) {
			const p_star = (primary.type === PROTOSTAR ? new Star(primary.proto_type, primary.proto_subtype, primary.proto_classification) : primary);
			// Set to same stellar type and allow the subtype to make it cooler
			if (star.type < p_star.type) {
				log('Secondary ' + star.getProfileShort() + ' star is hotter than primary ' + p_star.getProfileShort() + ', reducing type to match primary');
				star.type = p_star.type;
			}
			// Special Case: Giant Class stars may become more massive as they cool; adjust so they do not become more massive than the primary, if possible
			let allow_sub_mod = this.adjustSecondaryGiant(p_star, star);
			// Adjust subtype if still hotter than primary, which may further change the star's type
			if (allow_sub_mod && star.type === p_star.type && star.subtype < p_star.subtype) {
				log('Secondary ' + star.getProfileShort() + ' star still hotter than primary, reducing subtype');
				star.subtype = p_star.subtype + 1;
				if (star.subtype > 9) {
					star.subtype -= 10;
					star.type += 1;
					log('Change in subtype resulted in cooler type: secondary star reduced to ' + star.getProfileShort());
				}
			}
			// Special Case: Class IV K5+ and M0+ (in case of above adjustments)
			this.adjustClassFourIfTooCool(star);
			// Special Case: Class VI changes any Type A to B and F to G
			this.adjustInvalidClassSix(star);
			// Any star that moves beyond the main sequence becomes a brown dwarf
			if (star.type > MAIN_TYPE_M) {
				log('Secondary star moved out of main sequence; reduced to Brown Dwarf');
				this.setStarData(star, BROWN_DWARF, -1, -1);
			}
		}
		// Special Case: Swap Prostar back in and store the type of star it will become
		if (proto) {
			proto_tmp = star; // i.e. the protostar's future state
			star = proto;     // i.e. the actual protostar
			this.setProtostarDataFrom(star, proto_tmp);
		}
		// Special Case: If the primary star is a Protostar, all secondary objects must also be protostars
		if (primary && primary.type === PROTOSTAR && star.type !== PROTOSTAR) {
			this.setProtostarDataFrom(star, star);
		}
		// Sanity check
		if (star.type <= MAIN_TYPE_M) {
			if (!STAR_DATA.hasOwnProperty(star.type)) {
				log('Invalid star type: ' + star.type);
			} else if (!STAR_DATA[star.type].hasOwnProperty(star.classification)) {
				log('Invalid star class: ' + star.classification + ' for type: ' + star.type);
			} else if (!STAR_DATA[star.type][star.classification].hasOwnProperty(star.subtype)) {
				log('Invalid star subtype: ' + star.subtype + ' for type: ' + star.type + ' and class: ' + star.classification);
			} else {
				log('Valid star generated: ' + star.getProfileShort());
			}
		} else if (star.subtype > -1) {
			log('Invalid subtype: ' + star.type + ' for otherwise valid stellar object: ' + star.getProfileShort());
		} else if (star.classification > -1) {
			log('Invalid class: ' + star.classification + ' for otherwise valid stellar object: ' + star.getProfileShort());
		} else {
			log('Valid stellar object generated: ' + star.getProfileShort());
		}
		return star;
	}

	genSecondaryStar(primary, method)
	{
		switch (method) {
		case 'BD':
			return new Star(BROWN_DWARF, -1, -1, false);
		case 'D':
			return new Star(WHITE_DWARF, -1, -1, false);
		case 'Lesser':
			// Same class but one type cooler, e.g. F becomes G, etc., and reroll subtype
			let lesser = new Star(primary.type, -1, primary.classification, false);
			if (lesser.type === BLACK_HOLE) {
				// Special Case: A lesser Black Hole becomes a Neutron Star
				lesser.type = NEUTRON_STAR;
			} else if (lesser.type === NEUTRON_STAR || lesser.type === PULSAR) {
				// Special Case: A lesser Neutron Star or Pulsar becomes a White Dwarf
				lesser.type = WHITE_DWARF;
			} else if (lesser.type === WHITE_DWARF) {
				// Special Case: A lesser White Dwarf becomes a Brown Dwarf
				lesser.type = BROWN_DWARF;
			} else if (lesser.type === MAIN_TYPE_M) {
				// M-type remains the same type (for now)
			} else if (lesser.type < MAIN_TYPE_M) {
				// All other main sequence stars become one type cooler, i.e. bigger numeric type
				lesser.type += 1;
			}
			// Reroll the new subtype
			lesser.subtype = this.genSubtype(lesser);
			// Special Case: Giant Class stars may become more massive as they cool in some cases
			let allow_sub_mod_lesser = this.adjustSecondaryGiant(primary, lesser);
			// Special Case: M-type becomes a brown dwarf if it is hotter (i.e. lower numeric subtype) than its parent
			if (allow_sub_mod_lesser && lesser.type === MAIN_TYPE_M && lesser.type === primary.type && lesser.subtype < primary.subtype) {
				log('Lesser Type M star reduced to Brown Dwarf');
				this.setStarData(lesser, BROWN_DWARF, -1, -1);
			}
			// Special Case: Class IV K5+ and M0+
			this.adjustClassFourIfTooCool(lesser);
			// Special Case: Class VI changes any Type A to B and F to G
			this.adjustInvalidClassSix(lesser);
			return lesser;
		case 'Random':
			// Roll as normal, but treat any results of hotter type/subtype as lesser instead
			return null;
		case 'Sibling':
			let sibling = new Star(primary.type, primary.subtype, primary.classification, false);
			// All non-main sequence stars retain their primary star's characteristics
			if (sibling.type > MAIN_TYPE_M) {
				return sibling;
			}
			// Special Case: Giant Class stars may become more massive as they cool in some cases
			let allow_sub_mod_sibling = this.adjustSecondaryGiant(primary, sibling);
			// Add 1D to the subtype (i.e. cooler), subtracting 10 instead if this moves to a lower type
			sibling.subtype += (allow_sub_mod_sibling ? this.roll(1, 6, 0, 'Sibling Star Subtype Modifier') : 0);
			if (sibling.subtype > 9) {
				sibling.subtype -= 10;
				sibling.type += 1;
				// Special Case: M-type becomes a Brown Dwarf if it moves out of the main sequence
				if (sibling.type > MAIN_TYPE_M) {
					this.setStarData(sibling, BROWN_DWARF, -1, -1);
				}
				log('Sibling star subtype reduction moved star to next lower class; new profile: ' + sibling.getProfileShort());
			}
			// Special Case: Class IV K5+ and M0+
			this.adjustClassFourIfTooCool(sibling);
			// Special Case: Class VI changes any Type A to B and F to G
			this.adjustInvalidClassSix(sibling);
			return sibling;
		case 'Twin':
			return new Star(primary.type, primary.subtype, primary.classification, false);
		}
		log('Unknown method for secondary star generation: ' + method);
		return null;
	}

	genTypeAndClass(primary = null, proto_dm = 0)
	{
		let classification = -1;
		let result = this.roll(2, 6, proto_dm, 'Star Type: ' + (this.trad_gen ? 'Traditional Table' : 'Realistic Table'));
		let type = (this.trad_gen ? TYPE_TRAD[result] : TYPE_REAL[result]);
		if (type > ANOMALY) {
			result = this.roll(2, 6, 0, 'Star Type: Hot Table');
			type = TYPE_HOT[result];
			classification = 5; // Class V
		} else if (type < 0) {
			if (this.prime_main) {
				result = this.roll(2, 6, 0, 'Star Type: Special Table');
				classification = CLASS_SPECIAL[result];
				if (classification > 15) {
					result = this.roll(2, 6, 0, 'Star Type: Giant Table');
					classification = CLASS_GIANT[result];
				}
			} else {
				result = this.roll(2, 6, 0, 'Star Type: Unusual Table');
				classification = CLASS_UNUSUAL[result];
				// Option 2: Reroll any Peculiar result when generating a Primary Star
				if (primary === null && this.prime_peculiar === 2) {
					while (classification < 0) {
						result = this.roll(2, 6, 0, 'Star Type: Rerolling Peculiar Result');
						classification = CLASS_UNUSUAL[result];
					}
				}
				if (classification < 0) {
					// Option 1: Roll 1D for any Peculiar result when generating a Primary Star; 1-5 = NS and 6 = BH
					if (primary === null && this.prime_peculiar === 1) {
						result = this.roll(1, 6, 0, 'Star Type: Peculiar, 1D version (1-5 = NS, 6 = BH)');
						type = (result > 5 ? BLACK_HOLE : NEUTRON_STAR);
					} else {
						// Option 0 and non-Primary stars - roll on!
						result = this.roll(2, 6, 0, 'Star Type: Peculiar Table');
						type = TYPE_PECULIAR[result];
					}
				} else if (classification > 15) {
					result = this.roll(2, 6, 0, 'Star Type: Giant Table');
					classification = CLASS_GIANT[result];
				} else if (classification === BROWN_DWARF || classification === WHITE_DWARF) {
					// Special Case: Types D and BD
					type = classification;
					classification = -1; // undefined
				}
			}
		} else {
			classification = 5; // Class V
		}
		const star = new Star(type, -1, classification);
		// Reroll for Type with DM+1 if only Class determined
		if (star.type < 0 && star.classification > -1) {
			result = this.roll(2, 6, 1, 'Star Type: Reroll w/DM+1');
			star.type = (this.trad_gen ? TYPE_TRAD[result] : TYPE_REAL[result]);
			if (star.type > ANOMALY) {
				result = this.roll(2, 6, 0, 'Star Type: Hot Table');
				star.type = TYPE_HOT[result];
			}
		}
		// Special Case: Class IV adds DM+5 to any Type M and changes Type O to B
		if (star.classification === 4) {
			if (star.type === MAIN_TYPE_M) {
				star.type = (this.trad_gen ? TYPE_TRAD[result + 5] : TYPE_REAL[result + 5]);
			}
			if (star.type === MAIN_TYPE_B) {
				star.type = MAIN_TYPE_B;
			}
		}
		// Special Case: Class VI changes any Type A to B and F to G
		this.adjustInvalidClassSix(star);
		log('Star type and class (initial values) determined: ' + star.type + ', ' + star.classification);
		return star;
	}

	genSubtype(star)
	{
		// Only main-sequence stars have a subtype
		if (star.type > MAIN_TYPE_M) {
			return -1;
		}
		const mtype = (star.primary && star.type === MAIN_TYPE_M);
		// M-Types always use the Straight Roll method when using traditional traveler generation
		if (this.flat_subtypes || (mtype && this.trad_gen)) {
			return this.roll(1, 10, -1, 'Star Subtype: Straight');
		}
		const result = this.roll(2, 6, 0, 'Star Subtype: ' + (mtype ? 'M-Type' : 'Numeric'));
		if (mtype) {
			return SUBTYPE_M_PRIMARY[result];
		}
		// Special Case for K IV stars handled externally to allow Lesser and Sibling secondaries of a cooler subtype, which then transition to Class V stars instead
		return SUBTYPE_NUMERIC[result];
	}

	setProtostarDataFrom(proto, star)
	{
		proto.proto_type = star.type;
		proto.proto_subtype = star.subtype;
		proto.proto_classification = star.classification;
		this.setStarData(proto, PROTOSTAR, -1, -1);
		log('Protostar future star profile set to: ' + star.getProfileShort());
	}

	setStarData(star, type, subtype, classification)
	{
		star.type = type;
		star.subtype = subtype;
		star.classification = classification;
	}

	genMass(star)
	{
		// Table lookup by Type + Subtype + Class for all OBAFGKM-type stars
		if (star.type <= MAIN_TYPE_M) {
			log('Star Data [Mass]: looking up Type ' + star.type + ', Subtype ' + star.subtype + ', and Class ' + star.classification);
			return STAR_DATA[star.type][star.classification][star.subtype]['M'];
		}
		// Special Case: Protostar systems determine mass as the star they will become, with up to +/- 50% variance (applied via #genMassDeviation)
		if (star.type === PROTOSTAR && star.proto_type <= MAIN_TYPE_M) {
			log('Star Data [Mass]: looking up Protostar Type ' + star.proto_type + ', Subtype ' + star.proto_subtype + ', and Class ' + star.proto_classification);
			return STAR_DATA[star.proto_type][star.proto_classification][star.proto_subtype]['M'];
		}
		const label = 'Star Mass: ' + star.getName();
		// Special Case: Brown Dwarf = 1D/100 + (4D-1)/1000 [0.013 to 0.08]
		if (star.type === BROWN_DWARF || (star.type === PROTOSTAR && star.proto_type === BROWN_DWARF)) {
			return (0.01 * this.roll(1, 6, 0, label))
				+ (0.001 * this.roll(4, 6, -1, label));
		}
		// Special Case: White Dwarf = (2D-1)/10 + d10/100
		if (star.type === WHITE_DWARF || (star.type === PROTOSTAR && star.proto_type === WHITE_DWARF)) {
			return (0.1 * this.roll(2, 6, -1, label))
				+ (0.01 * this.roll(1, 10, 0, label));
		}
		// Special Case: Neutron Star = 1 + (1D/10), and if that was a 6, then add another (1D-1)/10
		// Pulsars are a type of NS so use the same formula here
		if (star.type === NEUTRON_STAR || star.type === PULSAR) {
			let base = this.roll(1, 6, 0, label);
			let mass = 1 + (0.1 * base);
			if (base === 6) {
				mass += 0.1 * this.roll(1, 6, -1, label);
			}
			return mass;
		}
		// Special Case: Black Hole = 1.1 + 1Dp + d10/10; 1D penetrates on 6 - keep rolling!
		if (star.type === BLACK_HOLE) {
			let mass = 1.1 + (0.1 * this.roll(1, 10, 0, label));
			let roll = 0;
			do {
				roll = this.roll(1, 6, 0, label);
				mass += roll;
			} while (roll === 6);
			return mass;
		}
		// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
		return 0.001;
	}

	genMassDeviation(star)
	{
		// Skip if not enabled
		if (!this.enable_var_mass) {
			return 0;
		}
		// Ignore mass variance for any post-stellar objects
		if (star.isPostStellar()) {
			return 0;
		}
		const result = this.roll(2, 6, -7, 'Star Variance: Mass');
		return (star.classification > 3 || star.type === PROTOSTAR
			? result * 0.1 * star.mass    // Giant  = +/- 50%, 0.1  = 0.2 * 0.5 (and also any Protostar, not just future Giants)
			: result * 0.04 * star.mass); // Normal = +/- 20%, 0.04 = 0.2 * 0.2
	}

	/**
	 * Star temperature may depend on mass and/or age
	 */
	genTemperature(star, primary = null)
	{
		// Table lookup by Type + Subtype + Class for all OBAFGKM-type stars
		if (star.type <= MAIN_TYPE_M) {
			log('Star Data [Temp]: looking up Type ' + star.type + ', Subtype ' + star.subtype + ', and Class ' + star.classification);
			return STAR_DATA[star.type][star.classification][star.subtype]['T'];
		}
		// Special Case: Protostar systems determine temperature as the star they will become
		if (star.type === PROTOSTAR && star.proto_type <= MAIN_TYPE_M) {
			log('Star Data [Temp]: looking up Protostar Type ' + star.proto_type + ', Subtype ' + star.proto_subtype + ', and Class ' + star.proto_classification);
			return STAR_DATA[star.proto_type][star.proto_classification][star.proto_subtype]['M'];
		}
		// Special Case: Brown Dwarf = lookup table (by mass)
		if (star.type === BROWN_DWARF || (star.type === PROTOSTAR && star.proto_type === BROWN_DWARF)) {
			return this.getBrownDwarfData(star)['T'];
		}
		// Special Case: White Dwarf  = lookup table (by age) * (M / 0.6)
		// Special Case: Neutron Star = as White Dwarf
		// Pulsars are a type of NS and use the same formula here
		if ([WHITE_DWARF, NEUTRON_STAR, PULSAR].includes(star.type) || (star.type === PROTOSTAR && [WHITE_DWARF, NEUTRON_STAR, PULSAR].includes(star.proto_type))) {
			return this.getWhiteDwarfData(star, primary)['T'] * star.mass / 0.6;
		}
		// Special Case: Black Holes, by definition, do not radiate heat, but the accretion disk may generate a great deal of electromagnetic radiaion
		if (star.type === BLACK_HOLE) {
			return 0;
		}
		// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
		return 100;
	}

	genTemperatureDeviation(star, primary = null)
	{
		// Skip if not enabled
		if (!this.enable_var_temp) {
			return 0;
		}
		const type = (star.type === PROTOSTAR ? star.proto_type : star.type);
		// Ignore temperature variance for any non-main sequence object
		if (type > MAIN_TYPE_M) {
			return 0;
		}
		const classification = (star.type === PROTOSTAR ? star.proto_classification : star.classification);
		const subtype = (star.subtype === PROTOSTAR ? star.proto_subtype : star.subtype);
		const sub_lookup = (subtype > 0 ? subtype - 1 : subtype + 1);
		log('Star Data [Temp]: looking up Type ' + type + ', Subtype ' + subtype + ', and Class ' + classification + ' (deviation)');
		const a = star.temperature;
		const b = STAR_DATA[type][classification][sub_lookup]['T'];
		const max_diff = (a > b ? a - b : b - a) / 2;
		const result = this.roll(1, 101, -51, 'Star Variance: Temperature');
		return result * 0.01 * max_diff;
	}

	/**
	 * Star diameter depends on mass
	 */
	genDiameter(star, primary = null)
	{
		// Table lookup by Type + Subtype + Class for all OBAFGKM-type stars
		if (star.type <= MAIN_TYPE_M) {
			log('Star Data [Size]: looking up Type ' + star.type + ', Subtype ' + star.subtype + ', and Class ' + star.classification);
			return STAR_DATA[star.type][star.classification][star.subtype]['D'];
		}
		// Special Case: Protostar systems multiply any resulting diameter by 1 + (2D-2) ÷ 10
		const proto_f = (star.type === PROTOSTAR ? (1 + this.roll(2, 6, -2, 'Star Diameter: Protostar inherent variability') / 10) : 1);
		// Special Case: Protostar systems; treat as Class V of same type and subtype
		if (star.type === PROTOSTAR && star.proto_type <= MAIN_TYPE_M) {
			log('Star Data [Size]: looking up Protostar Type ' + star.proto_type + ', Subtype ' + star.proto_subtype + ', and Class ' + star.proto_classification + ' (but treated as Class V for this calculation)');
			return proto_f * STAR_DATA[star.proto_type][5][star.proto_subtype]['D'];
		}
		// Special Case: Brown Dwarf = 0.1, unless 0.05 < M < 0.07, in which case roll as large Gas Giant (the planet), i.e. 2D+6, w/DM-2
		if (star.type === BROWN_DWARF || (star.type === PROTOSTAR && star.proto_type === BROWN_DWARF)) {
			let m = star.getTotalMass();
			if (m > 0.05 && m < 0.07 ? -2 : 0) {
				// Convert planetary Terra-based diameter to stellar Sol units
				return proto_f * (TERRA_DIAMETER * this.roll(2, 6, 4, 'Star Diameter: ' + star.getName())) / SOL_DIAMETER;
			}
			return proto_f * 0.1;
		}
		// Special Case: White Dwarf = 0.01 / M
		if (star.type === WHITE_DWARF || (star.type === PROTOSTAR && star.proto_type === WHITE_DWARF)) {
			return proto_f * 0.01 / star.getTotalMass();
		}
		// Special Case: Neutron Star = 1D + 19 km (remember to CONVERT to Sol Diameters!!!)
		// Pulsars are a type of NS so use the same formula here
		if (star.type === NEUTRON_STAR || star.type === PULSAR) {
			return (19 + this.roll(1, 6, 0, 'Star Diameter: ' + star.getName())) / SOL_DIAMETER;
		}
		// Special Case: Black Hole = 5.9 km * M (remember to CONVERT to Sol Diameters!!!)
		if (star.type === BLACK_HOLE) {
			return (5.9 * star.getTotalMass()) / SOL_DIAMETER;
		}
		// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
		return 1;
	}

	genDiameterDeviation(star, primary = null)
	{
		// Skip if not enabled
		if (!this.enable_var_size) {
			return 0;
		}
		// Special Case: Protostar diameters have built-in variability (see #genDiameter) so don't need any extra added here
		// Ignore variance any non-main sequence object
		if (star.type > MAIN_TYPE_M) {
			return 0;
		}
		const result = this.roll(2, 6, -7, 'Star Variance: Diameter');
		return (star.classification > 3
			? result * 0.1 * star.diameter    // Giant  = +/- 50%, 0.1  = 0.2 * 0.5
			: result * 0.04 * star.diameter); // Normal = +/- 20%, 0.04 = 0.2 * 0.2
	}

	/**
	 * Luminosity depends on diameter and temperature; may also depend on mass and/or age for certain star types
	 */
	genLuminosity(star, primary = null)
	{
		let compute = !this.enable_var_nits;
		// Special Case: Neutron Star = can be computed, provided diameter is in Sol units instead of km (which was done in genDiameter)
		// Pulsars are a type of NS so use the same formula here
		// Special Case: Protostar systems have highly variable diameters and should thus always use the calculation
		if ([NEUTRON_STAR, PULSAR, PROTOSTAR].includes(star.type)) {
			compute = true;
		}
		// Non-variable luminosity is calculated based on diameter and temperature
		if (compute) {
			const SOL_TEMP = 5772;
			return Math.pow(star.getTotalDiameter(), 2) * Math.pow(star.getTotalTemperature() / SOL_TEMP, 4);
		}
		// Table lookup by Type + Subtype + Class for all OBAFGKM-type stars
		if (star.type <= MAIN_TYPE_M) {
			log('Star Data [Lum.]: looking up Type ' + star.type + ', Subtype ' + star.subtype + ', and Class ' + star.classification);
			return STAR_DATA[star.type][star.classification][star.subtype]['L'];
		}
		// Special Case: Brown Dwarf = lookup table (by mass)
		if (star.type === BROWN_DWARF) {
			return this.getBrownDwarfData(star)['L'];
		}
		// Special Case: White Dwarf = lookup table (by age)
		if (star.type === WHITE_DWARF) {
			return this.getWhiteDwarfData(star, primary)['L'];
		}
		// Special Case: Black Hole = 0, other than as remnants from e.g. shredded stars
		if (star.type === BLACK_HOLE) {
			return 0;
		}
		// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
		return 0;
	}

	genLuminosityDeviation(star, primary = null)
	{
		// Skip if not enabled
		if (!this.enable_var_nits) {
			return 0;
		}
		// Ignore variance for post-stellar objects
		if (star.isPostStellar()) {
			return 0;
		}
		const result = this.roll(2, 6, -7, 'Star Variance: Luminosity');
		return (star.classification > 3 || (star.type === PROTOSTAR && star.proto_classification > 3)
			? result * 0.1 * star.luminosity    // Giant  = +/- 50%, 0.1  = 0.2 * 0.5
			: result * 0.04 * star.luminosity); // Normal = +/- 20%, 0.04 = 0.2 * 0.2
	}

	/**
	 * The age of a star depends only upon its mass
	 */
	genAge(star)
	{
		const mass = star.getTotalMass();
		star.life_main = 10 / Math.pow(mass, 2.5);
		star.life_subgiant = star.life_main / (4 + mass);
		star.life_giant = star.life_main / (10 * Math.pow(mass, 3));
		if (star.type > MAIN_TYPE_M) {
			let age = 0;
			// White Dwarf, Neutron Star, Pulsar, and Black Hole all add the Dead Star formula
			if ([WHITE_DWARF, NEUTRON_STAR, PULSAR, BLACK_HOLE].includes(star.type)) {
				age += this.genAgeDead(star);
			}
			// Brown Dwarf, White Dwarf, Neutron Star, and Black Hole add the Small Star formula
			if ([BROWN_DWARF, WHITE_DWARF, NEUTRON_STAR, BLACK_HOLE].includes(star.type)) {
				age += this.genAgeSmall(star);
			}
			// Pulsars add (100,000,000 years i.e. 0.1 Gyr / 2d10)
			if (star.type === PULSAR) {
				age += 0.1 / this.roll(2, 10, 0, 'Age: Pulsar');
			}
			// Protostars add (10,000,000 years i.e. 0.01 Gyr / 2d10)
			if (star.type === PROTOSTAR) {
				age += 0.01 / this.roll(2, 10, 0, 'Age: Protostar');
			}
			// Nebulae, Star Clusters, and Anomalies can be handled by the GM on a case-by-case basis
			return age;
		} else if (star.classification < 4) {
			// Giant
			return this.genAgeGiant(star);
		} else if (star.classification === 4) {
			// Subgiant
			return this.genAgeSubgiant(star);
		} else if (star.getTotalMass() > 0.9) {
			// Large Star
			return this.genAgeLarge(star);
		}
		// Small Star
		return this.genAgeSmall(star);
	}

	genAgeGiant(star)
	{
		const f = (this.star_age_large
			? 0.01 * this.roll(1, 100, 0, 'Age: Giant Star')
			: (this.roll(1, 6, -1, 'Age: Giant Star') + (this.roll(1, 6, 0, 'Age: Giant Star') / 6)) / 6);
		return star.life_main + star.life_subgiant + (f * star.life_giant);
	}

	genAgeSubgiant(star)
	{
		const f = (this.star_age_large
			? 0.01 * this.roll(1, 100, 0, 'Age: Subgiant Star')
			: (this.roll(1, 6, -1, 'Age: Subgiant Star') + (this.roll(1, 6, 0, 'Age: Subgiant Star') / 6)) / 6);
		return star.life_main + (f * star.life_subgiant);
	}

	genAgeLarge(star)
	{
		const min = (star.getTotalMass() < 4.7 ? 0.01 : 0.1);
		if (this.star_age_large) {
			return Math.max(min, star.life_main * 0.01 * this.roll(1, 100, 0, 'Age: Large Star'));
		} else {
			return Math.max(min, star.life_main * (this.roll(1, 6, -1, 'Age: Large Star') + (this.roll(1, 6, 0, 'Age: Large Star') / 6)) / 6);
		}
	}

	genAgeSmall(star)
	{
		const a = (2 * this.roll(1, 6, 0, 'Age: Small Star'));
		const b = this.roll(1, 3, (this.star_age_small ? -2 : -1), 'Age: Small Star');
		const c = (this.star_age_small ? this.roll(1, 10, 0, 'Age: Small Star') / 10 : 0);
		const min = 0.1;
		const max = 12;
		return clamp(a + b + c, min, max);
	}

	genAgeDead(star)
	{
		const mass = this.roll(1, 3, 2, 'Age: Dead Star, Prior Mass') * star.getTotalMass();
		const main = 10 / Math.pow(mass, 2.5);
		const sub = main / (4 + mass);
		const giant = main / (10 * Math.pow(mass, 3));
		return main + sub + giant;
	}

	getWhiteDwarfData(star, primary)
	{
		const eff_age = (primary ? primary.age : star.age);
		const lookup = WHITE_DWARF_DATA.findLast(row => eff_age >= row['A']);
		log('White Dwarf (or equivalent) data lookup for effective age ' + eff_age + ': ' + (lookup === undefined ? 'FAIL - fallback to last entry' : 'Matched Age: ' + lookup['A']));
		return lookup === undefined
			? WHITE_DWARF_DATA[WHITE_DWARF_DATA.length - 1]
			: lookup;
	}

	getBrownDwarfData(star)
	{
		// Allow for up to half of the interpolated deviation between each row to achieve better matching
		const deviation = 0.00375;
		const mass = star.getTotalMass() + deviation;
		const lookup = BROWN_DWARF_DATA.find(row => mass > row['M']);
		log('Brown Dwarf (or equivalent) data lookup for effective mass ' + mass + ': ' + (lookup === undefined ? 'FAIL - fallback to last entry' : 'Matched Mass: ' + lookup['M']));
		return lookup === undefined
			? BROWN_DWARF_DATA[BROWN_DWARF_DATA.length - 1]
			: lookup;
	}

	/** 
	 * Special Case: Class IV stars of type K5+ or M0+; these move to Class V instead
	 */
	adjustClassFourIfTooCool(star)
	{
		if (star.classification === 4 && (star.type === MAIN_TYPE_M || (star.type === MAIN_TYPE_K && star.subtype > 4))) {
			log('Class IV star ' + star.getProfileShort() + ' is too cool, changing to Class V');
			star.classification = 5;
		}
	}

	/** 
	 * Special Case: Class VI changes any Type A to B and F to G
	 */
	adjustInvalidClassSix(star)
	{
		if (star.classification === 6) {
			if (star.type === MAIN_TYPE_A) {
				log('Invalid Type A Class VI star changed to Type B');
				star.type = MAIN_TYPE_B;
			}
			if (star.type === MAIN_TYPE_F) {
				log('Invalid Type F Class VI star changed to Type G');
				star.type = MAIN_TYPE_G;
			}
		}
	}

	/**
	 * Special Case: Giant-class stars begin increasing in mass as they cool starting at G1 (K1 for Class III);
	 * this function ensures such a Secondary does not become more massive than its Giant-class Primary
	 *
	 * @return bool True if the star's resulting subtype is allowed to be further modified
	 */
	adjustSecondaryGiant(primary, star)
	{
		if (star.type < primary.type || star.classification > primary.classification || !primary.isGiant() || !star.isGiant()) {
			// no adjustment needed
		} else if ((star.classification < 3 && star.type >= MAIN_TYPE_G) || star.type >= MAIN_TYPE_K) {
			if (this.sec_giant_twin) {
				log('Giant-class Secondary ' + star.getProfileShort() + ' star will become more massive as it cools; changing it to be a Twin of the primary');
				this.setStarData(star, primary.type, primary.subtype, primary.classification);
				return false;
			} else {
				log('Giant-class Secondary ' + star.getProfileShort() + ' star will become more massive as it cools; changing it to Class V of at least the same Type as the Primary');
				this.setStarData(star, Math.max(star.type, primary.type), star.subtype, 5);
				// Allow modifying subtype for everything but Type M so the former Giant does not end up as
				// a Brown Dwarf; it is already guaranteed to be cooler and less massive than the Primary
				return star.type < MAIN_TYPE_M;
			}
		}
		return true;
	}

	adjustForPostStellarObject(object, primary)
	{
		if (!object.isPostStellar() || object.age <= primary.life_main) {
			return;
		}
		// Prevent running to infinity by setting a hard limit
		const max_mass = 1000000;
		while (object.age > primary.life_main && object.getTotalMass() < max_mass) {
			log('Increasing mass of post-stellar object (m = ' + object.getTotalMass() + ') to accomodate primary main sequence limit of ' + primary.life_main);
			this.increasePostStellarObjectMass(object, primary);
		}
		// Recalculate temperature, diameter, and luminosity based on increased mass and current post-stellar type
		// Exclusion zones (MAO) are calculated in a later step, so no need to worry about them here
		object.temperature = this.genTemperature(object, primary);
		object.diameter = this.genDiameter(object, primary);
		object.luminosity = this.genLuminosity(object, primary);
	}

	increasePostStellarObjectMass(object, primary)
	{
		const f = 0.01 * this.roll(2, 6, 3, 'Post-Stellar Mass Adjustment: ' + object.getName());
		object.mass = (1 + f) * object.mass;
		// Special Case: White Dwarfs become Neutron Stars when their mass exceeds 1.2
		if (object.type === WHITE_DWARF && object.getTotalMass() > 1.2) {
			object.type = NEUTRON_STAR;
		}
		// Special Case: Neutron Stars become Black Holes when their mass exceeds 2.16
		if (object.type === NEUTRON_STAR && object.getTotalMass() > 2.16) {
			object.type = BLACK_HOLE;
		}
		// Use the Final Age formula (i.e. Dead Star); do NOT include the Small Star Age for this step
		object.age = this.genAgeDead(object);
	}
}

class StarSystemFactory extends AbstractFactory
{
	/**
	 * @param StarFactory  star_factory
	 * @param WorldFactory world_factory
	 * @param FormData options:
	 *   @option bool enable_ecc True to calculate orbital eccentricities
	 *   @option bool var_orbit True to enable variations in star orbits
	 *   @option bool cumulative_orbit True to calculate each planetary orbit from the previous orbit, i.e. with cumulative variance
	 *   @option bool per_star_baseline True to calculate baseline number, baseline Orbit#, and system spread for each secondary and companion star separately
	 *   @option bool per_star_empty_orbits True to determine empty orbits for each star (or group) individually, rather than for the system as a whole
	 *   @option bool cont_sec True to enable checking for secondary stars when only the primary was provided (Continuation Method)
	 */
	constructor(star_factory, world_factory, options)
	{
		super();
		this.star_factory = star_factory;
		this.world_factory = world_factory;
		this.enable_eccentricity = options.has('enable_ecc');
		this.enable_var_orbit = options.has('var_orbit');
		this.cumulative_orbit = options.has('cumulative_orbit');
		this.per_star_baseline = options.has('per_star_baseline');
		this.per_star_empty_orbits = options.has('per_star_empty_orbits');
		this.continuation_add_secondaries = options.has('cont_sec');
		this.bands = ['Primary', 'Close', 'Near', 'Far'];
	}

	/**
	 * @param array profile_stars Optional profiles for existing stars when using the Continuation method
	 * @param array profile_planets Optional System Planetary Profile data for number of existing planets, Baseline Number, and System Spread when using the Continuation method
	 */
	generate(profile_stars = [], profile_planets = [])
	{
		//=== STAR GEN ===//
		// Step 1: Determine Primary Star
		let stars = [];
		const primary = (profile_stars.length > 0
			? this.star_factory.fromProfile(profile_stars[0], true)
			: this.star_factory.generate());
		this.star_factory.flushHistory(primary);
		stars.push(primary);
		
		// Step 2: Determine presence of Secondary and/or Companion Star(s)
		let secondaries = (profile_stars.length > (this.continuation_add_secondaries ? 1 : 0)
			? this.getSecondariesFromProfiles(primary, profile_stars)
			: this.checkForSecondaryObjects(primary));
		
		// Step 3: Determine Orbit#(s) and Eccentricity
		secondaries = this.genSecondaryOrbits(primary, secondaries);
		
		// Step 4: Determine Type, Class, etc. of any Secondary and/or Companion Star(s)
		// For companions, treat their partner as the Primary for all relevant calculations
		for (let i = 0; i < secondaries.length; i++) {
			let method = '';
			let star = null;
			let entry = secondaries[i];
			if (i === 0) {
				star = primary;
			} else if (entry['present']) {
				if (entry['present'] instanceof AbstractStar) {
					star = entry['present'];
				} else {
					method = this.genSecondaryStarMethod(primary, entry);
					star = this.star_factory.generate(primary, method);
				}
				this.assignSecondaryCharacteristics(star, entry);
				star.designation = stars.length;
				star.orbit_band = i;
				this.star_factory.flushHistory(star);
				stars.push(star);
			}
			// Generate companion star, if any
			if (star && entry['companion']) {
				let companion = null;
				if (entry['companion'] instanceof AbstractStar) {
					companion = entry['companion'];
				} else {
					method = this.genSecondaryStarMethod(star, entry, true);
					companion = this.star_factory.generate(star, method);
				}
				companion.host = star;
				// Special Case: Orbit# for companions of giants (Ia, Ib, II, or III) = 1D x MAO of the primary star (i.e. the giant)
				if (star.type <= MAIN_TYPE_M && star.classification < 4) {
					// MAO of many giants can be > 3.5 which, multiplied by 1D, could exceed the maximum Orbit# of 20
					// To avoid this, first convert MAO to AU, multiply by the specified 1D, then convert back to Orbit#
					const giant_dev = this.roll(1, 6, 0, 'Companion Orbit#: ' + this.bands[i] + ' Giant');
					const giant_mao = this.getOrbitalExclusionZone(star);
					const giant_min_au = orbitToAU(giant_mao);
					entry['companion_orbit'] = auToOrbit(giant_dev * giant_min_au);
				}
				this.assignSecondaryCharacteristics(companion, entry, 'companion_');
				star.designation += 4;
				companion.designation = star.designation + 4;
				companion.orbit_band = i; // same orbital band as host star
				this.star_factory.flushHistory(companion);
				star.companion = companion;
			}
		};
		
		// Special Case: Binary star systems use only A and B designations, even for the primary's companion
		const n_stars = stars.reduce((n, star) => n + (star.companion ? 2 : 1), 0);
		if (n_stars === 2) {
			stars[0].designation = 0;
			if (stars[0].companion) {
				stars[0].companion.designation = 1;
			} else {
				stars[1].designation = 1;
			}
		}
		
		// Step 5: Adjust mass of any post-stellar objects to accommodate a main sequence primary star
		if (primary.type <= MAIN_TYPE_M) {
			stars.forEach(star => {
				if (star.isPostStellar() && star.age > primary.life_main) {
					this.star_factory.adjustForPostStellarObject(star, primary);
					this.star_factory.flushHistory(star);
				}
				if (star.companion && star.companion.isPostStellar() && star.companion.age > primary.life_main) {
					this.star_factory.adjustForPostStellarObject(star.companion, primary);
					this.star_factory.flushHistory(star.companion);
				}
			});
		}
		
		// Step 6: Adjust overlapping Orbit#s
		let n_adj = 0;
		while (this.adjustStellarOrbits(stars)) {
			// continues adjusting until no further adjustments are made
			n_adj++;
			log(n_adj + ' Adjusted stellar orbits');
		}
		
		// Step 7: Determine orbital periods only after mass and Orbit#s all finalized, and calculate the base MAO of each while we're at it
		const p_mass = primary.getOrbitalMass();
		stars.forEach(star => {
			star.orbit_exclusion_zone = this.getOrbitalExclusionZone(star);
			if (!star.primary) {
				// Primary star is at AU 0, so need only use the secondary's orbit_au as the separation value
				star.orbit_period = Math.sqrt(Math.pow(star.orbit_au, 3) / (p_mass + star.getOrbitalMass()));
			}
			if (star.companion) {
				// When determining the period of a companion around its host, the companion's orbit_au accounts for the entire separation
				star.companion.orbit_period = Math.sqrt(Math.pow(star.companion.orbit_au, 3) / star.getOrbitalMass());
				star.companion.orbit_exclusion_zone = this.getOrbitalExclusionZone(star.companion);
				// Maximum allowed orbit only relevant for stars with companions
				star.allowed_orbits_max = this.getMaximumAllowableOrbit(star);
				star.companion.allowed_orbits_max = this.getMaximumAllowableOrbit(star.companion);
			}
		});
		// Step 8: Determine number of planets, if any, orbiting each star and/or star group
		let system = this.genWorldCounts(new StarSystem(stars), profile_planets);
		system.n_orbits = this.determineTotalSystemOrbits(system);
		this.flushHistory(system);
		
		//=== WORLD GEN ===//
		if (system.n_orbits > 0) {
			// Step 1: Determine allowable orbits (i.e. orbit_slots) and allocated orbits (i.e. n_bodies) for each star
			this.determineOrbitsPerStar(system);
			
			// Step 2: Determine system baseline number
			// Only care about Primary group's HZCO for this step, even though it has the combined orbit slots for all of A, AB, ABC, and ABCD groups
			const p_group = system.getPrimaryStarComponent();
			system.baseline_number = (profile_planets.length > 3 && profile_planets[3] !== null
				? profile_planets[3]
				: this.determineBaselineNumber(system, p_group, false));
			
			// Step 3: Determine system baseline Orbit#
			// Since the primary group itself may not have any orbits, use the first primary group that does for HZCO and Min/Max Allowable Orbit#s
			const active_group = system.star_groups.find(group => group.isPrimaryComponent() && group.getTotalAllowedOrbits() > 0);
			if (active_group === undefined) {
				log('Failed to determine System Baseline Orbit# - no primary group with Allowable Orbit#s could be found');
			} else {
				system.baseline_orbit = round(this.determineBaselineOrbit(system, active_group, system.baseline_number, p_group.n_bodies, false), 3);
				log('System Baseline Orbit# set to: ' + system.baseline_orbit);
			}
			
			// Step 4: Empty orbits
			this.determineEmptyOrbits(system);
			
			// Step 5: Determine system spread
			system.orbit_spread = (profile_planets.length > 4 && profile_planets[4] !== null
				? round(profile_planets[4], 3)
				: round(this.determineSystemSpread(system, active_group), 3));
			system.orbit_spread_max = round(this.determineSystemSpreadMax(system), 3);
			// Add a bit more variability when the minimum orbit_spread is significantly less than the potential maximum
			if (profile_planets.length > 3 && profile_planets[3] !== null) {
				// Do not adjust user-entered system spread
			} else if ((system.orbit_spread_max / system.orbit_spread) > (system.n_planets + system.n_empty)) {
				const spread_half = system.orbit_spread_max / 2;
				const spread_mod = 0.1 * spread_half * this.roll(2, 6, -7, 'System Spread: Additional Amount (default was too small)');
				log('System Spread of ' + system.orbit_spread + ' is far smaller than Max of ' + system.orbit_spread_max + '; increasing by +' + (spread_half + spread_mod));
				system.orbit_spread = round(system.orbit_spread + spread_half + spread_mod, 3);
			}
			this.flushHistory(system);
			system.star_groups.forEach(group => {
				if (group.n_bodies > 0 && !group.isPrimaryComponent()) {
					// Determine max spread for each secondary even if not determining the other characteristics independently
					group.orbit_spread_max = this.determineSecondarySpreadMax(system, group);
					// Optionally determine Baseline #, Baseline Orbit#, and Spread for each companion and non-primary star with orbit_slots > 0
					if (this.per_star_baseline) {
						group.baseline_number = this.determineBaselineNumber(system, group, true);
						group.baseline_orbit = round(this.determineBaselineOrbit(system, group, group.baseline_number, group.n_bodies, true), 3);
						log('Secondary Baseline Orbit# for ' + group.getDesignation(system.n_stellar) + ' set to: ' + group.baseline_orbit);
						group.orbit_spread = round(this.determineSecondarySpread(group.baseline_number, group.baseline_orbit, group), 3);
						this.flushHistory(group);
					}
				}
			});
			
			// Step 6: Placing Orbit#s
			// Primary star(s) first
			const p_groups = system.star_groups.filter(group => group.isPrimaryComponent());
			const spread = system.getMinimumOrbitSpread();
			if (p_groups[0].n_bodies > 0) {
				this.determineOrbitNumbers(p_groups[0], spread, p_groups);
				this.recalculatePrimaryBodyCounts(p_groups[0], p_groups);
			}
			// Then any secondary and/or companion star with independent orbits
			system.star_groups.forEach(group => {
				if (!group.isPrimaryComponent() && group.n_bodies > 0) {
					// Use the group's individual spread value if available (i.e. > 0)
					const group_spread = (this.per_star_baseline ? group.getMinimumOrbitSpread() : 0);
					this.determineOrbitNumbers(group, (group_spread > 0 ? group_spread : spread));
				}
			});
			
			// Step 7: Anomalous Planets
			// TODO
			
			// Step 8: Placing Worlds
			this.placeWorlds(system);
			
			// Step 9: Determine Planetary Physical and Orbital Characteristics
			system.star_groups.forEach(group => {
				group.bodies.forEach(body => {
					// Generate the world's physical characteristics (other than Size) such as Diameter and Mass
					this.world_factory.genTraits(system, body);
					this.world_factory.flushHistory(body);
					// Eccentricity and related characteristics
					const ecc_world = this.world_factory.getEccentricityMod(system, body);
					body.orbit_eccentricity = this.genEccentricity(ecc_world, 'Planetary Orbital Eccentricity');
					this.calculateOrbitalCharacteristics(body);
					this.flushHistory(body);
					// Orbital Period
					const p_mass = body.getTotalMass() * TERRA_MASS_TO_SOL;
					body.orbit_period = Math.sqrt(Math.pow(body.orbit_au, 3) / (p_mass + body.host.getOrbitalMass()));
					// Determine Hill Sphere and Moon Orbit Range
					body.hill_sphere = this.world_factory.genHillSphere(system, body);
					body.moon_orbit_range = Math.floor(body.hill_sphere / 2) - 2;
					// Significant Moons
					this.world_factory.genSignificantMoons(system, body);
					body.bodies.forEach(moon => {
						const ecc_moon = this.world_factory.getMoonEccentricityMod(moon);
						moon.orbit_eccentricity = this.genEccentricity(ecc_world + ecc_moon, 'Moon Orbital Eccentricity');
						moon.orbit_retrograde = (this.roll(2, 6, ecc_moon, 'Moon Orbit Direction') > 9);
						this.flushHistory(moon);
					});
					this.flushHistory(body);
				});
			});
		} else if (system.n_planets > 0) {
			log('Generated system with ' + system.n_planets + ' planetary bodies but no available orbits');
		}
		this.flushHistory(system);
		
		// Additional debug information
		system.star_groups.forEach(group => log(group));
		return system;
	}

	/**
	 * @return bool True if any changes to Orbit#s were made
	 */
	adjustStellarOrbits(stars)
	{
		let changed = false;
		for (let i = stars.length - 1; i > 0; i--) {
			let outer = stars[i];
			let inner = stars[i - 1];
			// Crossed orbits, add 1.0 until they are not or the maximum Orbit# is reached
			while (outer.orbit_major_min < inner.orbit_major_max && outer.orbit <= 19.00) {
				log('Adjusting outer orbit for ' + outer.getProfileShort() + '; min orbit ' + outer.orbit_major_min + ' crosses inner ' + inner.getProfileShort() + ' max orbit ' + inner.orbit_major_max);
				outer.orbit = outer.orbit + 1;
				this.calculateOrbitalCharacteristics(outer);
				changed = true;
			}
		}
		return changed;
	}

	assignSecondaryCharacteristics(star, entry, prefix = '')
	{
		star.orbit = entry[prefix + 'orbit'];
		star.orbit_deviation = entry[prefix + 'orbit_deviation'];
		star.orbit_eccentricity = entry[prefix + 'orbit_eccentricity'];
		this.calculateOrbitalCharacteristics(star);
	}

	/**
	 * Calculates the values for the orbiting body's orbit_au, orbit_major_min, and orbit_major_max fields
	 *
	 * @param OribtingBody body
	 */
	calculateOrbitalCharacteristics(body)
	{
		body.orbit_au = orbitToAU(body.getTotalOrbit());
		body.orbit_major_min = body.orbit_au * (1 - body.orbit_eccentricity);
		body.orbit_major_max = body.orbit_au * (1 + body.orbit_eccentricity);
	}

	getOrbitalExclusionZone(star)
	{
		// Special Case: Brown Dwarf MAO is 0.005 instead of 0.01
		// Special Case: Dead Star system MAO is 0.001 instead of 0.01
		const min = (star.type === BROWN_DWARF ? 0.005 : (star.isPostStellar() ? 0.001 : 0.01));
		return Math.max(0.01, auToOrbit(0.01 * star.getTotalDiameter()));
	}

	/**
	 * Determines the maximum allowable orbit#, if any, in which planets can orbit around a star
	 */
	getMaximumAllowableOrbit(star)
	{
		if (star.getHzco() > 0.129 || !this.isCandidateForIndependentOrbit(star)) {
			return 0;
		}
		const companion = (star.companion === null ? star : star.companion);
		return 0.25 * companion.getTotalOrbit() * (1 - companion.orbit_eccentricity);
	}

	isCandidateForIndependentOrbit(star)
	{
		// Brown Dwarfs always qualify
		if (star.type === BROWN_DWARF) {
			return true;
		}
		// Other stars must be dimmer than M5 V (0.0029) or M5 VI (0.00072)
		if (star.type === MAIN_TYPE_M && star.subtype > 5 && star.classification > 4) {
			return true;
		}
		// Any Post-Stellar objects such as White Dwarfs can qualify if they are dimmer than an M5 V star (i.e. 0.0029)
		return star.isPostStellar() && star.getTotalLuminosity() < 0.0029;
	}

	getSecondariesFromProfiles(primary, profiles)
	{
		let secondaries = [
			{'present': primary, 'companion': false},
			{'present': false, 'companion': false},
			{'present': false, 'companion': false},
			{'present': false, 'companion': false},
		];
		const close_ok = !primary.isGiant();
		const max_stars = Math.min(profiles.length, (close_ok ? 8 : 6));
		for (let i = 1; i < max_stars; i++) {
			const star = this.star_factory.fromProfile(profiles[i], false);
			let flag = false;
			while (!flag) {
				let roll = this.roll(1, 6, 0, 'Existing Star Location: ' + star.getProfileShort());
				// 3+ Star Systems use Far instead of Roll Again on a roll of 6
				if (roll === 6 && profiles.length > 2) {
					roll = 4;
				}
				if (roll < 5) {
					for (let j = roll - 1; !flag && j < secondaries.length; j++) {
						// Close band is not allowed if primary is a giant
						if (!close_ok && j === 1) j++;
						if (!secondaries[j]['present']) {
							flag = true;
							secondaries[j]['present'] = star;
							log('Placed secondary star ' + star.getProfileShort() + ' in band #' + j);
						} else if (!secondaries[j]['companion']) {
							flag = true;
							// Swap them if the companion would be more massive
							if (star.getTotalMass() > secondaries[j]['present'].getTotalMass()) {
								secondaries[j]['companion'] = secondaries[j]['present'];
								secondaries[j]['present'] = star;
								log('Placed secondary star ' + star.getProfileShort() + ' as host in band #' + j + '; less massive host swapped to companion');
							} else {
								secondaries[j]['companion'] = star;
								log('Placed secondary star ' + star.getProfileShort() + ' as companion in band #' + j);
							}
						}
						// Check again starting from the primary
						if (j === secondaries.length - 1) j = -1;
					}
				} else if (roll === 5) {
					// Attempt to match secondary star as a companion to an existing star, but only if same type and class
					for (let k = 0; !flag && k < secondaries.length; k++) {
						if (secondaries[k]['present'] instanceof AbstractStar && !secondaries[k]['companion']) {
							flag = (secondaries[k]['present'].type === star.type && secondaries[k]['present'].classification === star.classification);
							if (flag) {
								// Swap them if the companion would be more massive
								if (star.getTotalMass() > secondaries[k]['present'].getTotalMass()) {
									secondaries[k]['companion'] = secondaries[k]['present'];
									secondaries[k]['present'] = star;
									log('Placed secondary star ' + star.getProfileShort() + ' as host in band #' + k + '; less massive host swapped to companion');
								} else {
									secondaries[k]['companion'] = star;
									log('Placed secondary star ' + star.getProfileShort() + ' as companion in band #' + k);
								}
							}
						}
					}
				}
				// Roll again on a 6 or 5 that didn't find a match
			}
			this.flushHistory(star);
		}
		return secondaries;
	}

	getSecondaryPresenceMod(primary)
	{
		let dm = 0;
		// Primary star of Class Ia ,Ib, II, III or IV
		if (primary.classification < 5) dm++;
		// Primary star of Class V or VI and type O, B, A or F
		if (primary.type <= MAIN_TYPE_F && (primary.classification === 5 || primary.classification === 6)) dm++;
		// Primary star of Class V or VI and type M
		if (primary.type === MAIN_TYPE_M && (primary.classification === 5 || primary.classification === 6)) dm--;
		// Primary star is a Brown Dwarf, White Dwarf, Neutron Star, Pulsar or Black Hole
		if ([BROWN_DWARF, WHITE_DWARF, NEUTRON_STAR, PULSAR, BLACK_HOLE].includes(primary.type)) dm--;
		// Protostar, Nebula, Star Cluster, and Anomaly have no additional modifier
		return dm;
	}

	checkForSecondaryObjects(primary)
	{
		const threshold = 9;
		const dm = this.getSecondaryPresenceMod(primary);
		return this.checkForCompanionObjects(dm, [
			{'present': true},
			{'present': (primary.classification > 4 && this.roll(2, 6, dm, 'Secondary Presence: ' + this.bands[1])) > threshold},
			{'present': (this.roll(2, 6, dm, 'Secondary Presence: ' + this.bands[2]) > threshold)},
			{'present': (this.roll(2, 6, dm, 'Secondary Presence: ' + this.bands[3]) > threshold)},
		]);
	}

	checkForCompanionObjects(dm, entries)
	{
		for (let i = 0; i < entries.length; i++) {
			entries[i]['companion'] = (entries[i]['present'] && (this.roll(2, 6, dm, 'Companion Presence: ' + this.bands[i]) > 9));
		};
		return entries;
	}

	genSecondaryOrbits(primary, entries)
	{
		// DM+2 Star Eccentricity, presumably this applies to ALL stars
		const ecc_mod_star = 2;
		// DM-1 For all Orbit#s below 1.0 if system is > 1 Gyr in age (using the Primary's age since the remaining stars have not yet been determined)
		const is_older_system = (primary.age > 1);
		let ecc_mod_near = 0;
		// DM+1 For each star an object directly orbits beyond the first, i.e. all of the stars with Orbit# less than itself, including companions
		let n_stars = 0; // Technically 1, but the Primary is not counted for the eccentricity DM so exclude it now
		for (let i = 0; i < entries.length; i++) {
			if (entries[i]['present']) {
				if (i > 0) {
					const dm = ((i - 1) * 6) - 1;
					entries[i]['orbit'] = Math.max(0.5, this.roll(1, 6, dm, 'Secondary Orbit#: ' + this.bands[i]));
					entries[i]['orbit_deviation'] = (this.enable_var_orbit ? 0.1 * this.roll(2, 6, -7, 'Secondary Orbit# Variance: ' + this.bands[i]) : 0);
					// Minimum total Orbit# is 0.01
					if ((entries[i]['orbit'] + entries[i]['orbit_deviation']) < 0.01) {
						log('Enforcing minimum 0.01 Orbit# for ' + this.bands[i] + ' Secondary at Orbit# ' + entries[i]['orbit'] + ' with deviation ' + signed(entries[i]['orbit_deviation']));
						entries[i]['orbit_deviation'] = -(entries[i]['orbit'] - 0.01);
					}
					ecc_mod_near = (is_older_system && (entries[i]['orbit'] + entries[i]['orbit_deviation']) < 1 ? -1 : 0);
					entries[i]['orbit_eccentricity'] = this.genEccentricity(n_stars + ecc_mod_star + ecc_mod_near, 'Secondary Orbital Eccentricity: ' + this.bands[i]);
					n_stars++; // Each Secondary star counts as DM+1 for eccentricity of stars further out, as well as for its own companion, if any
				} else {
					entries[i]['orbit'] = 0;
					entries[i]['orbit_deviation'] = 0;
					entries[i]['orbit_eccentricity'] = 0;
				}
				// Handle the companion, if any, first to increase the stellar body count
				if (entries[i]['companion']) {
					const a = this.roll(1, 6, 0, 'Companion Orbit#: ' + this.bands[i]);
					const b = this.roll(2, 6, -7, 'Companion Orbit#: ' + this.bands[i]);
					entries[i]['companion_orbit'] = (a * 0.1) + (b * 0.01);
					entries[i]['companion_orbit_deviation'] = 0; // built in to companion orbit#
					ecc_mod_near = (is_older_system && entries[i]['companion_orbit'] < 1 ? -1 : 0);
					entries[i]['companion_orbit_eccentricity'] = this.genEccentricity(n_stars + ecc_mod_star + ecc_mod_near, 'Companion Orbital Eccentricity: ' + this.bands[i]);
					n_stars++; // Each Companion counts as DM+1 for eccentricity of stars further out, but not for its own host star
				}
			}
		};
		return entries;
	}

	genEccentricity(dm, label)
	{
		if (!this.enable_eccentricity) {
			return 0;
		}
		const chart = {
			5: {'base': -0.001, 'roll': 1, 'divisor': 1000},
			6: {'base': 0, 'roll': 1, 'divisor': 200},
			7: {'base': 0, 'roll': 1, 'divisor': 200},
			8: {'base': 0.03, 'roll': 1, 'divisor': 100},
			9: {'base': 0.03, 'roll': 1, 'divisor': 100},
			10: {'base': 0.05, 'roll': 1, 'divisor': 20},
			11: {'base': 0.05, 'roll': 2, 'divisor': 20},
			12: {'base': 0.3, 'roll': 2, 'divisor': 20},
		};
		const i = clamp(this.roll(2, 6, dm, label), 5, 12);
		const a = chart[i]['base'];
		const b = this.roll(chart[i]['roll'], 6, 0, label) / chart[i]['divisor'];
		return clamp(a + b, 0.000, 0.999);
	}

	/**
	 * @param Star primary The primary star or, when generating a companion, the companion's host star
	 * @param array entry An entry from the #checkForSecondaryObjects result
	 * @param bool companion True if generating a companion
	 */
	genSecondaryStarMethod(primary, entry, companion = false)
	{
		// Brown Dwarf primary (or companion host) may only have a Sibling result
		if (primary.type === BROWN_DWARF) {
			return 'Sibling';
		}
		const chart = this.genNonPrimaryStarTable(primary, entry);
		// DM-1 if primary star (or companion host) is Class III or IV
		const dm = (primary.classification === 3 || primary.classification === 4 ? -1 : 0);
		const label = (companion ? 'Companion' : 'Secondary');
		const result = clamp(this.roll(2, 6, dm, label + ' Non-Primary Star Determination'), 2, 12);
		if (chart[result] === 'Other') {
			const other = this.roll(2, 6, 0, label + ' Non-Primary Star Determination: Other');
			return (other > 7 ? 'BD' : 'D');
		} else {
			return chart[result];
		}
	}

	genNonPrimaryStarTable(primary, entry)
	{
		// White Dwarf, Neutron Star, Pulsar, and Black Hole primaries use the Post-Stellar chart
		if ([WHITE_DWARF, NEUTRON_STAR, PULSAR, BLACK_HOLE].includes(primary.type)) {
			return NON_PRIMARY_DEAD;
		}
		// Companions use the Companion chart
		if (entry['companion']) {
			return NON_PRIMARY_COMPANION;
		}
		// Everything else uses the Secondary chart, but may have special cases handled elsewhere
		return NON_PRIMARY_SECONDARY;
	}

	/**
	 * @param StarSystem system A newly created star system with all of the star-data already determined
	 * @param array planets See StarSystemFactory::generate, #planet_profiles
	 *
	 * @return StarSystem with the number of each type of world determined
	 */
	genWorldCounts(system, planets = [])
	{
		const primary = system.getPrimaryStar();
		const n_planets = planets.reduce((n, value, index) => n + (index < 3 && value !== null ? value : 0));
		// Special Case: Dead star systems (i.e. those with a post-stellar primary) may not have any planets at all
		if (n_planets < 1 && primary.isPostStellar()) {
			let dm = 0;
			// DM-2 if multiple post-stellar objects
			dm -= (system.stars.reduce((n, star) => n + (star.isPostStellar() ? 1 : 0), 0) > 1 ? 2 : 0);
			// DM-2 if a Neutron Star (including Pulsars etc.) is present
			dm -= (system.stars.reduce((n, star) => n + (star.type === NEUTRON_STAR || star.type === PULSAR ? 1 : 0), 0) > 0 ? 2 : 0);
			// DM-4 if a Black Hole is present
			dm -= (system.stars.reduce((n, star) => n + (star.type === BLACK_HOLE ? 1 : 0), 0) > 0 ? 4 : 0);
			let roll = this.roll(2, 6, dm, 'World Presence: Dead Star System');
			// No planets on any roll of 7- that was not a natural 12
			if (roll < 8 && (roll - dm) !== 12) {
				log('No planets detected in dead star system');
				return system;
			}
		}
		system.n_planet_gas = (planets.length > 0 && planets[0] !== null ? planets[0] : this.genGasGiantCount(system));
		system.n_planet_belt = (planets.length > 1 && planets[1] !== null ? planets[1] : this.getPlanetoidBeltCount(system));
		system.n_planet_rock = (planets.length > 2 && planets[2] !== null ? planets[2] : this.genTerrestrialPlanetCount(system));
		system.n_planets = system.n_planet_gas + system.n_planet_belt + system.n_planet_rock;
		return system;
	}

	genGasGiantCount(system)
	{
		const primary = system.getPrimaryStar();
		// Gas Giant(s) are absent if 2D > 9
		let absent_over = 9;
		// Special Case: Brown Dwarf systems have none on 8+
		if (primary.isPostStellar()) {
			absent_over = 7;
		}
		// Special Case: Dead star systems have none on 6+
		if (primary.isPostStellar()) {
			absent_over = 5;
		}
		if (this.roll(2, 6, 0, 'World Presence: Gas Giants') > absent_over) {
			return 0;
		}
		let dm = 0;
		// DM+1 System consists of a single Class V star
		if (system.n_stars === 1 && primary.classification === 5) dm += 1;
		// DM-2 Primary star is a brown dwarf
		if (primary.type === BROWN_DWARF) dm -= 2;
		// DM-2 Primary star is a poststellar object
		if (primary.isPostStellar()) dm -= 2;
		// DM-1 per post-stellar object (including primary star)
		dm -= system.stars.reduce((n, star) => n + (star.isPostStellar() ? 1 : 0), 0);
		// DM-1 System consists of four or more stars
		if (system.n_stellar > 4) dm -= 1;
		let roll = this.roll(2, 6, dm, 'World Count: Gas Giants');
		return PLANET_QTY_GAS[clamp(roll, 4, 13)];
	}

	getPlanetoidBeltCount(system)
	{
		const primary = system.getPrimaryStar();
		// Planetoid Belt(s) are absent if 2D < 8
		let absent_under = 8;
		// Special Case: Dead star systems have none under 6
		if (primary.isPostStellar()) {
			absent_under = 6;
		}
		if (this.roll(2, 6, 0, 'World Presence: Planetoid Belts') < absent_under) {
			return 0;
		}
		let dm = 0;
		// DM+1 System has 1 or more gas giants
		if (system.n_planet_gas > 0) dm += 1;
		// DM+3 Primary star is a protostar
		if (primary.type === PROTOSTAR) dm += 3;
		// DM+2 (p37, or DM+4 per p225) Primary star is primordial (i.e. system is < 100 million years old [0.1 Gyrs] but beyond its protostar stage)
		if (primary.type !== PROTOSTAR && system.age < 0.1) dm += 2;
		// DM+1 Primary star is a poststellar object
		if (primary.isPostStellar()) dm += 1;
		// DM+1 Per post-stellar object (including primary star)
		dm += system.stars.reduce((n, star) => n + (star.isPostStellar() ? 1 : 0), 0);
		// DM+1 System consists of two or more stars
		if (system.n_stellar > 1) dm += 1;
		let roll = this.roll(2, 6, dm, 'World Count: Planetoid Belts');
		return (roll < 7 ? 1 : (roll > 11 ? 3 : 2));
	}

	genTerrestrialPlanetCount(system)
	{
		const primary = system.getPrimaryStar();
		// All systems have some quantity of terrestrial planets
		let dm = -2;
		// DM-1 Per post-stellar object (including primary star)
		dm -= system.stars.reduce((n, star) => n + (star.isPostStellar() ? 1 : 0), 0);
		let n = 2;
		// Special Case: Dead star systems roll only 1D instead of 2D
		if (primary.isPostStellar()) {
			n = 1;
		}
		let roll = this.roll(n, 6, dm, 'World Count: Terrestrial Planets');
		// If the resultant terrestrial planets are less than 3, reroll as D3+2
		if (roll < 3) {
			roll = this.roll(1, 3, 2, 'World Count: Terrestrial Planets - Reroll');
		}
		// If the resultant terrestrial planets are 3 or more, add another D3-1
		if (roll > 2) {
			roll += this.roll(1, 3, -1, 'World Count: Terrestrial Planets - Additional');
		}
		return roll;
	}

	determineTotalSystemOrbits(system)
	{
		let n_orbits = 0;
		// Any group with the Primary star included adds its orbit slots to the Primary star instead
		const p_orbits = system.star_groups.reduce((n, group) => (group.isPrimaryComponent() ? n + group.getTotalAllowedOrbits() : n), 0);
		if (p_orbits > 0) {
			const p_group = system.getPrimaryStarComponent();
			p_group.orbit_slots = Math.floor(p_orbits + p_group.getAllowedOrbitMod());
			n_orbits += p_group.orbit_slots;
		}
		// All others determine their allowed number of orbital slots normally
		system.star_groups.filter(group => !group.isPrimaryComponent()).forEach(group => {
			const orbits = group.getTotalAllowedOrbits();
			const mod = (orbits > 0 ? group.getAllowedOrbitMod() : 0);
			group.orbit_slots = Math.floor(orbits + mod);
			n_orbits += group.orbit_slots;
		});
		return n_orbits;
	}

	determineOrbitsPerStar(system)
	{
		let assigned_bodies = 0;
		system.star_groups.forEach(group => {
			const n_bodies = system.n_planets * group.orbit_slots / system.n_orbits;
			// The primary star (or its group, which at this point contains all bodies allocated to any primary group) rounds the number of bodies up; others all round down
			group.n_bodies = (group.isPrimaryComponent() ? Math.ceil(n_bodies) : Math.floor(n_bodies));
			log('Assigned ' + group.n_bodies + ' planetary bodies to ' + group.getDesignation(system.n_stellar));
			assigned_bodies += group.n_bodies;
		});
		const r_bodies = (system.n_planets - assigned_bodies);
		if (r_bodies > 0) {
			const last = system.star_groups.findLast(group => group.orbit_slots > 0);
			last.n_bodies += r_bodies;
			log('Assigned remaining ' + r_bodies + ' planetary bodies to furthest star or companion pair: ' + last.getDesignation(system.n_stellar));
		}
	}

	/**
	 * @param StarSystem system
	 * @param Star|StarGroup group Either the system's primary star component, or a secondary or companion star that may have independent orbits
	 * @param bool secondary True if determining the baseline for a secondary or companion star
	 */
	determineBaselineNumber(system, group, secondary = false)
	{
		const label = (secondary ? 'Secondary' : 'System');
		const p_group = (secondary ? group : system.getPrimaryStarComponent());
		if (!p_group.isHzcoValid()) {
			// Special Case: Invalid HZCO and no allowed orbits - baseline is 0
			if (p_group.orbit_slots < 1) return 0;
			// Special Case: Invalid HZCO and some allocated orbits - place a random number of worlds around the star and use that number +1 (or more) as the baseline
			const p_worlds = Math.ceil((p_group.n_bodies / 10) * this.roll(2, 6, -2, label + ' Baseline Number: invalid HZCO, rolling a random planet # to use as the baseline'));
			return p_worlds + 1;
		}
		const primary = (secondary ? (group instanceof StarGroup ? group.bodies[0] : group) : system.getPrimaryStar());
		const dm = this.getBaselineNumberMod(system, primary);
		const n_planets = (this.per_star_baseline && secondary ? group.n_bodies : system.n_planets);
		const dm_planet = this.getBaselineNumberWorldCountMod(n_planets);
		return this.roll(2, 6, dm + dm_planet, label + ' Baseline Number: valid HZCO, rolling for baseline');
	}

	getBaselineNumberMod(system, primary)
	{
		let dm = 0;
		// DM-2 if Primary star has or is itself a companion
		if (primary.companion || primary.host) dm -= 2;
		// DM+3 if Primary star is Class Ia, Ib, or II
		if (primary.type <= MAIN_TYPE_M && primary.classification < 3) dm += 3;
		// DM+2 if Primary star is Class III
		if (primary.type <= MAIN_TYPE_M && primary.classification === 3) dm += 2;
		// DM+1 if Primary star is Class IV
		if (primary.type <= MAIN_TYPE_M && primary.classification === 4) dm += 1;
		// DM-1 if Primary star is Class VI
		if (primary.type <= MAIN_TYPE_M && primary.classification === 6) dm -= 1;
		// DM-2 if Primary star is a post-stellar object
		if (primary.isPostStellar()) dm -= 2;
		// DM-1 for each secondary star (excluding companions)
		dm -= (system.stars.length - 1);
		return dm;
	}

	getBaselineNumberWorldCountMod(n_worlds)
	{
		if (n_worlds < 6) return -4;
		if (n_worlds < 10) return -3;
		if (n_worlds < 13) return -2;
		if (n_worlds < 16) return -1;
		if (n_worlds < 18) return 0;
		if (n_worlds < 21) return 1;
		return 2;
	}

	/**
	 * @param StarSystem system
	 * @param Star|StarGroup group Either the first primary star component with allowable orbits, or a secondary or companion star that may have independent orbits
	 * @param float baseline_number Either from the system or the secondary group
	 * @param int n_bodies The number of bodies (excluding empty orbits) around the group or, when determining it for the entire system, the first primary star component
	 * @param bool secondary True if determining the baseline orbit# for a secondary or companion star
	 */
	determineBaselineOrbit(system, group, baseline_number, n_bodies, secondary = false)
	{
		const label = (secondary ? 'Secondary' : 'System');
		const n_planets = (this.per_star_baseline && secondary ? n_bodies : system.n_planets);
		const orbit_min = group.getMinimumAllowableOrbit();
		const orbit_max = group.getMaximumAllowableOrbit();
		const hzco = group.getHzco();
		const eff_hzco  = clamp(hzco, orbit_min, orbit_max);
		log('Determining ' + label + ' Baseline Orbit# from Baseline Number: ' + baseline_number + ', HZCO: ' + hzco + ', Min Orbit: ' + orbit_min + ', Max Orbit: ' + orbit_max);
		if (baseline_number < 1.0) {
			const roll_b = this.roll(2, 6, -2, label + ' Baseline Orbit: Method B');
			if (orbit_min < 1.0) {
				const mod_b = (Math.abs(baseline_number) / 10) + (roll_b / 100);
				if (hzco >= orbit_max) {
					log(label + ' Baseline Orbit# determined by Method B, MAO < 1 and HZCO >= Max Orbit, returning Max ' + orbit_max + ' - ' + mod_b);
					return clamp(orbit_max - mod_b, orbit_min, orbit_max);
				}
				log(label + ' Baseline Orbit# determined by Method B, MAO < 1 and HZCO < Max Orbit, returning effective HZCO ' + eff_hzco + ' + ' + mod_b);
				return clamp(eff_hzco + mod_b, orbit_min, orbit_max);
			}
			const result_b = eff_hzco - baseline_number + n_planets + (roll_b / 10);
			if (result_b > 20.0) {
				log(label + ' Baseline Orbit# determined by Method B, MAO >= 1 and ' + result_b + ' exceeds 20; reducing to 20 - ' + (roll_b / 10));
				return 20.0 - (roll_b / 10);
			}
			log(label + ' Baseline Orbit# determined by Method B, MAO >= 1; returning valid result: ' + result_b);
			return clamp(result_b, orbit_min, orbit_max);
		} else if (baseline_number > n_planets) {
			const roll_c = this.roll(2, 6, -7, label + ' Baseline Orbit: Method C');
			const method_c = baseline_number + n_planets;
			if (eff_hzco - method_c >= 1.0) {
				log(label + ' Baseline Orbit# determined by Method C, total >= 1.0');
				return clamp(eff_hzco - method_c + (roll_c / 5), orbit_min, orbit_max);
			}
			const result_c = eff_hzco - ((method_c + (roll_c / 5)) / 10);
			if (result_c < 0) {
				// Note that this calculation uses the group's total worlds, not the system's
				log(label + ' Baseline Orbit# determined by Method C, total < 1.0 and subsequent result < 0');
				return clamp(Math.max(eff_hzco - 0.1, orbit_min + (0.1 * n_bodies)), orbit_min, orbit_max);
			}
			log(label + ' Baseline Orbit# determined by Method C, total < 1.0 and subsequent result >= 0');
			return clamp(result_c, orbit_min, orbit_max);
		}
		const roll_a = this.roll(2, 6, -7, label + ' Baseline Orbit: Method A');
		const mod_a = (roll_a / (eff_hzco < 1.0 ? 100 : 10));
		if (hzco >= orbit_max) {
			log(label + ' Baseline Orbit# determined by Method A, HZCO >= Max Orbit, returning Max ' + orbit_max + ' - ' + Math.abs(mod_a));
			return clamp(orbit_max - Math.abs(mod_a), orbit_min, orbit_max);
		}
		log(label + ' Baseline Orbit# determined by Method A, HZCO < Max Orbit, returning effective HZCO ' + eff_hzco + (mod_a < 0 && eff_hzco + mod_a >= orbit_min ? ' - ' : ' + ') + Math.abs(mod_a));
		const result_a = (eff_hzco + mod_a < orbit_min ? eff_hzco - mod_a : eff_hzco + mod_a);
		return clamp(result_a, orbit_min, orbit_max);
	}

	determineEmptyOrbits(system)
	{
		if (this.per_star_empty_orbits) {
			system.star_groups.forEach(group => {
				if (group.n_bodies > 0) {
					group.n_empty = Math.max(0, this.roll(2, 6, -9, 'Empty Orbits: Star ' + group.getDesignation(system.n_stellar)));
					system.n_empty += group.n_empty;
				}
			});
		} else {
			system.n_empty = Math.max(0, this.roll(2, 6, -9, 'Empty Orbits: Entire System'));
			let empty = system.n_empty;
			let i = 0;
			// Allocate first to Close, Near, and Far star(s), then finally Primary star(s)
			while (empty > 0 && i < 3) {
				empty = this.allocateEmptyOrbits(system, empty, (group) => group.orbit_band > 0);
				empty = this.allocateEmptyOrbits(system, empty, (group) => group.orbit_band < 1);
				i++;
			}
		}
	}

	allocateEmptyOrbits(system, empty, callback)
	{
		system.star_groups.forEach(group => {
			if (empty > 0 && group.n_bodies > 0 && callback(group)) {
				log('Allocating +1 empty orbit around ' + group.getDesignation(system.n_stellar));
				group.n_empty++;
				empty--;
			}
		});
		return empty;
	}

	determineSystemSpread(system, active_group = null)
	{
		return this.determineSecondarySpread(system.baseline_number, system.baseline_orbit, active_group);
	}

	determineSystemSpreadMax(system)
	{
		const p_group = system.getPrimaryStarComponent();
		return (p_group.orbit_slots / (p_group.n_bodies + p_group.n_empty + system.n_stellar));
	}

	determineSecondarySpread(baseline_number, baseline_orbit, group = null)
	{
		const mao = (group ? group.getMinimumAllowableOrbit() : 0);
		return Math.max(0.01, (baseline_orbit - mao) / Math.max(1, baseline_number));
	}

	determineSecondarySpreadMax(system, star)
	{
		const total_orbits = star.getTotalAllowedOrbits();
		// The "number of worlds" refers to the star or pair in question
		if ((total_orbits / star.n_bodies) > system.orbit_spread) {
			return round(total_orbits / (1 + star.n_bodies + star.n_empty), 3);
		}
		return 0;
	}

	/**
	 * @return bool True if all of the star's bodies were allocated a valid Orbit#
	 */
	determineOrbitNumbers(star, spread, p_groups = [])
	{
		const n_bodies = star.n_bodies + star.n_empty;
		let allocated = 0;
		let orbit = star.getMinimumAllowableOrbit();
		let p_index = 1;
		log('Attempting to place ' + n_bodies + ' Orbit#s around star/group ' + star.getDesignation() + '; Cumulative Variance? ' + (this.cumulative_orbit ? 'Y' : 'N'));
		for (let n = 0; n < n_bodies; n++) {
			const mao = (this.cumulative_orbit ? orbit : star.getMinimumAllowableOrbit() + (star.bodies.length * spread));
			const orbit_var = 0.1 * spread * this.roll(2, 6, -7, 'Placing Orbits for ' + star.getDesignation() + ': Variance');
			orbit = mao + spread + orbit_var;
			// Special Case: Primary Star group(s) move to next furthest primary star group if orbit is outside of the current group's maximum allowable orbit
			while (p_index < p_groups.length && orbit > star.getMaximumAllowableOrbit()) {
				log('Placing Orbits for ' + star.getDesignation() + ': Orbit# ' + orbit + ' exceeds maximum allowed by ' + star.getDesignation() + '; proceeding to next group, if any');
				star = p_groups[p_index++];
				orbit = star.getMinimumAllowableOrbit() + spread + orbit_var;
			}
			if (orbit > star.getMaximumAllowableOrbit()) {
				log('Placing Orbits for ' + star.getDesignation() + ': ran out of allowable orbit slots at n=' + n);
			} else {
				log('Valid orbit for ' + star.getDesignation() + ' at ' + orbit + ' (Min: ' + mao + ', Spread: ' + spread + ', Variance: ' + orbit_var + ')');
				star.bodies.push(orbit);
				allocated++;
			}
		}
		log('World Orbit#s for ' + star.getDesignation());
		log(star.bodies);
		return allocated === n_bodies;
	}

	recalculatePrimaryBodyCounts(primary, p_groups)
	{
		const n_bodies = primary.n_bodies;
		const n_empty = primary.n_empty;
		// Recalculate n_bodies and n_empty for each primary group
		let empty = n_empty;
		p_groups.forEach(group => {
			group.n_empty = Math.floor(n_empty * group.bodies.length / n_bodies);
			group.n_bodies = group.bodies.length - group.n_empty;
			empty -= group.n_empty;
		});
		// Allocate any remaining empty orbits working from the furthest star inwards
		let i = 3; // fail-safe
		while (empty > 0 && i > 0) {
			p_groups.reverse().forEach(group => {
				if (empty > 0 && group.n_bodies > 1) {
					group.n_empty++;
					group.n_bodies--;
					empty--;
				}
			});
			i--;
		}
		if (empty > 0) {
			log('Failed to place all empty orbits for Primary Star Group(s): ' + empty + ' remaining');
		}
	}

	placeWorlds(system)
	{
		// Special Case: Young Protostar systems (i.e. < 0.002 Gyr old) have special rules for world generation
		const primary = system.getPrimaryStar();
		const is_young_protostar = (primary.type === PROTOSTAR && system.age < 0.002);
		const proto_cap = (primary.type === PROTOSTAR ? round(system.age * 1000, 0) : 0);
		const worlds = this.getWorldsForPlacement(system);
		this.determineWorldTypes(system, worlds);
		this.flushHistory(system);
		// Clear the temporary data out of the bodies array for each star and group
		system.star_groups.forEach(group => group.bodies = []);
		// Create the actual World objects for each star/group
		let b_index = 1;
		let p_index = 1;
		let host = null;
		worlds.forEach(entry => {
			if (host === null || host.getDesignation(system.n_stellar) !== system.star_groups[entry['group_index']].getDesignation(system.n_stellar)) {
				host = system.star_groups[entry['group_index']];
				b_index = 1;
				p_index = 1;
			}
			if (entry['type'] === PLANET_EMPTY) {
				// no-op
			} else if (entry['type'] === PLANET_BELT) {
				const belt = new PlanetoidBelt(host, entry['orbit'], b_index++);
				host.bodies.push(belt);
			} else {
				const world = new World(host, entry['orbit'], p_index++, entry['type']);
				world.size = this.world_factory.genSize(system, world);
				// Special Case: Protostar systems cap the size of terrestrial planets and moons at 1 per million years
				let proto_adds = [];
				const proto_diff = (world.size - proto_cap);
				if (primary.type === PROTOSTAR && proto_diff > 0 && (world.type === PLANET_ROCK || world.type === PLANET_MOON)) {
					world.size = proto_cap;
					for (let i = 0; i < proto_diff; i++) {
						// Add up to +/- 10% orbital variance
						const orbit_var = 0.02 * entry['orbit'] * this.roll(2, 6, -7, 'Protostar Planetary Chunk: Additional orbit variance');
						// Use the same planet index
						const proto_add = new World(host, entry['orbit'] + orbit_var, p_index, entry['type']);
						// Chunks < Size 0 become Size 0 to make lots of little asteroids
						proto_add.size = Math.max(0, proto_cap - this.roll(1, 6, -1, 'Protostar Planetary Chunk: Size reduction'));
						proto_adds.push(proto_add);
					}
				}
				// Add all rolls (including for any Protostar additions) to main world history
				this.world_factory.flushHistory(world);
				this.flushHistory(world);
				// Special Case: Young Protostar systems (i.e. < 0.002 Gyr old) may have reduced a world's size below 0, indicating it should not be added
				if (!is_young_protostar || world.size > -1) {
					host.bodies.push(world);
				} else {
					p_index--; // planet not added; reduce planet index by 1
				}
				// Special Case: Young Protostar systems (i.e. < 0.002 Gyr old) add a belt in every slot with a gas giant or terrestrial planet, even if that planet was removed
				if (is_young_protostar && (world.type === PLANET_GAS || world.type === PLANET_ROCK)) {
					log('Protostar System < 0.002 Gyr in age: adding a Planetoid Belt in same orbit as ' + world.getDesignation(system.n_stellar));
					host.bodies.push(new PlanetoidBelt(host, entry['orbit'], b_index++));
				}
				// Protostars add any extra terrestrial chunks
				host.bodies.push(...proto_adds);
			}
		});
	}

	getWorldsForPlacement(system)
	{
		let worlds = [];
		for (let i = 0; i < system.star_groups.length; i++) {
			const group = system.star_groups[i];
			const n_bodies = group.n_bodies + group.n_empty;
			for (let j = 0; j < n_bodies; j++) {
				worlds.push({'group_index': i, 'orbit': group.bodies[j], 'type': null});
			}
			// If empty orbits are per-star rather than system-wide, allocate them now
			if (this.per_star_empty_orbits) {
				for (let k = 0; k < group.n_empty; k++) {
					let index = this.roll(1, n_bodies, -1, 'World Placement: Empty Orbit for ' + group.getDesignation(system.n_stellar));
					// Ensure empty orbit placed in an undetermined slot
					while (worlds[worlds.length - n_bodies + index]['type'] !== null) {
						index = (index + 1 === n_bodies ? 0 : index + 1);
					}
					worlds[worlds.length - n_bodies + index]['type'] = PLANET_EMPTY;
				}
			}
		};
		return worlds;
	}

	determineWorldTypes(system, worlds)
	{
		const map = {
			[PLANET_EMPTY]: (this.per_star_empty_orbits ? 0 : system.n_empty),
			[PLANET_GAS]: system.n_planet_gas,
			[PLANET_BELT]: system.n_planet_belt,
			// Terrestrial planets fill all remaining slots once the others are allocated
		};
		for (const type in map) {
			for (let n = 0; n < map[type]; n++) {
				const label = (+type === PLANET_EMPTY ? 'Empty Orbit' : (+type === PLANET_GAS ? 'Gas Giant' : 'Planetoid Belt'));
				let i = this.roll(1, worlds.length, -1, 'World Placement: ' + label);
				// Find next available slot if already occupied
				while (worlds[i]['type'] !== null) {
					i++;
					if (i === worlds.length) i = 0;
				}
				worlds[i]['type'] = +type;
			}
		}
		// Fill the remaining slots with Terrestrial planets
		for (let j = 0; j < worlds.length; j++) {
			if (worlds[j]['type'] === null) {
				worlds[j]['type'] = PLANET_ROCK;
			}
		}
	}
}

class WorldFactory extends AbstractFactory
{
	/**
	 * @param FormData options:
	 *   @option bool flat_temp True to use 7+DMs when determining the temperature of worlds outside the HZ
	 *   @option bool hill_moon_qty True to use only the Hill Sphere when determining DM-1 per die for Significant Moon Qty
	 *   @option bool var_mass True to enable variations in world mass
	 *   @option bool var_orbit True to enable variations in moon orbit#s
	 *   @option bool var_size True to enable variations in world diameter
	 *   @option bool var_temp True to enable variations in world temperature
	 *   @option bool per_star_baseline True to calculate baseline number, baseline Orbit#, and system spread for each secondary and companion star separately
	 *   @option bool 
	 * @param AtmosphereFactory|null
	 */
	constructor(options, atmosphere_factory = null)
	{
		super();
		this.enable_flat_temp = options.has('flat_temp');
		this.hill_moon_qty = options.has('hill_moon_qty');
		this.enable_var_mass = options.has('var_mass');
		this.enable_var_orbit = options.has('var_orbit');
		this.enable_var_size = options.has('var_size');
		this.enable_var_temp = options.has('var_temp');
		this.per_star_baseline = options.has('per_star_baseline');
		this.atmosphere_factory = (atmosphere_factory ? atmosphere_factory : new AtmosphereFactory(options));
	}

	generate()
	{
		// TODO
	}

	genAlbedo(world)
	{
		let albedo = this.genAlbedoBase(world);
		// Not all worlds will have a defined atmosphere, e.g. Gas Giants
		if (world.atmosphere) {
			// Atmosphere types 1-3 and E add 0.01 * (2D-3)
			if ([1, 2, 3, 14].includes(world.atmosphere.type)) albedo += 0.01 * this.roll(2, 6, -3, 'Albedo: Atmosphere (1-3,E) Modifier');
			// Atmosphere types 4-9 add 0.01 * 2D
			if (world.atmosphere.type > 3 && world.atmosphere.type < 10) albedo += 0.01 * this.roll(2, 6, 0, 'Albedo: Atmosphere (4-9) Modifier');
			// Atmosphere types A-C or F+ add 0.05 * (2D-2)
			if (world.atmosphere.type > 14 || [10, 11, 12].includes(world.atmosphere.type)) albedo += 0.05 * this.roll(2, 6, -2, 'Albedo: Atmosphere (A-C,F+) Modifier');
			// Atmosphere type D add 0.03 * 2D
			if (world.atmosphere.type === 13) albedo += 0.03 * this.roll(2, 6, 0, 'Albedo: Atmosphere (D) Modifier');
		}
		// Hydrographics 2-5 add 0.02 * (2D-2)
		if (world.hydrographics > 1 && world.hydrographics < 6) albedo += 0.02 * this.roll(2, 6, -2, 'Albedo: Hydrographics (2-5) Modifier');
		// Hydrographics 6+ add 0.03 * (2D-4)
		if (world.hydrographics > 5) albedo += 0.03 * this.roll(2, 6, -4, 'Albedo: Hydrographics (6+) Modifier');
		return clamp(albedo, 0.02, 0.98);
	}

	genAlbedoBase(world)
	{
		// Gas Giant: 0.05 * (2D+1)
		if (world.type === PLANET_GAS) return 0.05 * this.roll(2, 6, 1, 'Albedo: Gas Giant');
		// Rocky Terrestrial (i.e. Density > 0.5): 0.04 + 0.02 * (2D-2)
		if (world.density > 0.5) return 0.04 + (0.02 * this.roll(2, 6, -2, 'Albedo: Rocky Terrestrial'));
		// Icy Terrestrial (i.e. Density <= 0.5) up to HZCO+2: 0.2 + 0.05 * (2D-3)
		const orbit = world.getHzcoOrbit();
		if (orbit <= world.getHzcoPlus(2)) return 0.2 + (0.05 * this.roll(2, 6, -3, 'Albedo: Icy Terrestrial up to HZCO+2'));
		// Icy Terrestrial (i.e. Density <= 0.5) beyond HZCO+2: 0.25 + 0.07 * (2D-2)
		let albedo = 0.25 + (0.07 * this.roll(2, 6, -2, 'Albedo: Icy Terrestrial beyond HZCO+2'));
		if (albedo <= 0.4) {
			albedo -= 0.05 * this.roll(1, 6, -1, 'Albedo: Icy Terrestrial beyond HZCO+2, additional reduction')
		}
		return albedo;
	}

	getEccentricityMod(system, world)
	{
		let dm = 0;
		const primary = system.getPrimaryStar();
		// DM-1 For all Orbit#s below 1.0 if system is > 1 Gyr in age
		if (system.age > 1 && world.getTotalOrbit() < 1) dm--;
		// DM+1 For any significant body in an asteroid or planetoid belt, either any Gas Giant or Terrestrial planet in a Protostar system or when using the Continuation method
		if (primary.type === PROTOSTAR && (world.type === PLANET_GAS || world.type === PLANET_ROCK)) dm++;
		// DM+2 for planets in a Protostar system
		if (primary.type === PROTOSTAR) dm += 2;
		// DM+1 for planets in a Primordial system (any system < 0.1 Gyr and not a Protostar)
		if (system.age < 0.1 && primary.type !== PROTOSTAR) dm++;
		// DM+1 For each star an object directly orbits beyond the first, excluding this planet's own companion/host unless it is in a circumbinary orbit
		if (world.host.orbit_band > 0) {
			dm += system.stars.reduce((n, star) => n + (star.orbit_band < world.host.orbit_band ? (star.companion ? 2 : 1) : 0), 0);
		}
		// DM+1 for worlds in a circumbinary orbit since it was not accounted for above
		if (world.host instanceof StarGroupCompanion) dm++;
		return dm;
	}

	/**
	 * Depends on world.density and world.diameter
	 */
	genGravity(world)
	{
		return world.density * world.getTotalDiameter() / TERRA_DIAMETER;
	}

	/**
	 * Depends on both physical (e.g. mass, diameter) and orbital (e.g. orbit_au) characteristics
	 */
	genHillSphere(system, world)
	{
		// Only Gas Giants and Terrestrial planets support additional orbiting bodies
		if (world.type !== PLANET_GAS && world.type !== PLANET_ROCK) return 0;
		const mass_solar = world.getTotalMass() * TERRA_MASS_TO_SOL;
		const mass_stars = system.stars
			.filter(star => star.orbit_band < world.host.orbit_band)
			.reduce((n, star) => n + star.getTotalMass() + (star.companion ? star.companion.getTotalMass() : 0), world.host.getTotalMass());
		// Gas Giant diameters are in units of Terra, while others are already in km
		const diameter = (world.type === PLANET_GAS ? world.getTotalDiameter() * TERRA_DIAMETER : world.getTotalDiameter());
		const hill_sphere_au = world.orbit_au * (1 - world.orbit_eccentricity) * Math.cbrt(mass_solar / (3 * mass_stars));
		const hill_sphere_pd = hill_sphere_au * AU / diameter;
		log('Calculating Hill Sphere for ' + world.getDesignation(system.n_stellar) + '; Orbit AU = ' + format(world.orbit_au, 6) + ', Eccentricity = ' + format(world.orbit_eccentricity, 6) + ', World Mass (Solar) = ' + format(mass_solar, 6) + ', Star Mass = ' + format(mass_stars, 6));
		log('Hill Sphere results: AU = ' + hill_sphere_au + ', PD = ' + hill_sphere_pd + ', Moon Limit = ' + (hill_sphere_pd / 2));
		// Worlds orbiting just one of a companion pair need to calculate their hill sphere compared to both and use the smallest
		const companion = (world.host.companion ? world.host.companion : world.host.host);
		if (companion) {
			// Host's mass was previously included in mass_stars; replace it with the companion mass for this calculation
			const comp_mass = companion.getTotalMass() - world.host.getTotalMass();
			const comp_sphere_au = world.orbit_au * (1 - world.orbit_eccentricity) * Math.cbrt(mass_solar / (3 * (mass_stars + comp_mass)));
			const comp_sphere_pd = comp_sphere_au * AU / diameter;
			log('Hill Sphere for companion: AU = ' + comp_sphere_au + ', PD = ' + comp_sphere_pd);
			return Math.min(hill_sphere_pd, comp_sphere_pd);
		}
		return hill_sphere_pd;
	}

	genSize(system, world)
	{
		if (world.type === PLANET_GAS) {
			return this.genSizeGasGiant(system);
		} else if (world.type === PLANET_ROCK) {
			return this.genSizeTerrestrial(system);
		}
		return 0;
	}

	genSizeGasGiant(system)
	{
		let dm = 0;
		const primary = system.getPrimaryStar();
		// DM-1 if Primary Star is a Brown Dwarf, M-Type Class V, or any Class VI star
		if (primary.type === BROWN_DWARF || primary.classification === 6 || (primary.type <= MAIN_TYPE_M && primary.classification === 5)) dm--;
		// DM-1 if System Spread is less than 0.1
		if (system.orbit_spread < 0.1) dm--;
		const roll_a = this.roll(1, 6, dm, 'Gas Giant Size: First Roll');
		let size = (roll_a < 3 ? 0 : (roll_a < 5 ? 1 : 2));
		// Special Case: Young Protostar systems (i.e. < 0.002 Gyr old) reduce Medium gas giants to Small and Small to none
		if (size < 2 && primary.type === PROTOSTAR && system.age < 0.002) {
			size--;
		}
		return size;
	}

	genSizeTerrestrial(system)
	{
		const roll_a = this.roll(1, 6, 0, 'Terrestrial Size: First Roll');
		if (roll_a < 3) {
			return this.roll(1, 6, 0, 'Terrestrial Size: Second Roll');
		} else if (roll_a < 5) {
			return this.roll(2, 6, 0, 'Terrestrial Size: Second Roll');
		}
		return this.roll(2, 6, 3, 'Terrestrial Size: Second Roll');
	}

	/**
	 * Gives an estimated mean temperature based solely on the value of world.temperature
	 */
	genTemperatureMeanEstimate(world)
	{
		const chart = [188, 198, 218, 238, 263, 278, 283, 288, 293, 298, 313, 338, 388];
		const index = clamp(world.temperature, 0, 12);
		let t = chart[index];
		if (world.temperature < 1) {
			t += 5 * world.temperature;
			t = (t < 10 ? this.roll(1, 6, 5, 'Mean Temperature: reroll < 10') : t);
		}
		if (world.temperature > 12) {
			t += 50 * (world.temperature - 12);
		}
		log('Mean Temperature for temperature index ' + world.temperature + ' is ' + chart[index] + '; T = ' + t);
		if (this.enable_var_temp) {
			const diffs = [5, 10, 20, 20, 25, 15, 5, 5, 5, 5, 15, 25, 50];
			const diff = (world.temperature < 0 ? 5 : (world.temperature > 12 ? 50 : diffs[index]));
			t += diff * 0.1 * this.roll(2, 6, -7, 'Mean Temperature: Variance')
		}
		return t;
	}

	/**
	 * Depends on world orbit and atmosphere
	 */
	genTemperature(world)
	{
		const dm_atmo = this.getTemperatureModAtmosphere(world.atmosphere);
		const dm_hzco = this.getTemperatureModHzco(world);
		return !this.enable_flat_temp || world.isInHzco()
			? this.roll(2, 6, dm_atmo + dm_hzco, 'Mean Temperature')
			: (7 + dm_atmo + dm_hzco);
	}

	getTemperatureModAtmosphere(atmosphere)
	{
		let dm = 0;
		// DM-2 for atmosphere codes 2 or 3
		if (atmosphere.type === 2 || atmosphere.type === 3) dm -= 2;
		// DM-1 for atmosphere codes 4, 5, or E
		if (atmosphere.type === 4 || atmosphere.type === 5 || atmosphere.type === 14) dm--;
		// DM+1 for atmosphere codes 8 or 9
		if (atmosphere.type === 8 || atmosphere.type === 9) dm++;
		// DM+2 for atmosphere codes A, D, or F
		if (atmosphere.type === 10 || atmosphere.type === 13 || atmosphere.type === 15) dm += 2;
		// DM+6 for atmosphere codes B or C
		if (atmosphere.type === 11 || atmosphere.type === 12) dm += 6;
		return dm;
	}

	getTemperatureModHzco(world)
	{
		let dm = 0;
		const orbit = world.getHzcoOrbit();
		const hzco_inner = world.getHzcoPlus(-1);
		const hzco_outer = world.getHzcoPlus(1);
		if (orbit < hzco_inner) {
			// DM+4 if world at Hot edge of HZCO, i.e. orbit < HZCO-1
			dm += 4;
			// Additional DM+1 per 0.5 Orbit# below HZCO-1, round to nearest
			const inner_in = Math.min(1, hzco_inner) - orbit;
			if (inner_in > 0) dm += Math.round(20 * inner_in);
			const inner_out = hzco_inner - Math.max(1, orbit);
			if (inner_out > 0) dm += Math.round(2 * inner_out);
		}
		if (orbit > hzco_outer) {
			// DM-4 if world at Cold edge of HZCO, i.e. orbit > HZCO+1
			dm -= 4;
			// Additional DM-1 per 0.5 Orbit# beyond HZCO+1, round to nearest
			const outer_in = Math.min(1, orbit) - hzco_outer;
			if (outer_in > 0) dm -= Math.round(20 * outer_in);
			const outer_out = orbit - Math.max(1, hzco_outer);
			if (outer_out > 0) dm -= Math.round(2 * outer_out);
		}
		return dm;
	}

	genTraits(system, world)
	{
		if (world.type === PLANET_GAS) {
			this.genTraitsGasGiant(system, world);
		} else if (world.type === PLANET_ROCK) {
			this.genTraitsTerrestrial(system, world);
		} else if (world.type === PLANET_MOON) {
			this.genTraitsTerrestrial(system, world);
		} else if (world.type === PLANET_BELT) {
			this.genTraitsPlanetoidBelt(system, world);
		} else if (world.type === PLANET_RING) {
			this.genTraitsPlanetaryRing(system, world);
		}
	}

	genTraitsGasGiant(system, world)
	{
		if (world.size < 1) {
			world.diameter = this.roll(2, 3, 0, 'Gas Giant Size: Diameter');
			world.mass = 5 * this.roll(1, 6, 1, 'Gas Giant Size: Mass');
		} else if (world.size === 1) {
			world.diameter = this.roll(1, 6, 6, 'Gas Giant Size: Diameter');
			world.mass = 20 * this.roll(3, 6, -1, 'Gas Giant Size: Mass');
		} else {
			world.diameter = this.roll(2, 6, 6, 'Gas Giant Size: Diameter');
			world.mass = 50 * this.roll(1, 3, 0, 'Gas Giant Size: Mass (1st roll)') * this.roll(3, 6, 4, 'Gas Giant Size: Mass (2nd Roll)');
		}
		// Special Case: If initial mass >= 3000, set mass to 4000 - (200 * (2D-2))
		if (world.getTotalMass() >= 3000) {
			world.mass = 4000 - (200 * this.roll(2, 6, -2, 'Gas Giant Size: Mass (3rd roll)'));
		}
		if (this.enable_var_mass) {
			const min = (world.size < 1 ? 10 : (world.size > 1 ? 350 : 40));
			const max = (world.size < 1 ? 35 : (world.size > 1 ? 4000 : 340));
			world.mass_deviation = 0.1 * min * this.roll(2, 6, -7, 'Gas Giant Size: Mass Variance');
			// Flip the deviation if it causes the gas giant's mass to go out of bounds
			if (world.getTotalMass() < min || world.getTotalMass() > max) {
				world.mass_deviation = -world.mass_deviation;
			}
		}
		world.albedo = this.genAlbedo(world);
	}

	genTraitsPlanetaryRing(system, ring)
	{
		ring.span = 0.07 + (0.01 * this.roll(3, 6, 0, 'Planetary Ring Span'));
	}

	genTraitsPlanetoidBelt(system, belt)
	{
		belt.span = this.genPlanetoidBeltSpan(system, belt);
		this.genPlanetoidBeltComposition(belt);
		belt.bulk = Math.max(1, this.genPlanetoidBeltBulk(system, belt));
		belt.resource_rating = Math.max(0, this.genPlanetoidBeltResourceRating(belt));
		belt.n_bodies_large = Math.max(0, this.genPlanetoidBeltBodyCountLarge(belt));
		belt.n_bodies_small = Math.max(0, this.genPlanetoidBeltBodyCountSmall(belt));
		log('Planetoid Belt ' + belt.getDesignation(system.n_stellar) + ' profile: ' + belt.getProfileLong());
	}

	genPlanetoidBeltBodyCountLarge(belt)
	{
		let dm = belt.bulk;
		// DM+2 if belt orbit is beyond HZCO+3
		if (belt.getHzcoOrbit() > belt.getHzcoPlus(3)) dm += 2;
		// DM-4 if belt span is less than 0.1
		if (belt.span < 0.1) dm -= 4;
		return this.roll(2, 6, dm - 12, 'Planetoid Belt: Size 1 Significant Bodies');
	}

	genPlanetoidBeltBodyCountSmall(belt)
	{
		let dm = 0;
		const orbit = belt.getHzcoOrbit();
		// DM+1 if belt orbit is between HZCO+2 and HZCO+3
		if (orbit > belt.getHzcoPlus(2) && orbit < belt.getHzcoPlus(3)) dm++;
		// DM+3 if belt orbit is beyond HZCO+3
		if (orbit > belt.getHzcoPlus(3)) dm += 3;
		// DM+1 if belt span is greater than 1.0
		if (belt.span > 1) dm++;
		const n = ((dm + 1) * (belt.bulk + 1)) + this.roll(2, 6, -10, 'Planetoid Belt: Size 1 Significant Bodies');
		// Special Case: Span of < 0.1 divides number of Size S bodies by 2, rounded up
		return (belt.span < 0.1 ? Math.ceil(n / 2) : n);
	}

	genPlanetoidBeltBulk(system, belt)
	{
		// DM-1 per 2 Gyr of system age, rounded down
		let dm = -Math.round(system.age / 2, 0);
		// DM+1 per 10% of c-type composition, rounded down
		dm += Math.round(belt.composition_c / 10, 0);
		return this.roll(2, 2, dm, 'Planetoid Belt Bulk');
	}

	genPlanetoidBeltComposition(belt)
	{
		let dm = 0;
		// DM-4 if belt is inside the HZCO
		if (belt.isInHzco()) dm -= 4;
		// DM+4 if belt is beyond the HZCO+2
		if (belt.getHzcoOrbit() > belt.getHzcoPlus(2)) dm += 4;
		belt.composition_m = this.genPlanetoidBeltCompositionM(this.roll(2, 6, dm, 'Planetoid Belt Composition: m-type, 1st roll'));
		belt.composition_s = this.genPlanetoidBeltCompositionS(this.roll(2, 6, dm, 'Planetoid Belt Composition: s-type, 1st roll'));
		belt.composition_c = this.genPlanetoidBeltCompositionC(this.roll(2, 6, dm, 'Planetoid Belt Composition: c-type, 1st roll'));
		let diff = (belt.composition_m + belt.composition_s + belt.composition_c) - 100;
		if (diff > 0) {
			// Remove any excess first from m-type
			let tmp = belt.composition_m - diff;
			diff = (tmp > 0 ? 0 : diff - belt.composition_m);
			belt.composition_m = Math.max(0, tmp);
			// Remove any remaining excess next from s-type
			tmp = belt.composition_s - diff;
			diff = (tmp > 0 ? 0 : diff - belt.composition_s);
			belt.composition_s = Math.max(0, tmp);
			// Remove any remaining excess lastly from c-type
			belt.composition_c -= diff;
		} else if (diff < 0) {
			belt.composition_o = -diff;
		}
	}

	genPlanetoidBeltCompositionM(roll)
	{
		if (roll  <   1) return 60 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  1) return 50 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  2) return 40 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  3) return 25 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  4) return 15 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  5) return  5 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  6) return  0 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  7) return  5 + 2 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  8) return  5 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll ===  9) return  0 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		if (roll === 10) return  0 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: m-type');
		return (roll > 11 ? 0 : this.roll(1, 3, 0, 'Planetoid Belt Composition: m-type'));
	}

	genPlanetoidBeltCompositionS(roll)
	{
		if (roll  <   1) return  0 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  1) return  5 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  2) return 15 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  3) return 30 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  4) return 35 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  5) return 40 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  6) return 40 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  7) return 35 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  8) return 30 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll ===  9) return 15 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll === 10) return  5 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		if (roll === 11) return  5 + 2 * this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
		return this.roll(1, 6, 0, 'Planetoid Belt Composition: s-type');
	}

	genPlanetoidBeltCompositionC(roll)
	{
		if (roll ===  1) return  0 + 1 * this.roll(1, 3, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  2) return  0 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  3) return  0 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  4) return  5 + 1 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  5) return  5 + 2 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  6) return  0 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  7) return 10 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  8) return 20 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll ===  9) return 40 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll === 10) return 50 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll === 11) return 60 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		if (roll === 12) return 70 + 5 * this.roll(1, 6, 0, 'Planetoid Belt Composition: c-type');
		return 0;
	}

	genPlanetoidBeltResourceRating(belt)
	{
		// DM+1 per point of bulk
		let dm = belt.bulk;
		// DM+1 per 10% of m-type composition, rounded down
		dm += Math.round(belt.composition_m / 10, 0);
		// DM-1 per 10% of c-type composition, rounded down
		dm -= Math.round(belt.composition_c / 10, 0);
		return this.roll(2, 6, dm - 7, 'Planetoid Belt Resource Rating');
	}

	genPlanetoidBeltSpan(system, belt)
	{
		let dm = 0;
		const group_spread = (this.per_star_baseline ? belt.host.getMinimumOrbitSpread() : 0);
		const spread = (group_spread > 0 ? group_spread : system.getMinimumOrbitSpread());
		// DM-1 if any adjacent orbital slot contains a Gas Giant
		const orbit = belt.getHzcoOrbit();
		const lower = orbit - spread;
		const upper = orbit + spread;
		const adj_gas = belt.host.bodies.find(body => {
			if (body.type === PLANET_GAS) {
				const orb = body.getHzcoOrbit();
				return orb > lower && orb < upper;
			}
			return false;
		});
		if (adj_gas) dm--;
		// DM+3 if the belt occupies the outermost orbital slot
		if (belt.index === belt.host.bodies.length) dm += 3;
		return spread * 0.1 * this.roll(2, 6, dm, 'Planetoid Belt Span');
	}

	genTraitsTerrestrial(system, world)
	{
		// Special Case: No additional characteristics for Planetoids or Planetary Rings (i.e. Size 0 Planets or Moons)
		if (world.size === 0) {
			return;
		}
		world.diameter = (world.size < 0 ? 600 : TERRESTRIAL_DIAMETERS[world.size]);
		world.diameter_deviation = this.genTerrestrialDiameterDeviation(world);
		world.composition = this.genTerrestrialComposition(system, world);
		world.density = this.genTerrestrialDensity(world);
		world.mass = this.genTerrestrialMass(world);
		world.gravity = this.genGravity(world);
		world.atmosphere = this.atmosphere_factory.generate(system, world);
		world.temperature = this.genTemperature(world);
		// All worlds suffering from runaway greenhouse effect are assumed to be Boiling for Hydrographics code generation purposes
		const greenhouse = this.atmosphere_factory.isRunawayGreenhouse(system, world);
		this.atmosphere_factory.flushHistory(this);
		world.hydrographics = this.genHydrographicsCode(world, greenhouse);
		// Special Case: Unusual atmospheres may have a minimum hydrographics score
		if (world.atmosphere.type === 15) {
			// Steam requires a minimum of 5
			if (world.atmosphere.subtype === 8 || world.atmosphere.subtype_b === 8) {
				world.hydrographics = Math.max(5, world.hydrographics);
			}
			// Panthalassic requires a score of 10
			if (world.atmosphere.subtype === 7 || world.atmosphere.subtype_b === 7) {
				world.hydrographics = 10;
			}
		}
		world.hydrographics_percentage = this.genHydrographicsPercentage(world);
		world.habitability = clamp(this.genHabitabilityRating(world), 0, 12);
		world.albedo = this.genAlbedo(world);
		world.temperature_mean = this.genTemperatureMeanEstimate(world)
	}

	genHydrographicsCode(world, greenhouse = false)
	{
		// Special Case: Size 1 and smaller worlds have a Hydrographics code of 0
		if (world.size < 2) return 0;
		let dm = world.atmosphere.type;
		// DM-4 for atmosphere types 0, 1, or A+
		if (world.atmosphere.type < 2 || world.atmosphere.type > 9) dm -= 4;
		// DM-2 for Hot temperatures
		if (!greenhouse && world.temperature > 9 && world.temperature < 12) dm -= 2;
		// DM-6 for Boiling temperatures or any suffering from a Runaway Greenhouse Effect
		if (greenhouse || world.temperature > 11) dm -= 6;
		return clamp(this.roll(2, 6, dm - 7, 'Hydrographics Code'), 0, 10);
	}

	genHydrographicsPercentage(world)
	{
		// Special Case: Size 9+ worlds with Hydrographics 10 are always treated as 100% liquid
		if (world.size > 8 && world.hydrographics === 10) return 100;
		return clamp((10 * world.hydrographics) + this.roll(1, 10, -4, 'Hydrographics Percentage'), 0, 100);
	}

	genHabitabilityRating(world)
	{
		const atmo = this.getHabitabilityAtmoMod(world.atmosphere);
		const hydro = this.getHabitabilityHydroMod(world);
		const size = this.getHabitabilitySizeMod(world);
		const grav = this.getHabitabilityGravMod(world, size !== 0);
		const temp = this.getHabitabilityTempMod(world);
		log('World Habitability mods for ' + world.getDesignation() + ': Atmo = ' + signed(atmo) + ', Grav = ' + signed(grav) + ', Hydro = ' + signed(hydro) + ', Size = ' + signed(size) + ', Temp = ' + signed(temp));
		return 10 + atmo + grav + hydro + size + temp;
	}

	getHabitabilityAtmoMod(atmosphere)
	{
		// DM-1 for Low Oxygen taint, in addition to any other DMs
		const dm = (atmosphere.taints.find(t => t.subtype === TAINT_L) === undefined ? 0 : -1);
		// DM+0 for Atmosphere 6
		if (atmosphere.type === 6) return dm;
		// DM-8 for Atmosphere 0, 1, or 10 (A)
		if ([0, 1, 10].includes(atmosphere.type)) return dm - 8;
		// DM-4 for Atmosphere 2 or 14 (E)
		if (atmosphere.type === 2 || atmosphere.type === 14) return dm - 4;
		// DM-3 for Atmosphere 3 or 13 (D)
		if (atmosphere.type === 3 || atmosphere.type === 13) return dm - 3;
		// DM-2 for Atmosphere 4 or 9
		if (atmosphere.type === 4 || atmosphere.type === 9) return dm - 2;
		// DM-1 for Atmosphere 5, 7, or 8
		if ([5, 7, 8].includes(atmosphere.type)) return dm - 1;
		// DM-10 for Atmosphere 11 (B)
		if (atmosphere.type === 11) return dm - 10;
		// DM-12 for Atmosphere 12 (C) or 15+ (F+)
		return dm - 12;
	}

	getHabitabilityGravMod(world, fudge_flag = false)
	{
		const fudge = (fudge_flag ? 0.05 : 0);
		// DM-4 for Gravity < 0.2
		if (world.gravity < 0.2 + fudge) return -4;
		// DM-2 for Gravity < 0.4
		if (world.gravity < 0.4 + fudge) return -2;
		// DM-1 for Gravity < 0.7
		if (world.gravity < 0.7 + fudge) return -1;
		// DM+1 for Gravity < 0.9 (opposite fudge from here on to push toward lower DM)
		if (world.gravity < 0.9 - fudge) return 1;
		// DM+0 for Gravity < 1.1
		if (world.gravity < 1.1 - fudge) return 0;
		// DM-1 for Gravity < 1.4
		if (world.gravity < 1.4 - fudge) return -1;
		// DM-3 for Gravity < 2.0
		if (world.gravity < 2.0 - fudge) return -3;
		// DM-6 for Gravity 2.0 or higher
		return -6;
	}

	getHabitabilityHydroMod(world)
	{
		// DM-4 for Hydrographics 0 or 9
		if (world.hydrographics < 1 || world.hydrographics === 9) return -4;
		// DM-2 for Hydrographics 1-3 or 10 (A)
		if (world.hydrographics < 4 || world.hydrographics === 10) return -2;
		return 0;
	}

	getHabitabilitySizeMod(world)
	{
		// DM-1 for Size 0-4
		if (world.size < 5) return -1;
		// DM+1 for Size 9+
		if (world.size > 8) return 1;
		return 0;
	}

	getHabitabilityTempMod(world)
	{
		// DM-6 for Boiling or Frozen
		if (world.temperature < 3 || world.temperature > 11) return -6;
		// DM-2 for Hot or Cold
		if (world.temperature < 5 || world.temperature > 9) return -2;
		return 0;
	}

	/**
	 * Depends on world.size
	 *
	 * @param World a terrestrial world or moon
	 */
	genTerrestrialComposition(system, world)
	{
		const dm = this.getTerrestrialCompositionMod(system, world);
		const result = this.roll(2, 6, dm, 'Terrestrial Planet: Composition');
		if (result < -3) return 0;
		if (result < -1) return 1;
		if (result <  7) return 2;
		if (result < 12) return 3;
		if (result < 15) return 4;
		return 5;
	}

	getTerrestrialCompositionMod(system, world)
	{
		let dm = 0;
		const orbit = world.getHzcoOrbit();
		const hzco = world.getHzco();
		// DM-1 if Size < 5
		if (world.size < 5) dm--;
		// DM+1 if Size > 4 and < 10
		if (world.size > 4 && world.size < 10) dm++;
		// DM+3 if Size > 9
		if (world.size > 9) dm += 3;
		// DM+1 if World is at HZCO or closer
		if (orbit <= hzco) dm++;
		// DM-1 if World is further than HZCO
		if (orbit > hzco) dm--;
		// DM-1 per full 1.0 Orbit# beyond HZCO, where 0.1 is a "full Orbit#" while HZCO < 1
		const outer_in = Math.min(1, orbit) - hzco;
		if (outer_in > 0) dm -= Math.floor(10 * outer_in);
		const outer_out = orbit - Math.max(1, hzco);
		if (outer_out > 0) dm -= Math.floor(outer_out);
		// DM-1 if system more than 10 Gyrs old
		if (system.age > 10) dm--;
		return dm;
	}

	/**
	 * Depends on world.composition
	 *
	 * @param World a terrestrial world or moon
	 */
	genTerrestrialDensity(world)
	{
		const result = this.roll(2, 6, 0, 'Terrestrial Planet: Density');
		return TERRESTRIAL_DENSITIES[world.composition][result - 2];
	}

	genTerrestrialDiameterDeviation(world)
	{
		// Skip if not enabled
		if (!this.enable_var_size) {
			return 0;
		}
		// Special Case: Size S worlds only roll on the 2nd table
		const roll_a = (world.size < 0 ? 3 : this.roll(1, 3, 0, 'Terrestrial Planet: Diameter Variance (1st table)'));
		const roll_b = this.roll(1, 6, 0, 'Terrestrial Planet: Diameter Variance (2nd table)');
		// Special Case: Reroll both dice if the first die is 3 and the second 5+
		if (roll_a === 3 && roll_b > 4) {
			return this.genTerrestrialDiameterDeviation(world);
		}
		// Diameters in the lookup table assume the exact midpoint, which is 800 (or 200 for Size S) higher than the minimum diameters upon which deviations are based
		let mod = (world.size < 0 ? -200 : -800);
		if (world.size < 0) {
			mod += (roll_b - 1) * this.roll(1, 100, 0, 'Terrestrial Planet: Diameter Variance (Size S world)');
		} else {
			mod += 100 * (roll_b - 1);
			if (roll_a === 1) mod += 600;
			if (roll_a === 2) mod += 1200;
		}
		// Variation down to the single-kilometer level
		mod += 10 * this.roll(1, 10, -1, 'Terrestrial Planet: Diameter Variance (tens place)');
		mod += this.roll(1, 10, -1, 'Terrestrial Planet: Diameter Variance (ones place)');
		return mod;
	}

	/**
	 * Depends on world.density and world.diameter
	 *
	 * @param World a terrestrial world or moon
	 */
	genTerrestrialMass(world)
	{
		return world.density * Math.pow(world.getTotalDiameter() / TERRA_DIAMETER, 3);
	}

	genMoon(system, world, size, type)
	{
		// Special Case: Planetary Rings are generally inside the Roche Limit (i.e. 1.5 PD) and so placed in band 0
		const band = (type === PLANET_RING ? 0 : this.genMoonOrbitBand(world));
		const orbit = this.genMoonOrbit(world, band);
		const moon = this.getMoonInstance(world, orbit, type);
		moon.orbit_band = band;
		moon.orbit_deviation = (this.enable_var_orbit && type !== PLANET_RING ? 0.1 * this.roll(2, 6, -7, 'Moon Orbit: Variance') : 0);
		moon.size = size;
		this.genTraits(system, moon);
		// Determine Orbital Period, in hours; distance is in PD, and world size for gas giants is 8 per size category (i.e. S = 8, M = 16, L = 24)
		const world_size = (world.type === PLANET_GAS ? (world.size + 1) * 8 : world.size);
		const combined = moon.getTotalMass() + world.getTotalMass();
		const distance = moon.getTotalOrbit() * world_size;
		moon.orbit_period = 0.176927 * Math.sqrt(Math.pow(distance, 3) / combined);
		this.flushHistory(moon);
		return moon;
	}

	getMoonInstance(world, orbit, type)
	{
		switch (type) {
		case PLANET_MOON: return new Moon(world, orbit, world.bodies.length + 1);
		case PLANET_RING: return new PlanetaryRing(world, orbit, world.bodies.length + 1);
		}
		return new World(world, orbit, world.bodies.length + 1, type);
	}

	genSignificantMoons(system, world)
	{
		const hill_sphere_moon_limit = world.hill_sphere / 2;
		const n = this.genSignificantMoonQty(system, world);
		if (n < 0) {
			// No significant moons
		} else if (hill_sphere_moon_limit < 0.55) {
			// No moons or planetary rings can exist due to the extremely low Hill Sphere
		} else if (n < 1) {
			// Planetary ring, i.e. a Size 0 moon
			world.bodies.push(this.genMoon(system, world, 0, PLANET_RING));
		} else if (hill_sphere_moon_limit < 1.5) {
			// Hill Sphere Moon Limit is below the Roche Limit; convert first moon to a planetary ring and ignore the remainder
			log('Hill Sphere Moon Limit for ' + world.getDesignation(system.n_stellar) + ' is too low for moons; converting first to a Planetary Ring and ignoring the remaining ' + (n - 1));
			world.bodies.push(this.genMoon(system, world, 0, PLANET_RING));
		} else {
			// Generate n moons
			for (let i = 0; i < n; i++) {
				let type = PLANET_MOON;
				let size = this.genMoonSize(world);
				// Special Case: Any non-ring moon with Size of -1 or smaller is Size S (i.e. -1)
				if (size < 0) size = -1;
				// Special Case: Any non-ring moon exactly 2 sizes less than its host Terrestrial Planet rolls 2D (Size S counts as 0 for this purpose)
				if (world.type === PLANET_ROCK && size !== 0 && Math.max(0, size) === (world.size - 2)) {
					const roll = this.roll(2, 6, 0, 'Moon Size: Exactly 2 less than Terrestrial host');
					if (roll === 2) size = world.size - 1;
					if (roll === 12) {
						size = world.size;
						type = PLANET_ROCK;
					}
				}
				// Special Case: Size 0 moons become Planetary Rings
				if (size === 0 && type === PLANET_MOON) {
					type = PLANET_RING;
				}
				// Special Case: Maximum size moon around a Gas Giant
				if (world.type === PLANET_GAS && size === 16) {
					size = 0; // Size S
					type = PLANET_GAS;
					// Special Case: If the parent Gas Giant is Large, roll another 2D; on a 12, the moon is a Size M gas giant
					if (world.size > 1 && 12 === this.roll(2, 6, 0, 'Moon Size: Large Gas Giant')) size = 1;
				}
				world.bodies.push(this.genMoon(system, world, size, type));
			}
			// Reorder and re-index moons based on their actual orbit#s
			world.bodies.sort((a, b) => a.getTotalOrbit() - b.getTotalOrbit());
			for (let j = 0; j < world.bodies.length; j++) {
				world.bodies[j].index = j + 1;
			}
		}
	}

	genSignificantMoonQty(system, world)
	{
		// Either DM-1 or 0, to be applied per die rolled
		const dm = this.getSignificantMoonMod(system, world);
		switch (world.type) {
		case PLANET_GAS:
			if (world.size < 0) return -1;
			if (world.size < 1) return this.roll(3, 6, (3 * dm) - 7, 'Significant Moons: Quantity');
			return this.roll(4, 6, (4 * dm) - 6, 'Significant Moons: Quantity');
		case PLANET_ROCK:
			if (world.size < 1) return -1;
			if (world.size < 3) return this.roll(1, 6, (1 * dm) - 5, 'Significant Moons: Quantity');
			if (world.size < 10) return this.roll(2, 6, (2 * dm) - 8, 'Significant Moons: Quantity');
			return this.roll(2, 6, (2 * dm) - 6, 'Significant Moons: Quantity');
		}
		return -1;
	}

	getSignificantMoonMod(system, world)
	{
		// Apply DM-1 per die only for the first condition that applies, ignoring any additional conditions
		if (this.hill_moon_qty) {
			return (world.hill_sphere < 60 ? -1 : 0);
		}
		const orbit = world.getTotalOrbit();
		const group_spread = (this.per_star_baseline ? world.host.getMinimumOrbitSpread() : 0);
		const spread = (group_spread > 0 ? group_spread : system.getMinimumOrbitSpread());
		// DM-1 if planet’s Orbit# is less than 1.0
		if (orbit < 1) return -1;
		// DM-1 if planet is an orbital slot adjacent to a companion, i.e. within 1 x spread of the companion-induced MAO (0.5 + eccentricity)
		if (world.host instanceof StarGroupCompanion && orbit < (world.host.getMinimumAllowableOrbit() + spread)) return -1;
		// if ((world.host instanceof Star && (world.host.companion || world.host.host))) {
		// DM-1 if planet’s orbital slot around a primary star (or pair) is adjacent to a Close or Near star unavailability range
		if (world.host.isPrimaryComponent()) {
			const adjacent = system.stars.find(star => {
				if (star.orbit_band < 1 || star.orbit_band > 2) return false;
				const min = star.getMinimumAllowableOrbit();
				if (orbit < min && min - spread < orbit) return true;
				const max = star.getMaximumAllowableOrbit();
				if (max < orbit && orbit < max + spread) return true;
			});
			if (adjacent) return -1;
		}
		// DM-1 if planet is in the adjacent orbital slot to the outermost Orbit# range of a Close, Near or Far star (e.g. around B, Ba, or Bb but not around AB)
		if (!world.host.isPrimaryComponent() && world.host.orbit_band > 0 && orbit > (world.host.getMaximumAllowableOrbit() - spread)) return -1;
		return 0;
	}

	getMoonEccentricityMod(moon)
	{
		let dm = 0;
		// DM-1 for Inner orbit moons
		if (moon.orbit_band === 1) dm--;
		// DM+1 for Middle orbit moons
		if (moon.orbit_band === 2) dm++;
		// DM+4 for Outer orbit moons
		if (moon.orbit_band === 3) dm += 4;
		// Additional DM+2 for any moons beyond the MOR (Moon Orbit Range)
		if (moon.getTotalOrbit() > moon.host.moon_orbit_range) dm += 2;
		return dm;
	}

	/**
	 * @return integer The value to use for the moon's orbit band: 0 = Adjacent (i.e. Planetary Ring), 1 = Inner, 2 = Middle, 3 = Outer
	 */
	genMoonOrbitBand(world)
	{
		const dm = (world.moon_orbit_range < 60 ? 1 : 0);
		const roll = this.roll(1, 6, dm, 'Moon Orbit: Range/Band Determination');
		return (roll < 4 ? 1 : (roll > 5 ? 3 : 2));
	}

	/**
	 * @param int orbit_band The orbit band the moon will be placed in
	 */
	genMoonOrbit(world, orbit_band)
	{
		// Special Case: Planetary Rings use a different calculation for their center of orbit
		if (orbit_band = 0) return 0.4 + (this.roll(2, 6, 0, 'Moon Orbit: Planetary Ring') / 8);
		// Moon Orbit Range capped at 200 for the purpose of determining Orbit#
		const mor = Math.min(200, world.moon_orbit_range);
		const roll = this.roll(2, 6, -2, 'Moon Orbit: Location in PD');
		if (orbit_band === 2) return roll * (mor / 30) + (mor / 6) + 3;
		if (orbit_band === 3) return roll * (mor / 20) + (mor / 2) + 4;
		return roll * (mor / 60) + 2;
	}

	genMoonSize(world)
	{
		const roll = this.roll(1, 6, 0, 'Moon Size: 1st roll');
		if (roll < 4) return -1; // Size S
		if (roll < 6) return this.roll(1, 3, -1, 'Moon Size: 2nd roll');
		if (world.type !== PLANET_GAS) return (world.size - 1) - this.roll(1, 6, 0, 'Moon Size: 2nd roll');
		// Special Case: Gas Giants
		const gas = this.roll(1, 6, 0, 'Moon Size: Gas Giant Special, 1st roll');
		if (roll < 4) return this.roll(1, 6, 0, 'Moon Size: Gas Giant Special, 2nd roll');
		if (roll < 6) return this.roll(2, 6, -2, 'Moon Size: Gas Giant Special, 2nd roll');
		return this.roll(2, 6, 4, 'Moon Size: Gas Giant Special, 2nd roll');
	}
}

class AtmosphereFactory extends AbstractFactory
{
	/**
	 * @param FormData options:
	 *   @option bool green_check True to enable checking for Runaway Greenhouse Effects
	 *   @option bool green_inner True to also check all planets orbiting below the HZCO for Runaway Greenhouse Effect
	 */
	constructor(options)
	{
		super();
		this.enable_green_check = options.has('green_check');
		this.enable_green_inner = options.has('green_inner');
	}

	generate(system, world)
	{
		// Only terrestrial planets and moons need to determine atmosphere type
		if (![PLANET_ROCK, PLANET_MOON].includes(world.type)) return null;
		const atmosphere = this.genType(world);
		atmosphere.type_orig = atmosphere.type;
		this.genSubtype(world, atmosphere, false);
		atmosphere.density = this.genDensity(atmosphere);
		atmosphere.bar = this.genPressureTotal(atmosphere);
		atmosphere.ppo = this.genPressureOxygen(system, atmosphere);
		// Special Case: PPO < 0.1 or > 0.5 for supposedly breathable atmosphere type of 5, 6, or 8; change to corresponding Tainted version
		if ([5, 6, 8].includes(atmosphere.type) && (atmosphere.ppo < 0.1 || atmosphere.ppo > 0.5)) {
			log('World ' + world.getDesignation(system.n_stellar) + ' atmospheric PPO out of bounds for breathable atmosphere ' + atmosphere.type + '; changing to corresponding Tainted type');
			atmosphere.type = (atmosphere.type < 6 ? 4 : atmosphere.type + 1);
		}
		// Tainted atmosphere types are 2, 4, 7, and 9
		if (atmosphere.irritant || [2, 4, 7, 9].includes(atmosphere.type)) {
			this.genTaint(atmosphere);
		}
		atmosphere.greenhouse_factor = this.genGreenhouseFactor(atmosphere);
		return atmosphere;
	}

	genType(world)
	{
		// Special Case: Worlds of Size 1 or less have no significant atmosphere
		if (world.size < 2) return new Atmosphere(0);
		const dm = this.getTypeMod(world);
		const roll = this.roll(2, 6, world.size + dm - 7, 'Atmosphere Type');
		// Habitable zone atmospheres use the die result effectiely as is
		if (world.isInHzco()) {
			return new Atmosphere(clamp(roll, 0, 17));
		}
		// Non-habitable zone atmospheres have multiple charts
		const orbit = world.getHzcoOrbit();
		if (orbit < world.getHzcoPlus(-2)) return this.genTypeHotPlus(world, roll);
		if (orbit < world.getHzcoPlus(-1)) return this.genTypeHot(world, roll);
		if (orbit > world.getHzcoPlus(3)) return this.genTypeCold(world, roll);
		if (orbit > world.getHzcoPlus(1)) return this.genTypeColdPlus(world, roll);
		log('Failed to determine atmosphere for ' + world.getDesignation(2) + ' at Orbit# ' + orbit.toFixed(4) + ' around HZCO ' + world.getHzco());
		return new Atmosphere(0);
	}

	getTypeMod(world)
	{
		let dm = 0;
		// DM-1 if world's gravity is less than 0.5G
		if (world.gravity < 0.5) dm--;
		// DM-1 (in addition to the above) if world's gravity is less than 0.4G
		if (world.gravity < 0.4) dm--;
		return dm;
	}

	genTypeHotPlus(world, roll)
	{
		if (roll < 2) return new Atmosphere(0); // None
		if (roll < 4) return new Atmosphere(1); // Trace
		if (roll < 9) {
			const density = (roll - 2);
			const irritant = (this.roll(1, 6, 0, 'Atmospheric Irritant Presence') > 4);
			// Special Case: world's orbit is closer than HZCO-3
			if (world.getHzcoOrbit() < world.getHzcoPlus(-3)) {
				const dm = (density > 4 ? 1 : 0);
				const roll_b = this.roll(1, 6, dm, 'Atmosphere Type: Orbit < HZCO-3');
				if (roll_b === 1) return new Atmosphere(1, density, irritant);
				if (roll_b === 2) return new Atmosphere(10, density, irritant); // Exotic
				if (roll_b > 5) return new Atmosphere(12, density, irritant); // Insidious
				return new Atmosphere(11, density, irritant); // Corrosive
			}
			return new Atmosphere(10, density, irritant); // Exotic
		}
		if (roll < 12 || roll === 13) return new Atmosphere(11); // Corrosive
		if (roll < 15) return new Atmosphere(12); // Insidious
		// Rolls of 15+ can be used directly as the corresponding type, capped at 17 (Gas, Hydrogen)
		return new Atmosphere(Math.min(17, roll));
	}

	genTypeHot(world, roll)
	{
		if (roll < 1) return new Atmosphere(0); // None
		if (roll < 2) return new Atmosphere(1); // Trace
		if (roll < 11) {
			const density = 1 + Math.floor(roll / 2);
			const irritant = ([2, 4, 7, 9].includes(roll) || (roll === 10 && this.roll(1, 6, 0, 'Atmospheric Irritant Presence') > 4));
			return new Atmosphere(10, density, irritant); // Exotic
		}
		if (roll === 11 || roll === 13) return new Atmosphere(11); // Corrosive
		if (roll < 15) return new Atmosphere(12); // Insidious
		// Rolls of 15+ can be used directly as the corresponding type, capped at 17 (Gas, Hydrogen)
		return new Atmosphere(Math.min(17, roll));
	}

	genTypeCold(world, roll)
	{
		if (roll < 1) return new Atmosphere(0); // None
		if (roll < 3) return new Atmosphere(1); // Trace
		if (roll < 11) {
			const density = 1 + Math.floor(roll / 2);
			const irritant = ([4, 7, 9].includes(roll) || ([3, 10].includes(roll) && this.roll(1, 6, 0, 'Atmospheric Irritant Presence') > 4));
			return new Atmosphere(10, density, irritant); // Exotic
		}
		if (roll === 11 || roll === 14) return new Atmosphere(11); // Corrosive
		// Rolls of 12+ can be used directly as the corresponding type, capped at 17 (Gas, Hydrogen)
		return new Atmosphere(Math.min(17, roll));
	}

	genTypeColdPlus(world, roll)
	{
		// Rolls of 12- are identical to the normal Cold results
		if (roll < 13) return this.genTypeCold(world, roll);
		if (roll === 13) return new Atmosphere(16); // Gas, Helium
		if (roll === 15) return new Atmosphere(15); // Unusual
		return new Atmosphere(17); // Gas, Hydrogen
	}

	genSubtype(world, atmosphere, greenhouse = false)
	{
		// Special Case: Exotic atmospheres roll for subtype; this may also determine density and whether to roll for irritants
		if (atmosphere.type === 10) {
			atmosphere.subtype = this.genSubtypeExotic(world, atmosphere, greenhouse);
			atmosphere.irritant = atmosphere.irritant || ([2, 4, 7, 9, 11, 14].includes(atmosphere.subtype));
		}
		// Special Case: Corrosive and Insidious atmospheres roll for subtype; this may also determine density and whether to roll for irritants
		if (atmosphere.type === 11 || atmosphere.type === 12) {
			atmosphere.subtype = this.genSubtypeHazardous(world, atmosphere, greenhouse);
			atmosphere.irritant = atmosphere.irritant || ([2, 4, 7, 9, 11, 14].includes(atmosphere.subtype));
		}
		// Special Case: Unusual atmospheres roll for subtype, which may dictate density
		if (atmosphere.type === 15) {
			atmosphere.subtype = this.genSubtypeUnusual(world, atmosphere);
		}
	}

	genSubtypeExotic(world, atmosphere, greenhouse = false)
	{
		const dm = this.getSubtypeMod(world, atmosphere, greenhouse);
		const roll = this.roll(2, 6, dm, 'Atmosphere Subtype: ' + atmosphere.getTypeName());
		const subtype = clamp(roll, 2, 14);
		// Exotic densities range from Very Thin (2) to Very Dense (6), increasing on each even result starting at 4
		atmosphere.density = 1 + Math.floor(Math.min(10, subtype) / 2);
		// Special Case: Roll of 13 = A (10) and 14 = B (11)
		return subtype > 12 ? subtype - 3 : subtype;
	}

	genSubtypeHazardous(world, atmosphere, greenhouse = false)
	{
		const dm = this.getSubtypeMod(world, atmosphere, greenhouse);
		const roll = this.roll(2, 6, dm, 'Atmosphere Subtype: ' + atmosphere.getTypeName());
		const subtype = clamp(roll, 1, 14);
		// Corrosive and Insidious densities range from Very Thin (2) to Extremely Dense (7), increasing on each even result starting at 4
		atmosphere.density = Math.max(2, 1 + Math.floor(Math.min(12, subtype) / 2));
		return subtype;
	}

	genSubtypeUnusual(world, atmosphere, combo = false)
	{
		const roll = this.roll(1, 12, 0, 'Atmosphere Subtype: ' + atmosphere.getTypeName());
		// Special Case: Layered subtype requires gravity > 1.2
		if (roll === 6 && world.gravity <= 1.2) {
			return this.genSubtypeUnusual(world, atmosphere, combo);
		}
		// Special Case: Dense results are incompatible with each other
		if (roll < 4 && atmosphere.subtype_b > -1 && atmosphere.subtype_b < 4) {
			return this.genSubtypeUnusual(world, atmosphere, combo);
		}
		// Special Case: Combination (i.e. 2 subtypes)
		if (roll === 11) {
			if (combo || atmosphere.subtype_b > -1) return this.genSubtypeUnusual(world, atmosphere, combo);
			atmosphere.subtype_b = this.genSubtypeUnusual(world, atmosphere, true);
			return this.genSubtypeUnusual(world, atmosphere, true);
		}
		return (roll > 10 ? 15 : roll);
	}

	getSubtypeMod(world, atmosphere, greenhouse = false)
	{
		let dm = 0;
		const orbit = world.getHzcoOrbit();
		// DM-2 for Size 2-4 worlds
		if (world.size > 1 && world.size < 5) dm -= 2;
		// DM-2 if orbit below HZCO-1
		if (orbit < world.getHzcoPlus(-1)) dm -= 2;
		// DM+2 if orbit greater than HZCO+2
		if (orbit > world.getHzcoPlus(2)) dm += 2;
		// DM+4 if the atmosphere became exotic because of a runaway greenhouse check
		if (greenhouse) dm += 4;
		// DM+2 for Size 8+ worlds with Corrosive or Insidious atmospheres
		if (atmosphere.type !== 10 && world.size > 7) dm += 2;
		// DM+2 if atmosphere is Insidious
		if (atmosphere.type === 12) dm += 2;
		return dm;
	}

	genDensity(atmosphere)
	{
		// Special Case: density already determined by special atmosphere type
		if (atmosphere.density > -1) return atmosphere.density;
		if (atmosphere.type  <   1) return 0; // None
		if (atmosphere.type  <   2) return 1; // Extremely Thin
		if (atmosphere.type  <   4) return 2; // Very Thin
		if (atmosphere.type  <   6) return 3; // Thin
		if (atmosphere.type  <   8) return 4; // Standard
		if (atmosphere.type  <  10) return 5; // Dense
		// Atmosphere types 10-12 (Exotic, Corrosive, and Insidious) should have already determined density
		if (atmosphere.type === 13) return 6; // Very Dense
		if (atmosphere.type === 14) return 2; // Very Thin
		if (atmosphere.type === 16) return 8; // Crushing
		if (atmosphere.type === 17) return 9; // Extremely Crushing
		// Unusual atmosphere density depends on its subtype(s)
		if (atmosphere.type === 15) {
			if (atmosphere.subtype === 1 || atmosphere.subtype_b === 1) return 7;
			if (atmosphere.subtype === 2 || atmosphere.subtype_b === 2) return 8;
			if (atmosphere.subtype === 3 || atmosphere.subtype_b === 3) return 9;
			if (atmosphere.subtype === 8 || atmosphere.subtype_b === 8) return 6 + this.roll(1, 3, -1, 'Steam Atmosphere Density');;
			if (atmosphere.subtype === 7 || atmosphere.subtype_b === 7) return 4 + this.roll(1, 4, -1, 'Panthalassic Atmosphere Density');
		}
		return 4; // Default to Standard
	}

	genPressureTotal(atmosphere)
	{
		const max = this.getPressureMax(atmosphere.type, atmosphere.density);
		const low = this.getPressureMin(atmosphere.type, atmosphere.density);
		// Special Case: Unusual (Panthalassic) atmosphere subtype requires a minimum of 1.0 bar
		const pan = (atmosphere.type === 15 && (atmosphere.subtype === 7 || atmosphere.subtype_b === 7));
		const min = (pan ? Math.max(1.0, low) : low);
		const span = max - min;
		if (span > 0) {
			return min + (span * 0.01 * this.roll(1, 100, 0, 'Atmospheric Pressure: Total'));
		}
		return 0;
	}

	getPressureMax(type, density)
	{
		switch (density) {
		case 0: return 0.0009;
		case 1: return 0.09;
		case 2: return 0.42;
		case 3: return 0.70;
		case 4: return 1.49;
		case 5: return 2.49;
		case 6: return 10.0;
		case 7: return 100.0;
		case 8: return 1000.0;
		case 9: return 9999.9;
		}
		return 0;
	}

	getPressureMin(type, density)
	{
		// Special Case: H and He Gas atmospheres do not use the normal density ranges
		if (type === 16) return 100;
		if (type > 16) return 1000;
		switch (density) {
		case 0: return 0;
		case 1: return 0.001;
		case 2: return 0.1;
		case 3: return 0.43;
		case 4: return 0.70;
		case 5: return 1.5;
		case 6: return 2.5;
		case 7: return 10.0;
		case 8: return 100.0;
		case 9: return 1000.0;
		}
		return 0;
	}

	genPressureOxygen(system, atmosphere)
	{
		// PPO only for atmosphere types 2-9, D, and E
		if ((atmosphere.type < 2 || atmosphere.type > 9) && atmosphere.type !== 13 && atmosphere.type !== 14) {
			return 0;
		}
		const dm = this.getPressureOxygenMod(system);
		const a = 0.05 * this.roll(1, 6, dm, 'Atmosphere Pressure: Partial Oxygen (1st roll)');
		const b = 0.01 * this.roll(2, 6, -7, 'Atmosphere Pressure: Partial Oxygen (2nd roll)');
		const c = 0.05 * this.roll(1, 6, -1, 'Atmosphere Pressure: Partial Oxygen (3rd roll)');
		const v =  0.001 * this.roll(2, 6, -7, 'Atmosphere Pressure: Partial Oxygen Variance');
		let f = a + b + c + v;
		// Special Case: If result is 0 or less, determine it instead as 0.01 * 1D + variance
		if (f <= 0) {
			f = v + 0.01 * this.roll(1, 6, 0, 'Atmosphere Pressure: Partial Oxygen (reroll)');
		}
		return f * atmosphere.bar;
	}

	getPressureOxygenMod(system)
	{
		let dm = 0;
		// DM+1 if system more than 4 Gyrs old
		if (system.age > 4) dm++;
		// DM-1 if system between 3 and 3.5 Gyrs old
		if (system.age > 3 && system.age <= 3.5) dm--;
		// DM-2 if system between 2 and 3 Gyrs old
		if (system.age >= 2 && system.age < 3) dm -= 2;
		// DM-4 if system less than 2 Gyrs old
		if (system.age < 2) dm -= 4;
		return dm;
	}

	genGreenhouseFactor(atmosphere)
	{
		// Vacuum worlds have a greenhouse factor of 0 by definition
		if (atmosphere.type === 0) return 0;
		let gf = 0.5 * Math.sqrt(atmosphere.bar);
		// Atmosphere types 1-9, D, and E add 0.01 * 3D
		if (atmosphere.type < 10 || [13, 14].includes(atmosphere.type)) {
			gf += 0.01 * this.roll(3, 6, 0, 'Greenhouse Factor: Atmosphere (1-9, D, E)');
		}
		// Atmosphere types A and F add 1D-1 (min. 0.5)
		if (atmosphere.type === 10 || atmosphere.type === 15) {
			gf += Math.max(0.5, this.roll(1, 6, -1, 'Greenhouse Factor: Atmosphere (A, F)'));
		}
		// Atmosphere types B, C, G, and H roll 1D: on 1-5, multiply the greenhouse factor by the result, on a 6, multiply by 3D
		if ([11, 12, 16, 17].includes(atmosphere.type)) {
			const roll = this.roll(1, 6, 0, 'Greenhouse Factor: Atmosphere (B, C, G, H)');
			gf *= (roll < 6 ? roll : this.roll(3, 6, 0, 'Greenhouse Factor: Atmosphere (B, C, G, H)'));
		}
		return gf;
	}

	/**
	 * Checks for and applies the effects of the Runaway Greenhouse Effect
	 *
	 * @param StarSystem system
	 * @param World world Requires temperature to have been determined
	 *
	 * @return bool True if the world is determined to be suffering from a Runaway Greenhouse Effect
	 */
	isRunawayGreenhouse(system, world)
	{
		if (this.shouldCheckForRunawayGreenhouse(system, world)) {
			const dm = this.getRunawayGreenhouseMod(system, world);
			const roll = this.roll(2, 6, dm, 'Runaway Greenhouse Effect');
			if (roll > 11) {
				this.applyRunawayGreenhouse(system, world);
				return true;
			}
		}
		return false;
	}

	applyRunawayGreenhouse(system, world)
	{
		// Worlds with standard atmospheres (i.e. 2-9, D, or E) convert to A, B, or C
		if (world.atmosphere.type < 10 || world.atmosphere.type === 13 || world.atmosphere.type === 14) {
			let dm = 0;
			// DM-2 if world is Size 2-5
			if (world.size > 1 && world.size < 6) dm += 2;
			// DM+1 if original atmosphere was Tainted
			if ([2, 4, 7, 9].includes(world.atmosphere.type_orig)) dm++;
			const roll = this.roll(1, 6, dm, 'Runaway Greenhouse Effect: New Atmosphere Type');
			world.atmosphere.type = (roll < 2 ? 10 : (roll > 4 ? 12 : 11));
			this.genSubtype(world, world.atmosphere, true);
			// Recalculate atmospheric pressure and PPO using new density value
			world.atmosphere.bar = this.genPressureTotal(world.atmosphere);
			world.atmosphere.ppo = this.genPressureOxygen(system, world.atmosphere);
			// Clear previous Taints, if any, and check again if Irritant indicated as present
			world.atmosphere.taints = [];
			if (world.atmosphere.irritant) {
				this.genTaint(world.atmosphere);
			}
		}
	}

	shouldCheckForRunawayGreenhouse(system, world)
	{
		if (!this.enable_green_check) return false;
		// Worlds with atmospheres of < 2 or > F (15) never check for runaway greenhouse effect
		if (world.atmosphere.type < 2 || world.atmosphere.type > 15) return false;
		// Hot and Boiling worlds in the HZCO should check
		if (world.temperature > 9 && world.isInHzco()) return true;
		// Optionally, check for any world (i.e. regardless of temperature) closer than the HZCO
		if (this.enable_green_inner && world.getHzcoOrbit() < world.getHzcoPlus(-1)) return true;
		return false;
	}

	getRunawayGreenhouseMod(system, world)
	{
		let dm = 0;
		// DM+1 per Gyr of system age, rounded up
		dm += (system.age < 0.5 ? 0 : Math.ceil(system.age));
		// DM+4 if world is Boiling (i.e. temperature of 12+)
		if (world.temperature > 11) dm += 4;
		// DM-2 if world is Temperate (i.e. temperature of 5-9)
		if (world.temperature > 4 && world.temperature < 10) dm -= 2;
		return dm;
	}

	genTaint(atmosphere)
	{
		// Special Case: Flag for automatically-added Low or High Oxygen taint, which still need to roll to determine if there are additional taints
		let special = false;
		// Special Case: Atmospheres with PPO < 0.1 automatically acquire the Low Oxygen taint as their first
		if (atmosphere.ppo < 0.1 && atmosphere.taints.length < 1) {
			atmosphere.taints.push(new AtmosphereTaint(TAINT_L, this.genTaintSeverity(atmosphere, TAINT_L), 0));
			special = true;
		}
		// Special Case: Atmospheres with PPO > 0.5 automatically acquire the High Oxygen taint as their first
		if (atmosphere.ppo > 0.5 && atmosphere.taints.length < 1) {
			atmosphere.taints.push(new AtmosphereTaint(TAINT_H, this.genTaintSeverity(atmosphere, TAINT_H), 0));
			special = true;
		}
		const roll_a = this.genTaintSubtypeRoll(atmosphere);
		if (roll_a === 10) {
			if (!special) {
				atmosphere.taints.push(new AtmosphereTaint(TAINT_P, this.genTaintSeverity(atmosphere, TAINT_P), 0));
			}
			const roll_b = this.genTaintSubtypeRoll(atmosphere);
			if (!special) {
				const type_b = this.getTaintSubtypeFromRoll(roll_b);
				atmosphere.taints.push(new AtmosphereTaint(type_b, this.genTaintSeverity(atmosphere, type_b), 0));
			} else if (roll_b === 10) {
				atmosphere.taints.push(new AtmosphereTaint(TAINT_P, this.genTaintSeverity(atmosphere, TAINT_P), 0));
			}
			if (roll_b === 10) {
				const roll_c = this.genTaintSubtypeRoll(atmosphere);
				if (!special) {
					const type_c = this.getTaintSubtypeFromRoll(roll_c);
					atmosphere.taints.push(new AtmosphereTaint(type_c, this.genTaintSeverity(atmosphere, type_c), 0));
				} else if (roll_b === 10) {
					const roll_d = this.genTaintSubtypeRoll(atmosphere);
					const type_d = this.getTaintSubtypeFromRoll(roll_d);
					atmosphere.taints.push(new AtmosphereTaint(type_d, this.genTaintSeverity(atmosphere, type_d), 0));
				}
			}
		} else if (!special) {
			const type_a = this.getTaintSubtypeFromRoll(roll_a);
			atmosphere.taints.push(new AtmosphereTaint(type_a, this.genTaintSeverity(atmosphere, type_a), 0));
		}
		// Determine persistence for each Taint
		atmosphere.taints.forEach(taint => taint.persistence = this.genTaintPersistence(atmosphere, taint));
	}

	genTaintSubtypeRoll(atmosphere, n = 1)
	{
		const dm = this.getTaintMod(atmosphere);
		let roll = this.roll(2, 6, dm, 'Atmosphere Taint: Subtype');
		// Special Case: Change duplicate Oxygen taint result (of any kind) to Gas Mix
		if ((roll < 3 || roll > 11) && undefined !== atmosphere.taints.find(t => t.subtype === TAINT_H || t.subtype === TAINT_L)) {
			roll = 7;
		}
		// Special Case: Change Oxygen taint (of any kind) to Gas Mix for any atmosphere type outside the 4-9 range
		if ((roll < 3 || roll > 11) && (atmosphere.type < 3 || atmosphere.type > 9)) {
			roll = 7;
		}
		// Special Case: Low Oxygen taint as the result of a roll reduces PPO to less than 0.1
		if (roll < 3 && atmosphere.ppo >= 0.1) {
			atmosphere.ppo = 0.1 - (0.01 * this.roll(1, 6, 0, 'Atmosphere Taint: new PPO value for Low Oxygen'));
		}
		// Special Case: High Oxygen taint as the result of a roll increases PPO to greater than 0.5
		if (roll > 11 && atmosphere.ppo <= 0.5) {
			atmosphere.ppo = 0.5 + (0.1 * this.roll(1, 6, 0, 'Atmosphere Taint: new PPO value for High Oxygen'));
		}
		return roll;
	}

	getTaintSubtypeFromRoll(roll)
	{
		if (roll < 3) return TAINT_L;
		if (roll > 11) return TAINT_H;
		if (roll === 3 || roll === 11) return TAINT_R;
		if (roll === 4 || roll === 9) return TAINT_B;
		if (roll === 5 || roll === 7) return TAINT_G;
		if (roll === 8) return TAINT_S;
		return TAINT_P;
	}

	getTaintMod(atmosphere)
	{
		let dm = 0;
		// DM-2 for atmosphere type 4
		if (atmosphere.type === 4) dm -= 2;
		// DM+2 for atmosphere type 9
		if (atmosphere.type === 9) dm += 2;
		return dm;
	}

	genTaintSeverity(atmosphere, subtype)
	{
		// Special Case: Low Oxygen severity determined by atmospheric PPO level
		if (subtype === TAINT_L) {
			if (atmosphere.ppo >= 0.09) return 2;
			if (atmosphere.ppo >= 0.08) return 3;
			if (atmosphere.ppo >= 0.06) return 8;
			return 9;
		}
		// Special Case: High Oxygen severity determined by atmospheric PPO level
		if (subtype === TAINT_H) {
			if (atmosphere.ppo < 0.6) return 2;
			if (atmosphere.ppo < 0.7) return 7;
			if (atmosphere.ppo < 0.75) return 8;
			return 9;
		}
		// DM+6 for Insidious atmospheres
		const dm = (atmosphere.type === 12 ? 6 : 0);
		return clamp(this.roll(2, 6, dm, 'Atmospheric Taint: Severity'), 4, 12);
	}

	genTaintPersistence(atmosphere, taint)
	{
		let dm = 0;
		// DM+4 for High and Low Oxygen taints, or DM+6 if Severity 8+
		if (taint.subtype === TAINT_H || taint.subtype === TAINT_L) dm += (taint.severity > 7 ? 6 : 4);
		// DM+6 for Insidious atmospheres
		if (atmosphere.type === 12) dm += 6;
		return clamp(this.roll(2, 6, dm, 'Atmosphere Taint: Persistence'), 2, 9);
	}
}

function clamp(num, min, max)
{
	return Math.min(Math.max(num, min), max);
}

/**
 * @param Number n
 *
 * @param integer p Maximum desired level of precision
 */
function format(n, p)
{
	// Multiplying by 1 trims trailing zeroes after rounding to maximum desired precision
	return 1 * n.toPrecision(p);
}

function getRandomIntInclusive(min, max)
{
	min = Math.ceil(min);
	max = Math.floor(max);
	return Math.floor(Math.random() * (max - min + 1) + min);
}

function log(msg)
{
	if (debug) console.log(msg);
}

/**
 * Converts a measurement in AU to Orbit#
 *
 * @param float au Distance in AU (Astronomical Units)
 *
 * @return float Orbit# equivalent
 */
function auToOrbit(au)
{
	const i = ORBIT_AU.findLastIndex((entry) => entry <= au);
	if (i === undefined || i < 0) {
		return 0;
	} else if (i >= 20) {
		return 20;
	}
	const diff = ORBIT_AU[i + 1] - ORBIT_AU[i];
	return i + ((au - ORBIT_AU[i]) / diff);
}

/**
 * Converts an Orbit# into AU
 *
 * @param float orbit Distance as an Orbit#
 *
 * @return float Astronomical Unit (AU) equivalent
 */
function orbitToAU(orbit)
{
	const n = +Math.floor(orbit);
	const f = orbit - n;
	const base = ORBIT_AU[n];
	const next = ORBIT_AU[n + 1];
	const diff = next - base;
	return base + (f * diff);
}

/**
 * @param float orbit The original Orbit#
 * @param float mod The number of Orbit#s to add to or subtract from the original Orbit#
 *
 * @return float the correctly modified Orbit#, accounting for "whole" increments of 0.1 when Orbit# < 1
 */
function getOrbitPlus(orbit, mod)
{
	// Mod > 0, i.e. increasing effective Orbit#
	if (mod > 0) {
		if (orbit < 1) {
			// The number of Orbit#s needed for Orbit# to reach 1.0
			const one_up = 10 * (1 - orbit);
			return (mod < one_up
				? orbit + (0.1 * mod)
				: 1 + (mod - one_up));
		}
		return orbit + mod;
	}
	// Mod < 0, i.e. reducing effective Orbit#
	if (mod < 0) {
		if (orbit + mod >= 1) {
			return orbit + mod;
		}
		return (orbit > 1
			? 1 + (0.1 * (orbit + mod - 1))
			: orbit + (0.1 * mod));
	}
	return orbit;
}

/**
 * @return float The Habitable Zone Center Orbit# (HZCO) based on the given luminosity value
 */
function calculateHabitableCenterZone(luminosity)
{
	return auToOrbit(Math.sqrt(luminosity));
}

/**
 * @return string Converts a Roman Numeral to its positive integer equivalent
 * @throws SyntaxError if improperly formatted
 */
function convertFromRoman(roman)
{
	const lookup = {C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1};
	let number = 0;
	for (let i = 0; i < roman.length; i++) {
		let k = roman[i];
		if (k === 'I' && (i+1) < roman.length && ['V','X'].includes(roman[i+1])) {
			k = k + roman[i+1];
			i++;
		}
		if (k === 'X' && (i+1) < roman.length && ['C','L'].includes(roman[i+1])) {
			k = k + roman[i+1];
			i++;
		}
		if (!lookup.hasOwnProperty(k)) {
			throw new SyntaxError('Failed to parse invalid Roman Numeral: ' + roman);
		}
		number += lookup[k];
	}
	return number;
}

/**
 * @return string Converts a positive integer < 399 to its Roman Numeral equivalent
 */
function convertToRoman(number)
{
	const lookup = {C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1};
	let roman = '';
	for (const k in lookup) {
		while (number >= lookup[k]) {
			roman += k;
			number -= lookup[k];
		}
	}
	return roman;
}

/**
 * Converts an integer of 33 or less to the corresponding hex code used by e.g. UWP
 */
function toHexCode(number)
{
	if (number < 10) return number;
	// Skip the letter 'O'
	if (number > 22) number++;
	// Skip the letter 'I'
	if (number > 17) number++;
	return String.fromCharCode(number + 65 - 10);
}

/**
 * @return float The number rounded to the specified precision
 */
function round(num, precision)
{
	const base = 10 ** precision;
	return (Math.round(num * base) / base);
}

/**
 * @return string The number with its sign
 */
function signed(num)
{
	return (num > 0 ? '+' + num : num);
}

function getStarSystem(data)
{
	const star_factory = new StarFactory(data);
	const world_factory = new WorldFactory(data);
	const system_factory = new StarSystemFactory(star_factory, world_factory, data);
	const star_profiles = (data.has('system_profile') ? data.get('system_profile').split(':').filter(s => s.length > 0) : []);
	const planetary_profile = (data.has('cont_spp') ? data.getAll('cont_spp').map((s) => s.trim()).map((s) => s.length > 0 ? Number(s) : null) : Array(5).fill(null));
	return system_factory.generate(star_profiles, planetary_profile);
}

function displayStarSystem(system, data)
{
	const s_body = document.getElementById('star_tbl_entries');
	const s_temp = document.getElementById('star_tbl_template');
	const p_body = document.getElementById('planet_tbl_entries');
	const p_temp = document.getElementById('planet_tbl_template');
	s_body.replaceChildren();
	p_body.replaceChildren();
	system.star_groups.forEach(group => {
		addStarTableRow(group, s_body, s_temp, system.n_stellar);
		group.bodies.forEach(body => addPlanetTableRow(body, p_body, p_temp, system.n_stellar));
	});
	system.star_groups.forEach(group => {
		group.bodies.forEach(body => {
			body.bodies.forEach(moon => addPlanetTableRow(moon, p_body, p_temp, system.n_stellar, true));
		});
	});
	const per_star = data.has('per_star_baseline');
	document.querySelectorAll('.toggle-per_star_baseline').forEach((entry) => {
		if (per_star) {
			entry.classList.replace('hide', 'show-table');
		} else {
			entry.classList.replace('show-table', 'hide');
		}
	});
}

function addStarTableRow(entry, body, template, n_stellar = 1)
{
	const clone = template.content.cloneNode(true);
	const row = clone.querySelector('tr');
	const diameter = entry.getTotalDiameter();
	const luminosity = entry.getTotalLuminosity();
	const temperature = entry.getTotalTemperature();
	const independent = (entry.n_bodies > 0 && !entry.isPrimaryComponent());
	let j = 0;
	row.children[j++].innerHTML = entry.getDesignation(n_stellar);
	row.children[j++].innerHTML = entry.getProfileShort();
	row.children[j++].innerHTML = format(entry.getTotalMass(), 3);
	row.children[j++].innerHTML = (diameter < 0 ? '-' : format(diameter, 3));
	row.children[j++].innerHTML = (temperature < 0 ? '-' : temperature.toFixed(1));
	row.children[j++].innerHTML = (luminosity < 0 ? '-' : format(luminosity, 3));
	row.children[j++].innerHTML = entry.getTotalOrbit().toFixed(2) + (entry.orbit_retrograde ? 'R' : '');
	row.children[j++].innerHTML = entry.primary ? '-' : format(entry.orbit_au, 3);
	row.children[j++].innerHTML = entry.primary ? '-' : format(entry.orbit_eccentricity, 3);
	row.children[j++].innerHTML = entry.primary ? '-' : format(entry.orbit_major_min, 3);
	row.children[j++].innerHTML = entry.primary ? '-' : format(entry.orbit_major_max, 3);
	row.children[j++].innerHTML = entry.primary ? '-' : entry.getOrbitalPeriod();
	row.children[j++].innerHTML = entry.isHzcoValid() ? entry.hzco.toFixed(2) : '(' + entry.hzco.toFixed(2) + ')';
	row.children[j++].innerHTML = entry.getAllowedOrbits();
	row.children[j++].innerHTML = entry.orbit_slots;
	row.children[j++].innerHTML = entry.n_bodies + (entry.n_empty > 0 ? ' (' + entry.n_empty + ')' : '');
	row.children[j++].innerHTML = (independent ? entry.baseline_number : '-');
	row.children[j++].innerHTML = (independent ? entry.baseline_orbit : '-');
	row.children[j++].innerHTML = (independent ? entry.getMinimumOrbitSpread() : '-');
	body.appendChild(row);
}

function addPlanetTableRow(entry, body, template, n_stellar = 1, is_moon = false)
{
	const clone = template.content.cloneNode(true);
	const row = clone.querySelector('tr');
	const diameter = entry.getTotalDiameter();
	const mass = entry.getTotalMass();
	let j = 0;
	row.children[j++].innerHTML = entry.getHostStar().getDesignation(n_stellar);
	row.children[j++].innerHTML = entry.getDesignation(0);
	row.children[j++].innerHTML = (mass > 0 ? format(entry.getTotalMass(), 3) : '-');
	row.children[j++].innerHTML = (diameter > 0 ? round(diameter, 3) + (entry.type === PLANET_GAS ? '&CirclePlus;' : 'km') : '-');
	row.children[j++].innerHTML = (entry.density > 0 ? round(entry.density, 3) : '-');
	row.children[j++].innerHTML = (entry.gravity > 0 ? round(entry.gravity, 3) : '-');
	row.children[j++].innerHTML = (entry.temperature_mean < 0 ? '-' : (entry.temperature_mean - 273).toFixed(1));
	row.children[j++].innerHTML = entry.getTotalOrbit().toFixed(2) + (entry.orbit_retrograde ? 'R' : '');
	row.children[j++].innerHTML = (is_moon ? 'PD' : format(entry.orbit_au, 3));
	row.children[j++].innerHTML = format(entry.orbit_eccentricity, 3);
	row.children[j++].innerHTML = (is_moon ? '-' : format(entry.orbit_major_min, 3));
	row.children[j++].innerHTML = (is_moon ? '-' : format(entry.orbit_major_max, 3));
	row.children[j++].innerHTML = entry.getOrbitalPeriod();
	row.children[j++].innerHTML = entry.getProfileShort();
	row.children[j++].innerHTML = (is_moon ? '-' : entry.getSignificantBodyCount());
	row.children[j++].innerHTML = entry.getProfileNotes();
	body.appendChild(row);
}

function buildRollHistoryTable(entry)
{
	const tbl_template = document.getElementById('roll_tbl_template');
	const table = tbl_template.content.cloneNode(true);
	const row_template = document.getElementById('roll_row_template');
	const body = table.querySelector('tbody');
	entry.history.forEach(roll => {
		const clone = row_template.content.cloneNode(true);
		const row = clone.querySelector('tr');
		let j = 0;
		row.children[j++].innerHTML = roll.total;
		row.children[j++].innerHTML = roll.dice();
		row.children[j++].innerHTML = roll.modifier();
		row.children[j++].innerHTML = roll.rolls.join(', ');
		row.children[j++].innerHTML = roll.description;
		body.appendChild(row);
	});
	return table;
}

function toggleShowOptions(event, element, target_id)
{
	event.preventDefault();
	const div = document.getElementById(target_id);
	if (element.innerHTML === 'Show More') {
		element.innerHTML = 'Show Less';
		div.classList.replace('hide', 'show');
	} else {
		element.innerHTML = 'Show More';
		div.classList.replace('show', 'hide');
	}
	return false;
}

window.addEventListener("load", function(event)
{
	document.getElementById('form')?.addEventListener('submit', function(e)
	{
		e.preventDefault();
		const data = new FormData(e.target);
		const err_div = document.getElementById('error');
		err_div.classList.replace('show', 'hide');
		let output = null;
		try {
			output = getStarSystem(data);
		} catch (err) {
			err_div.classList.replace('hide', 'show');
			err_div.innerHTML = err.message;
		}
		if (output instanceof StarSystem) {
			document.getElementById('system_profile_short').innerHTML = output.getProfileShort();
			document.getElementById('system_profile_long').innerHTML = output.getProfileLong().split(':').join('<br>:');
			document.getElementById('system_age').innerHTML = format(output.age, 3) + ' Gyr';
			document.getElementById('system_planet_profile_short').innerHTML = output.getPlanetaryProfileShort();
			document.getElementById('baseline_number').innerHTML = output.baseline_number;
			document.getElementById('baseline_orbit').innerHTML = output.baseline_orbit;
			document.getElementById('system_spread').innerHTML = output.getMinimumOrbitSpread();
			document.getElementById('system_spread_calc').innerHTML = output.orbit_spread;
			document.getElementById('system_spread_max').innerHTML = output.orbit_spread_max;
			document.getElementById('n_stellar').innerHTML = output.n_stellar;
			document.getElementById('n_planet_gas').innerHTML = output.n_planet_gas;
			document.getElementById('n_planet_belt').innerHTML = output.n_planet_belt;
			document.getElementById('n_planet_rock').innerHTML = output.n_planet_rock;
			document.getElementById('n_empty').innerHTML = output.n_empty;
			displayStarSystem(output, data);
			// System generation history
			const history = document.getElementById('roll_history');
			history.innerHTML = '';
			history.appendChild(document.createTextNode('ROLL LOG'));
			history.appendChild(document.createElement('hr'));
			history.appendChild(document.createTextNode('Star System Rolls'));
			history.appendChild(buildRollHistoryTable(output));
			// Star generation history
			output.star_groups.forEach(star => {
				if (star.history.length > 0) {
					history.appendChild(document.createElement('hr'));
					history.appendChild(document.createTextNode('Rolls for ' + (star.primary ? 'Primary ' : 'Secondary ') + star.getProfileLong()));
					history.appendChild(buildRollHistoryTable(star));
				}
				if (star.companion && star.companion.history.length > 0) {
					history.appendChild(document.createElement('hr'));
					history.appendChild(document.createTextNode('Rolls for Companion ' + star.companion.getProfileLong()));
					history.appendChild(buildRollHistoryTable(star.companion));
				}
			});
			// World generation history
			output.star_groups.forEach(group => {
				group.bodies.forEach(body => {
					if (body.history.length > 0) {
						history.appendChild(document.createElement('hr'));
						history.appendChild(document.createTextNode('Rolls for Planet ' + body.getDesignation(output.n_stellar)));
						history.appendChild(buildRollHistoryTable(body));
					}
				});
			});
			// Moon generation history
			output.star_groups.forEach(group => {
				group.bodies.forEach(body => {
					body.bodies.forEach(moon => {
						if (moon.history.length > 0) {
							history.appendChild(document.createElement('hr'));
							history.appendChild(document.createTextNode('Rolls for Moon ' + moon.getDesignation(output.n_stellar)));
							history.appendChild(buildRollHistoryTable(moon));
						}
					});
				});
			});
		}
	});
});

</script>
